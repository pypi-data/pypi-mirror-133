# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['automapper', 'automapper.extensions']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'py-automapper',
    'version': '1.0.1',
    'description': 'Library for automatically mapping one object to another',
    'long_description': '<img src="logo.png" align="left" style="width:128px; margin-right: 20px;" />\n\n# py-automapper\n\n**Version**\n1.0.1\n\n**Author**\nanikolaienko\n\n**Copyright**\nanikolaienko\n\n**License**\nThe MIT License (MIT)\n\n**Last updated**\n5 Jan 2022\n\n**Package Download**\nhttps://pypi.python.org/pypi/py-automapper\n\n**Build Status**\nTODO\n\n---\n\n## Versions\nCheck [CHANGELOG.md](/CHANGELOG.md)\n\n## About\n\n**Python auto mapper** is useful for multilayer architecture which requires constant mapping between objects from separate layers (data layer, presentation layer, etc).\n\nInspired by: [object-mapper](https://github.com/marazt/object-mapper)\n\nThe major advantage of py-automapper is its extensibility, that allows it to map practically any type, discover custom class fields and customize mapping rules. Read more in [documentation](https://anikolaienko.github.io/py-automapper).\n\n## Usage\nInstall package:\n```bash\npip install py-automapper\n```\n\nSimple mapping:\n```python\nfrom automapper import mapper\n\nclass SourceClass:\n    def __init__(self, name: str, age: int, profession: str):\n        self.name = name\n        self.age = age\n        self.profession = profession\n\nclass TargetClass:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n# Register mapping\nmapper.add(SourceClass, TargetClass)\n\nsource_obj = SourceClass("Andrii", 30, "software developer")\n\n# Map object\ntarget_obj = mapper.map(source_obj)\n\n# or one time mapping without registering in mapper\ntarget_obj = mapper.to(TargetClass).map(source_obj)\n\nprint(f"Name: {target_obj.name}; Age: {target_obj.age}; has profession: {hasattr(target_obj, \'profession\')}")\n\n# Output:\n# Name: Andrii; age: 30; has profession: False\n```\n\n## Override fields\nIf you want to override some field and/or add mapping for field not existing in SourceClass:\n```python\nfrom typing import List\nfrom automapper import mapper\n\nclass SourceClass:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\nclass TargetClass:\n    def __init__(self, name: str, age: int, hobbies: List[str]):\n        self.name = name\n        self.age = age\n        self.hobbies = hobbies\n\nmapper.add(SourceClass, TargetClass)\n\nsource_obj = SourceClass("Andrii", 30)\nhobbies = ["Diving", "Languages", "Sports"]\n\n# Override `age` and provide missing field `hobbies`\ntarget_obj = mapper.map(source_obj, age=25, hobbies=hobbies)\n\nprint(f"Name: {target_obj.name}; Age: {target_obj.age}; hobbies: {target_obj.hobbies}")\n# Output:\n# Name: Andrii; Age: 25; hobbies: [\'Diving\', \'Languages\', \'Sports\']\n\n# Modifying initial `hobbies` object will not modify `target_obj`\nhobbies.pop()\n\nprint(f"Hobbies: {hobbies}")\nprint(f"Target hobbies: {target_obj.hobbies}")\n\n# Output:\n# Hobbies: [\'Diving\', \'Languages\']\n# Target hobbies: [\'Diving\', \'Languages\', \'Sports\']\n```\n\n## Extensions\n`py-automapper` has few predefined extensions for mapping to classes for frameworks:\n* [FastAPI](https://github.com/tiangolo/fastapi) and [Pydantic](https://github.com/samuelcolvin/pydantic)\n* [TortoiseORM](https://github.com/tortoise/tortoise-orm)\n\nWhen you first time import `mapper` from `automapper` it checks default extensions and if modules are found for these extensions, then they will be automatically loaded for default `mapper` object.\n\nWhat does extension do? To know what fields in Target class are available for mapping `py-automapper` need to extract the list of these fields. There is no generic way to do that for all Python objects. For this purpose `py-automapper` uses extensions.\n\nList of default extensions can be found in [/automapper/extensions](/automapper/extensions) folder. You can take a look how it\'s done for a class with `__init__` method or for Pydantic or TortoiseORM models.\n\nYou can create your own extension and register in `mapper`:\n```python\nfrom automapper import mapper\n\nclass TargetClass:\n    def __init__(self, **kwargs):\n        self.name = kwargs["name"]\n        self.age = kwargs["age"]\n    \n    @staticmethod\n    def get_fields(cls):\n        return ["name", "age"]\n\nsource_obj = {"name": "Andrii", "age": 30}\n\ntry:\n    # Map object\n    target_obj = mapper.to(TargetClass).map(source_obj)\nexcept Exception as e:\n    print(f"Exception: {repr(e)}")\n    # Output:\n    # Exception: KeyError(\'name\')\n\n    # mapper could not find list of fields from BaseClass\n    # let\'s register extension for class BaseClass and all inherited ones\n    mapper.add_spec(TargetClass, TargetClass.get_fields)\n    target_obj = mapper.to(TargetClass).map(source_obj)\n\n    print(f"Name: {target_obj.name}; Age: {target_obj.age}")\n```\n\nYou can also create your own clean Mapper without any extensions and define extension for very specific classes, e.g. if class accepts `kwargs` parameter in `__init__` method and you want to copy only specific fields. Next example is a bit complex but probably rarely will be needed:\n```python\nfrom typing import Type, TypeVar\n\nfrom automapper import Mapper\n\n# Create your own Mapper object without any predefined extensions\nmapper = Mapper()\n\nclass TargetClass:\n    def __init__(self, **kwargs):\n        self.data = kwargs.copy()\n\n    @classmethod\n    def fields(cls):\n        return ["name", "age", "profession"]\n\nsource_obj = {"name": "Andrii", "age": 30, "profession": None}\n\ntry:\n    target_obj = mapper.to(TargetClass).map(source_obj)\nexcept Exception as e:\n    print(f"Exception: {repr(e)}")\n    # Output:\n    # Exception: MappingError("No spec function is added for base class of <class \'type\'>")\n\n# Instead of using base class, we define spec for all classes that have `fields` property\nT = TypeVar("T")\n\ndef class_has_fields_property(target_cls: Type[T]) -> bool:\n    return callable(getattr(target_cls, "fields", None))\n    \nmapper.add_spec(class_has_fields_property, lambda t: getattr(t, "fields")())\n\ntarget_obj = mapper.to(TargetClass).map(source_obj)\nprint(f"Name: {target_obj.data[\'name\']}; Age: {target_obj.data[\'age\']}; Profession: {target_obj.data[\'profession\']}")\n# Output:\n# Name: Andrii; Age: 30; Profession: None\n\n# Skip `None` value\ntarget_obj = mapper.to(TargetClass).map(source_obj, skip_none_values=True)\nprint(f"Name: {target_obj.data[\'name\']}; Age: {target_obj.data[\'age\']}; Has profession: {hasattr(target_obj, \'profession\')}")\n# Output:\n# Name: Andrii; Age: 30; Has profession: False\n```\n',
    'author': 'Andrii Nikolaienko',
    'author_email': 'anikolaienko14@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/anikolaienko/py-automapper',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
