#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @PypiSeedTag: Main
# @Author : LeiXueWei
# @CSDN/Juejin/Wechat: 雷学委
# @XueWeiTag: CodingDemo
# @File : app2022.py
# @Project : prize


"""
generated by PypiSeed(PPC) - Main Program
"""
import datetime
import re
import threading
import time
import math
from random import *
from tkinter import Frame, IntVar

import pyperclip
import ttkbootstrap
import ttkbootstrap as ttk
from ttkbootstrap.constants import *

from prize.ui.menu_setting import *
from prize.util.number import padding0
from prize.util.ui_placer import centralize, right

BG_COLOR = 'skyblue'

sample_label = "小白%s"
all_people = []
for i in range(10):
    all_people.append(sample_label % i)
PRIZE_META = {"values": all_people, "items": [], "items_values": [], 'pickOnTime': -1, "terminated": False,
              "pickerWinOpen": False}


def schedule_picker(root: ttk.Window = None):
    if PRIZE_META['pickerWinOpen']:
        mb.showwarning(POPUP_TITLE, "请勿重复操作，已打开定时窗口！")
        return
    secondary = ttk.Toplevel(master=root, title=POPUP_TITLE)
    right(secondary, root, 226, 102)
    clock_label = ttk.Label(secondary, bootstyle="danger", borderwidth=3,
                            text=time.strftime(' %Y-%m-%d\n%H:%M:%S', time.localtime(time.time())))
    # toplevel_hook = IntVar(0) #has issue on Python3.10
    toplevel_hook = {'value': 0}

    def update_clock():
        while toplevel_hook['value'] == 0:
            if PRIZE_META['terminated']:
                return
            current_time = time.strftime('%Y-%m-%d\n%H:%M:%S', time.localtime(time.time()))
            clock_label.config(text=current_time)
            secondary.update()
            time.sleep(1)

    t = threading.Thread(target=update_clock)
    t.start()

    def on_closing():
        try:
            toplevel_hook['value'] = -1
            secondary.destroy()
        finally:
            PRIZE_META['pickerWinOpen'] = False

    secondary.protocol("WM_DELETE_WINDOW", on_closing)
    hour_label = ttk.Label(secondary, bootstyle="info", text="时[0,23]：")
    min_label = ttk.Label(secondary, bootstyle="info", text="分[0,59]：")
    sec_label = ttk.Label(secondary, bootstyle="info", text="秒[0,59]：")
    hour_text = ttk.Entry(secondary, background="skyblue", width=6)

    def handle_hour_keys(event):
        # print("event:", event)
        min_text.focus_force()

    def handle_min_keys(event):
        print("event:", event)
        sec_text.focus_force()

    def handle_sec_keys(event):
        # print("event:", event)
        hour_text.focus_force()

    hour_text.bind("<Tab>", handle_hour_keys)
    min_text = ttk.Entry(secondary, background="skyblue", width=6)
    min_text.bind("<Tab>", handle_min_keys)
    sec_text = ttk.Entry(secondary, background="skyblue", width=6)
    sec_text.bind("<Tab>", handle_sec_keys)
    hour_text.insert(END, "00")
    min_text.insert(END, "00")
    sec_text.insert(END, "00")

    def set_pick_time():
        hour = hour_text.get().strip()
        if not re.search("(^[0-1]{0,1}[0-9]$)|(^[2][0-3]$)", hour):
            print("Illegal input for hour：", hour)
            mb.showerror(POPUP_TITLE, "小时必须在0到23之内")
            return
        min = min_text.get().strip()
        if not re.search("^[0-5]{0,1}[0-9]$", min):
            print("Illegal input for min：", min)
            mb.showerror(POPUP_TITLE, "分钟必须在0到59之内")
            return
        sec = sec_text.get().strip()
        if not re.search("^[0-5]{0,1}[0-9]$", sec):
            print("Illegal input for second：", sec)
            mb.showerror(POPUP_TITLE, "秒数必须在0到59之内")
            return
        PRIZE_META['pickOnTime'] = padding0(hour) + ":" + padding0(min) + ":" + padding0(sec)
        print("PRIZE_META['pickOnTime']:", PRIZE_META['pickOnTime'])
        # secondary.destroy()

    confirm = ttk.Button(secondary, text="预约抽奖", width=10, padding=4,
                         command=set_pick_time)
    hour_label.grid(column=0, row=0, sticky=NSEW)
    hour_text.grid(column=1, row=0, sticky=NSEW)
    clock_label.grid(column=2, row=0, rowspan=3, sticky=NSEW)
    min_label.grid(column=0, row=1, sticky=NSEW)
    min_text.grid(column=1, row=1, sticky=NSEW)
    sec_label.grid(column=0, row=2, sticky=NSEW)
    sec_text.grid(column=1, row=2, sticky=NSEW)
    confirm.grid(column=0, row=3, columnspan=3, sticky=NSEW)
    PRIZE_META['pickerWinOpen'] = True
    secondary.rowconfigure(0, weight=1, pad=1)
    secondary.rowconfigure(1, weight=1, pad=1)
    secondary.rowconfigure(2, weight=1, pad=1)
    secondary.rowconfigure(3, weight=1, pad=1)
    secondary.columnconfigure(0, weight=1, pad=1)
    secondary.columnconfigure(1, weight=1, pad=1)
    secondary.columnconfigure(2, weight=1, pad=1)
    # secondary.mainloop()


def figure_table(size):
    col = 5
    row = size / 5
    if size % 5 != 0 and size != 0:
        row += 1
    return row, col


"""
prize  ui
"""


class ChouJiang(object):
    def __init__(self, root):
        self.root = root

    def setup_root_win(self):
        self.root.title(POPUP_TITLE)
        centralize(self.root, 604, 700)
        self.root.minsize(604, 700)
        self.root.configure(bg=BG_COLOR)
        self.root.bind('<Configure>', self.window_resize)
        self.name_list_btn = ttk.Button(self.root, bootstyle=PRIMARY, text="黏贴抽奖人员名单", padding=2,
                                        command=self.paste_namelist)
        self.generator_btn = ttk.Button(self.root, text="生成卡片", bootstyle=PRIMARY, padding=2,
                                        command=self.render_text_into_cards)
        self.generator_soft_toggle = True
        self.process_btn = ttk.Button(self.root, text="重新抽奖", bootstyle=SUCCESS, padding=2,
                                      command=self.start_prize_picker)
        paned_win = ttk.Frame(master=self.root, bootstyle="info")
        self.paned_win = paned_win
        self.winner_id = -1
        self.render_labels_on_panel(paned_win, self.root)
        self.names_text = ttk.Text(self.root, relief="flat")

        self.group = ttk.LabelFrame(self.root, padding=3, bootstyle="info", text='提取ID卡片方式？')
        self.set_data_process_options()
        self.default_name_text = "<点击上方按钮 或者 这里黏贴参与活动人员>"
        self.names_text.insert(0.0, self.default_name_text)
        # 布局
        self.name_list_btn.grid(row=0, column=0, columnspan=2, sticky=NSEW)
        self.group.grid(row=1, column=0, columnspan=2, sticky=NSEW)
        self.names_text.grid(row=2, column=0, columnspan=2, sticky=NSEW)
        self.generator_btn.grid(row=3, column=0, sticky=NSEW, ipadx=2, ipady=2)
        self.process_btn.grid(row=3, column=1, sticky=NSEW, ipadx=2, ipady=2)
        self.paned_win.grid(row=4, column=0, sticky=NSEW, columnspan=2, ipadx=0, ipady=0)
        self.root.rowconfigure(0, weight=1, pad=1)
        self.root.rowconfigure(1, weight=1, pad=1)
        self.root.rowconfigure(2, weight=1, pad=1)
        self.root.rowconfigure(3, weight=1, pad=1)
        self.root.rowconfigure(4, weight=1, pad=1)
        self.root.columnconfigure(0, weight=1, pad=1)
        self.root.columnconfigure(1, weight=1, pad=1)
        # start monitor
        clock_monitor = threading.Thread(target=self.monitor_clock)
        clock_monitor.setDaemon(True)
        clock_monitor.start()
        self.resizing_time = -1
        resizing_monitor = threading.Thread(target=self.monitor_resizing)
        resizing_monitor.setDaemon(True)
        resizing_monitor.start()
        print("end of ui rendering")

    def window_resize(self, event):
        # print("resize...%s" % str(event))
        if event:
            # print("event %s " % event.width)
            self.resizing_time = time.time()
            self.current_width = event.width

    def set_data_process_options(self):
        OPTS = [
            ("按行取ID  ", 0),
            ("按'ID:评论'提取ID  ", 1),
            ("按'ID：评论'提取ID  ", 2)]
        self.user_opt = ttk.IntVar()
        for index in range(0, len(OPTS)):
            opt, num = OPTS[index]
            # print("opt=%s, num=%s" % (opt, num))
            # bootstyle = "info-outline-toolbutton"
            bootstyle = "primary"
            b = ttk.Radiobutton(self.group, text=opt, bootstyle=bootstyle, variable=self.user_opt,
                                value=num, command=self.load_data_per_opt)
            b.grid(row=0, column=index)

    def load_data_per_opt(self):
        opt = self.user_opt.get()
        # print("opt is ", opt)

    def paste_namelist(self):
        self.name_list_btn.configure(state=DISABLED)
        try:
            values = pyperclip.paste()
            time.sleep(0.3)
            self.names_text.delete('1.0', 'end')
            self.names_text.insert(0.0, values)
        finally:
            self.name_list_btn.configure(state=NORMAL)

    def render_labels_on_panel(self, paned_win: Frame, root: ttkbootstrap.Window):
        all_items = PRIZE_META['items']
        all_items_values = PRIZE_META['items_values']
        all_items.clear()
        all_items_values.clear()
        children = paned_win.children
        # print("existing children:", len(children))
        for item in children:
            paned_win.remove(item)
        children = paned_win.children
        children.clear()
        paned_win = ttk.Frame(master=root, bootstyle="info")
        paned_win.config(height=100)
        paned_win.grid_propagate(0)
        paned_win.winfo_height()
        paned_win.grid(row=4, column=0, sticky=NSEW, columnspan=2)
        # paned_win.configure(background=BG_COLOR)
        people = PRIZE_META['values']
        num = len(people)
        row, col = figure_table(num)
        # print("row %s , col %s" % (row, col))
        row_id = 0
        col_id = 0
        # print("root width:", root.winfo_width())
        default_card_width = 120
        item_per_row = 5
        if len(people) >= 100:
            default_card_width = 60
            item_per_row = math.floor(root.winfo_width() / (default_card_width + 10)) - 1
        elif root.winfo_width() > 620:
            item_per_row = math.floor(root.winfo_width() / default_card_width + 10) - 1

        for i in range(0, item_per_row):
            paned_win.columnconfigure(i, weight=1, pad=1)
        counter = 0
        for person in people:
            counter += 1
            # bootstyle = "inverse-outline"
            # item = ttk.Label(paned_win, bootstyle=bootstyle, text=p, borderwidth=3, width=default_label_width)
            bootstyle = "info"
            display_text = str(person)
            if len(display_text) > 10:
                display_text = display_text[0:10]
            item = ttk.Button(paned_win, bootstyle=bootstyle, text=display_text)
            # print("highlight2 item %s" % self.winner_id)
            if self.winner_id == person:
                # print("highlight item %s"% self.winner_id)
                item.configure(bootstyle="danger")
            all_items.append(item)
            all_items_values.append(person)
            # paned_win.add(item)
            item.grid(row=row_id, column=col_id, sticky=NSEW)
            col_id += 1
            if counter % item_per_row == 0:
                row_id += 1
                col_id = 0
        root.update()

    def focus_item(self, rand: int, total: int, trigger_button: ttk.Button):
        def flash_red():
            # print("start flashing")
            data_list = [x for x in range(total)]
            shuffle(data_list)
            all_items = PRIZE_META['items']
            for x in data_list:
                item = all_items[x]
                item.configure(bootstyle="danger")
                time.sleep(0.1)
                item.configure(bootstyle="info")

        def highlight_winner(rand, item: ttk.Button):
            item.focus()
            item.configure(bootstyle="danger")
            item.update()
            try:
                # winner = item.cget('text')
                all_items_values = PRIZE_META['items_values']
                winner_fullname = all_items_values[rand]
                print("winner is:", winner_fullname)
                self.winner_id = winner_fullname
                # winner = "杜甫"
                mb.showinfo(POPUP_TITLE, "恭喜幸运个体【" + winner_fullname + "】！")
            except Exception as err:
                print("Fail to popup the winner info：%s" % str(err))

        try:
            all_items = PRIZE_META['items']
            each = all_items[rand]
            # print("each : ", each)
            flash_red()
            highlight_winner(rand, each)
        except Exception as e:
            print("all item =%s" % str(all_items))
            print("rand =%s" % str(rand))
        finally:
            trigger_button.configure(state=NORMAL)
            self.generator_soft_toggle = True
            print("end of processing")

    def monitor_resizing(self):
        self.previous_resizing_time = 0
        self.current_width = 0
        self.previous_resizing_width = 0
        while not PRIZE_META['terminated']:
            if self.previous_resizing_time != self.resizing_time:
                self.previous_resizing_time = self.resizing_time
                time.sleep(0.3)
                continue
            try:
                if math.fabs(self.previous_resizing_width - self.current_width) > 100:
                    print("re-rendering UI")
                    self.previous_resizing_width = self.current_width
                    self.render_labels_on_panel(self.paned_win, self.root)
            except Exception as e:
                pass
            time.sleep(1)

    def monitor_clock(self):
        while not PRIZE_META['terminated']:
            try:
                schedule_time = PRIZE_META['pickOnTime']
                min = 70
                hour = 26
                if re.search("^[0-9]{2}:[0-9]{2}:[0-9]{2}$", str(schedule_time)):
                    min = int(schedule_time.split(':')[1])
                    hour = int(schedule_time.split(':')[0])
                current = datetime.datetime.now()
                if abs(min - current.minute) > 2 or abs(hour - current.hour) > 2:
                    # print("Wait more time as clock is not closer")
                    time.sleep(2)
                # print("PRIZE_META['pickOnTime']:", PRIZE_META['pickOnTime'])
                time_str = padding0(current.hour) + ":" + padding0(current.minute) + ":" + padding0(current.second)
                # print("time_str :", time_str)
                if time_str == PRIZE_META['pickOnTime']:
                    print("on time")
                    PRIZE_META['pickOnTime'] = -1
                    self.start_prize_picker()
            finally:
                time.sleep(0.5)

    def start_prize_picker(self):
        self.process_btn.configure(state=DISABLED)
        self.generator_soft_toggle = False
        print("start prize picker")
        try:
            # Column integer to match the column which was clicked in the table
            # Create list of 'id's
            all_people = PRIZE_META['values']
            people_num = len(all_people)
            # print("people_num:", people_num)
            rand = choice(range(people_num))
            # print("随机数：", rand)
            all_items = PRIZE_META['items']
            for item in all_items:
                # item.configure(background='skyblue')
                item.configure(bootstyle="info")
            time.sleep(0.5)

            def my_focus_item():
                return self.focus_item(rand, people_num, self.process_btn)

            t = threading.Thread(target=my_focus_item)
            t.setDaemon(False)
            t.start()
        except Exception as err:
            self.generator_soft_toggle = True
            self.process_btn.configure(state=NORMAL)

    def render_text_into_cards(self):
        # self.generator_btn.configure(state=DISABLED) #disable will make button color as 'white' not so beautiful.
        # use a soft toggle to disable generation
        if not self.generator_soft_toggle:
            return
        try:
            self.winner_id = -1
            comment = self.names_text.get(1.0, END).strip()
            if comment is None or comment == '' or not comment or comment == self.default_name_text:
                mb.showinfo(POPUP_TITLE, "请输入有效的名单")
                return
            # print("comment:", comment)
            lines = comment.split("\n")
            # print("number of lines:", len(lines))
            dataset = set(lines)
            # print("number of unique lines:", len(dataset))
            colspacings = []
            id_opt = self.user_opt.get()
            if id_opt == 0:
                for line in dataset:
                    colspacings.append(line.strip())
            elif id_opt == 1:
                for line in dataset:
                    if ':' in line:
                        id = line[:line.index(':')]
                        colspacings.append(id)
            elif id_opt == 2:
                for line in dataset:
                    if '：' in line:
                        id = line[:line.index('：')]
                        colspacings.append(id)
            # print("colspacings:", colspacings)
            PRIZE_META['values'] = colspacings
            self.render_labels_on_panel(self.paned_win, self.root)
        finally:
            # self.generator_btn.configure(state=NORMAL)
            pass

    def clear_data(self):
        pass


def construct_menu(root):
    menu_bar = ttk.Menu(root)
    about_menu = ttk.Menu(menu_bar)
    setting_menu = ttk.Menu(menu_bar)
    about_menu.add_command(label='版权信息', command=show_copyright)
    about_menu.add_command(label='操作说明', command=show_about)
    about_menu.add_command(label='升级', command=trigger_upgrade)
    setting_menu.add_command(label='创建桌面快捷方式', command=make_shortcut)
    setting_menu.add_command(label='定时抽奖', command=lambda: schedule_picker(root))
    menu_bar.add_cascade(label="使用介绍", menu=about_menu)
    menu_bar.add_cascade(label="更多配置", menu=setting_menu)
    return menu_bar


def app_start():
    try:
        root = ttk.Window()
        root.config(menu=construct_menu(root))
        prize_ui = ChouJiang(root)
        prize_ui.setup_root_win()
        root.mainloop()
    finally:
        PRIZE_META['terminated'] = True
        print("program terminated, bye")
        sys.exit(0)


def main():
    hello = "hello prize,2022"
    print(hello)
    return hello


if __name__ == '__main__':
    main()
    app_start()
