"""
PySide stub files generated by **IceSpringPySideStubs**

Home: https://baijifeilong.github.io/2022/01/06/ice-spring-pyside-stubs/index.html

Github: https://github.com/baijifeilong/IceSpringPySideStubs

PyPI(PySide2): https://pypi.org/project/IceSpringPySideStubs-PySide2

PyPI(PySide6): https://pypi.org/project/IceSpringPySideStubs-PySide6

PyPI(PyQt5): https://pypi.org/project/IceSpringPySideStubs-PyQt5

Generated by BaiJiFeiLong@gmail.com

Licence: GPLv3
"""
import typing
from PyQt5 import QtNetwork
from PyQt5 import QtCore
from PyQt5 import sip


class QQmlNetworkAccessManagerFactory(sip.simplewrapper):
    """
    https://doc.qt.io/qt-5/qqmlnetworkaccessmanagerfactory.html

    **Detailed Description**

    A QML engine uses QNetworkAccessManager for all network access. By
    implementing a factory, it is possible to provide the QML engine with custom
    QNetworkAccessManager instances with specialized caching, proxy and cookies
    support.

    To implement a factory, subclass QQmlNetworkAccessManagerFactory and
    implement the virtual **create** () method, then assign it to the relevant
    QML engine using **QQmlEngine::setNetworkAccessManagerFactory** ().

    Note the QML engine may create QNetworkAccessManager instances from multiple
    threads. Because of this, the implementation of the **create** () method
    must be **reentrant** . In addition, the developer should be careful if the
    signals of the object to be returned from **create** () are connected to the
    slots of an object that may be created in a different thread:

    * The QML engine internally handles all requests, and cleans up any
    QNetworkReply objects it creates. Receiving the
    QNetworkAccessManager::finished() signal in another thread may not provide
    the receiver with a valid reply object if it has already been deleted.
      *
    Authentication details provided to
    QNetworkAccessManager::authenticationRequired() must be provided
    immediately, so this signal cannot be connected as a
    **Qt::QueuedConnection**  (or as the default **Qt::AutoConnection**  from
    another thread).

    For more information about signals and threads, see **Threads and QObjects**
    and **Signals and Slots Across Threads** .

    **See also** **Network Access Manager Factory Example** .
    """

    @typing.overload
    def __init__(self) -> None:
        ...

    @typing.overload
    def __init__(self, a0: "QQmlNetworkAccessManagerFactory") -> None:
        ...

    def create(self, parent: QtCore.QObject) -> QtNetwork.QNetworkAccessManager:
        """
        https://doc.qt.io/qt-5/qqmlnetworkaccessmanagerfactory.html#create

        **[pure virtual] QNetworkAccessManager
        *QQmlNetworkAccessManagerFactory::create(QObject * parent )**

        Creates and returns a network access manager with the specified
        **parent**. This method must return a new QNetworkAccessManager instance
        each time it is called.

        Note: this method may be called by multiple threads, so ensure the
        implementation of this method is reentrant.
        """
        ...
