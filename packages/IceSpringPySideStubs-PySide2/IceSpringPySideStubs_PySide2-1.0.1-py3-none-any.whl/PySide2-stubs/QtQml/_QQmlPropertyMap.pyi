"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtNetwork
import PySide2.QtQml

bytes = str


class QQmlPropertyMap(PySide2.QtCore.QObject):
    """
    **Detailed Description**

    QQmlPropertyMap provides a convenient way to expose domain data to the UI layer. The following example shows how you might declare data in C++ and then access it in QML.

    In the C++ file:

    // create our data
        **QQmlPropertyMap**  ownerData;
        ownerData.insert("name", **QVariant** (**QString** ("John Smith")));
        ownerData.insert("phone", **QVariant** (**QString** ("555-5555")));

        // expose it to the UI layer
        **QQuickView**  view;
        **QQmlContext**  *ctxt = view.rootContext();
        ctxt->setContextProperty("owner", &ownerData);

        view.setSource(**QUrl** ::fromLocalFile("main.qml"));
        view.show();

    Then, in `main.qml`:

    Text { text: owner.name + " " + owner.phone }

    The binding is dynamic - whenever a key\'s value is updated, anything bound to that key will be updated as well.

    To detect value changes made in the UI layer you can connect to the **valueChanged** () signal. However, note that **valueChanged** () is **NOT** emitted when changes are made by calling **insert** () or **clear** () - it is only emitted when a value is updated from QML.

    **Note:** It is not possible to remove keys from the map; once a key has been added, you can only modify or clear its associated value.

    **Note:** When deriving a class from QQmlPropertyMap, use the **protected two-argument constructor**  which ensures that the class is correctly registered with the Qt **Meta-Object System** .

    **Note:** The **QMetaObject**  of a QQmlPropertyMap is dynamically generated and modified. Operations on that meta object are not thread safe, so applications need to take care to explicitly synchronize access to the meta object.
    """

    def __init__(self, parent: typing.Optional[PySide2.QtCore.QObject] = ...) -> None:
        """
        **QQmlPropertyMap::QQmlPropertyMap(QObject * parent = nullptr)**

        Constructs a bindable map with parent object **parent**.
        """
        ...

    def clear(self, key: str) -> None:
        """
        **void QQmlPropertyMap::clear(const QString & key )**

        Clears the value (if any) associated with **key**.
        """
        ...

    def contains(self, key: str) -> bool:
        """
        **bool QQmlPropertyMap::contains(const QString & key ) const**

        Returns true if the map contains **key**.

        **See also** **size** ().
        """
        ...

    def count(self) -> int:
        """
        **int QQmlPropertyMap::count() const**

        This is an overloaded function.

        Same as **size** ().
        """
        ...

    def insert(self, key: str, value: typing.Any) -> None:
        """
        **void QQmlPropertyMap::insert(const QString & key , const QVariant & value )**

        Sets the value associated with **key** to **value**.

        If the key doesn't exist, it is automatically created.
        """
        ...

    def isEmpty(self) -> bool:
        """
        **bool QQmlPropertyMap::isEmpty() const**

        Returns true if the map contains no keys; otherwise returns false.

        **See also** **size** ().
        """
        ...

    def keys(self) -> typing.List:
        """
        **QStringList QQmlPropertyMap::keys() const**

        Returns the list of keys.

        Keys that have been cleared will still appear in this list, even though their associated values are invalid QVariants.

        **Note:** This function can be invoked via the meta-object system and from QML. See **Q_INVOKABLE** .
        """
        ...

    def size(self) -> int:
        """
        **int QQmlPropertyMap::size() const**

        Returns the number of keys in the map.

        **See also** **isEmpty** () and **count** ().
        """
        ...

    def updateValue(self, key: str, input: typing.Any) -> typing.Any:
        """
        **[virtual protected] QVariant QQmlPropertyMap::updateValue(const QString & key , const QVariant & input )**

        Returns the new value to be stored for the key **key**. This function is provided to intercept updates to a property from QML, where the value provided from QML is **input**.

        Override this function to manipulate the property value as it is updated. Note that this function is only invoked when the value is updated from QML.
        """
        ...

    def value(self, key: str) -> typing.Any:
        """
        **QVariant QQmlPropertyMap::value(const QString & key ) const**

        Returns the value associated with **key**.

        If no value has been set for this key (or if the value has been cleared), an invalid **QVariant**  is returned.
        """
        ...

    @property
    def valueChanged(self) -> PySide2.QtCore.SignalInstance:
        """
        **[signal] void QQmlPropertyMap::valueChanged(const QString & key , const QVariant & value )**

        This signal is emitted whenever one of the values in the map is changed. **key** is the key corresponding to the **value** that was changed.

        **Note:** valueChanged() is **NOT** emitted when changes are made by calling **insert** () or **clear** () - it is only emitted when a value is updated from QML.
        """
        ...
