"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtNetwork
import PySide2.QtQml

bytes = str


class QQmlProperty(object):
    """
    **Detailed Description**

    As QML uses Qt\'s meta-type system all of the existing **QMetaObject**  classes can be used to introspect and interact with objects created by QML. However, some of the new features provided by QML - such as type safety and attached properties - are most easily used through the QQmlProperty class that simplifies some of their natural complexity.

    Unlike **QMetaProperty**  which represents a property on a class type, QQmlProperty encapsulates a property on a specific object instance. To read a property\'s value, programmers create a QQmlProperty instance and call the **read** () method. Likewise to write a property value the **write** () method is used.

    For example, for the following QML code:

    // MyItem.qml
        import QtQuick 2.0

        **Text**  { text: "A bit of text" }

    The **Text**  object\'s properties could be accessed using QQmlProperty, like this:

    #include <QQmlProperty>
        #include <QGraphicsObject>

        ...

        **QQuickView**  view(**QUrl** ::fromLocalFile("MyItem.qml"));
        **QQmlProperty**  property(view.rootObject(), "font.pixelSize");
        **qWarning** () << "Current pixel size:" << property.read().toInt();
        property.write(24);
        **qWarning** () << "Pixel size should now be 24:" << property.read().toInt();
    """

    Invalid: QQmlProperty = ...
    InvalidCategory: QQmlProperty = ...
    List: QQmlProperty = ...
    Property: QQmlProperty = ...
    Object: QQmlProperty = ...
    SignalProperty: QQmlProperty = ...
    Normal: QQmlProperty = ...

    class PropertyTypeCategory(object):
        InvalidCategory: QQmlProperty.PropertyTypeCategory = ...
        List: QQmlProperty.PropertyTypeCategory = ...
        Object: QQmlProperty.PropertyTypeCategory = ...
        Normal: QQmlProperty.PropertyTypeCategory = ...

    class Type(object):
        Invalid: QQmlProperty.Type = ...
        Property: QQmlProperty.Type = ...
        SignalProperty: QQmlProperty.Type = ...

    @typing.overload
    def __init__(self) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(self, arg__1: PySide2.QtCore.QObject) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(
        self, arg__1: PySide2.QtCore.QObject, arg__2: PySide2.QtQml.QQmlContext
    ) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(
        self, arg__1: PySide2.QtCore.QObject, arg__2: PySide2.QtQml.QQmlEngine
    ) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(self, arg__1: PySide2.QtCore.QObject, arg__2: str) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(
        self,
        arg__1: PySide2.QtCore.QObject,
        arg__2: str,
        arg__3: PySide2.QtQml.QQmlContext,
    ) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(
        self,
        arg__1: PySide2.QtCore.QObject,
        arg__2: str,
        arg__3: PySide2.QtQml.QQmlEngine,
    ) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @typing.overload
    def __init__(self, arg__1: PySide2.QtQml.QQmlProperty) -> None:
        """
        **QQmlProperty::QQmlProperty()**

        Create an invalid QQmlProperty.
        """
        ...

    @staticmethod
    def __copy__() -> None:
        ...

    @typing.overload
    def connectNotifySignal(self, dest: PySide2.QtCore.QObject, method: int) -> bool:
        """
        **bool QQmlProperty::connectNotifySignal(QObject * dest , const char * slot ) const**

        Connects the property's change notifier signal to the specified **slot** of the **dest** object and returns true. Returns false if this metaproperty does not represent a regular Qt property or if it has no change notifier signal, or if the **dest** object does not have the specified **slot**.

        **Note:** **slot** should be passed using the SLOT() macro so it is correctly identified.
        """
        ...

    @typing.overload
    def connectNotifySignal(self, dest: PySide2.QtCore.QObject, slot: bytes) -> bool:
        """
        **bool QQmlProperty::connectNotifySignal(QObject * dest , const char * slot ) const**

        Connects the property's change notifier signal to the specified **slot** of the **dest** object and returns true. Returns false if this metaproperty does not represent a regular Qt property or if it has no change notifier signal, or if the **dest** object does not have the specified **slot**.

        **Note:** **slot** should be passed using the SLOT() macro so it is correctly identified.
        """
        ...

    def hasNotifySignal(self) -> bool:
        """
        **bool QQmlProperty::hasNotifySignal() const**

        Returns true if the property has a change notifier signal, otherwise false.
        """
        ...

    def index(self) -> int:
        """
        **int QQmlProperty::index() const**

        Return the Qt metaobject index of the property.
        """
        ...

    def isDesignable(self) -> bool:
        """
        **bool QQmlProperty::isDesignable() const**

        Returns true if the property is designable, otherwise false.
        """
        ...

    def isProperty(self) -> bool:
        """
        **bool QQmlProperty::isProperty() const**

        Returns true if this **QQmlProperty**  represents a regular Qt property.
        """
        ...

    def isResettable(self) -> bool:
        """
        **bool QQmlProperty::isResettable() const**

        Returns true if the property is resettable, otherwise false.
        """
        ...

    def isSignalProperty(self) -> bool:
        """
        **bool QQmlProperty::isSignalProperty() const**

        Returns true if this **QQmlProperty**  represents a QML signal property.
        """
        ...

    def isValid(self) -> bool:
        """
        **bool QQmlProperty::isValid() const**

        Returns true if the **QQmlProperty**  refers to a valid property, otherwise false.
        """
        ...

    def isWritable(self) -> bool:
        """
        **bool QQmlProperty::isWritable() const**

        Returns true if the property is writable, otherwise false.
        """
        ...

    def method(self) -> PySide2.QtCore.QMetaMethod:
        """
        **QMetaMethod QQmlProperty::method() const**

        Return the **QMetaMethod**  for this property if it is a **SignalProperty** , otherwise returns an invalid **QMetaMethod** .
        """
        ...

    def name(self) -> str:
        """
        **QString QQmlProperty::name() const**

        Return the name of this QML property.
        """
        ...

    def needsNotifySignal(self) -> bool:
        """
        **bool QQmlProperty::needsNotifySignal() const**

        Returns true if the property needs a change notifier signal for bindings to remain upto date, false otherwise.

        Some properties, such as attached properties or those whose value never changes, do not require a change notifier.
        """
        ...

    def object(self) -> PySide2.QtCore.QObject:
        """
        **QObject *QQmlProperty::object() const**

        Returns the **QQmlProperty** 's **QObject** .
        """
        ...

    def property(self) -> PySide2.QtCore.QMetaProperty:
        """
        **QMetaProperty QQmlProperty::property() const**

        Returns the **Qt property**  associated with this QML property.
        """
        ...

    def propertyType(self) -> int:
        """
        **int QQmlProperty::propertyType() const**

        Returns the **QVariant**  type of the property, or QVariant::Invalid if the property has no **QVariant**  type.
        """
        ...

    def propertyTypeCategory(self) -> PySide2.QtQml.QQmlProperty.PropertyTypeCategory:
        """
        **QQmlProperty::PropertyTypeCategory QQmlProperty::propertyTypeCategory() const**

        Returns the property category.
        """
        ...

    def propertyTypeName(self) -> bytes:
        """
        **const char *QQmlProperty::propertyTypeName() const**

        Returns the type name of the property, or 0 if the property has no type name.
        """
        ...

    @typing.overload
    @staticmethod
    def read(arg__1: PySide2.QtCore.QObject, arg__2: str) -> typing.Any:
        """
        **QVariant QQmlProperty::read() const**

        Returns the property value.
        """
        ...

    @typing.overload
    @staticmethod
    def read(
        arg__1: PySide2.QtCore.QObject, arg__2: str, arg__3: PySide2.QtQml.QQmlContext
    ) -> typing.Any:
        """
        **QVariant QQmlProperty::read() const**

        Returns the property value.
        """
        ...

    @typing.overload
    @staticmethod
    def read(
        arg__1: PySide2.QtCore.QObject, arg__2: str, arg__3: PySide2.QtQml.QQmlEngine
    ) -> typing.Any:
        """
        **QVariant QQmlProperty::read() const**

        Returns the property value.
        """
        ...

    @typing.overload
    def read(self) -> typing.Any:
        """
        **QVariant QQmlProperty::read() const**

        Returns the property value.
        """
        ...

    def reset(self) -> bool:
        """
        **bool QQmlProperty::reset() const**

        Resets the property and returns true if the property is resettable. If the property is not resettable, nothing happens and false is returned.
        """
        ...

    def type(self) -> PySide2.QtQml.QQmlProperty.Type:
        """
        **QQmlProperty::Type QQmlProperty::type() const**

        Returns the type of the property.
        """
        ...

    @typing.overload
    @staticmethod
    def write(arg__1: PySide2.QtCore.QObject, arg__2: str, arg__3: typing.Any) -> bool:
        """
        **bool QQmlProperty::write(const QVariant & value ) const**

        Sets the property value to **value**. Returns `true` on success, or `false` if the property can't be set because the **value** is the wrong type, for example.
        """
        ...

    @typing.overload
    @staticmethod
    def write(
        arg__1: PySide2.QtCore.QObject,
        arg__2: str,
        arg__3: typing.Any,
        arg__4: PySide2.QtQml.QQmlContext,
    ) -> bool:
        """
        **bool QQmlProperty::write(const QVariant & value ) const**

        Sets the property value to **value**. Returns `true` on success, or `false` if the property can't be set because the **value** is the wrong type, for example.
        """
        ...

    @typing.overload
    @staticmethod
    def write(
        arg__1: PySide2.QtCore.QObject,
        arg__2: str,
        arg__3: typing.Any,
        arg__4: PySide2.QtQml.QQmlEngine,
    ) -> bool:
        """
        **bool QQmlProperty::write(const QVariant & value ) const**

        Sets the property value to **value**. Returns `true` on success, or `false` if the property can't be set because the **value** is the wrong type, for example.
        """
        ...

    @typing.overload
    def write(self, arg__1: typing.Any) -> bool:
        """
        **bool QQmlProperty::write(const QVariant & value ) const**

        Sets the property value to **value**. Returns `true` on success, or `false` if the property can't be set because the **value** is the wrong type, for example.
        """
        ...
