"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtNetwork
import PySide2.QtQml

bytes = str


class QQmlIncubationController(object):
    """
    **Detailed Description**

    In order to behave asynchronously and not introduce stutters or freezes in an application, the process of creating objects a QQmlIncubators must be driven only during the application's idle time. QQmlIncubationController allows the application to control exactly when, how often and for how long this processing occurs.

    A QQmlIncubationController derived instance should be created and set on a **QQmlEngine**  by calling the **QQmlEngine::setIncubationController** () method. Processing is then controlled by calling the **QQmlIncubationController::incubateFor** () or QQmlIncubationController::incubateWhile() methods as dictated by the application's requirements.

    For example, this is an example of a incubation controller that will incubate for a maximum of 5 milliseconds out of every 16 milliseconds.

    class PeriodicIncubationController : public **QObject** ,
                                             public QQmlIncubationController
        {
        public:
            PeriodicIncubationController() {
                startTimer(16);
            }

        protected:
            void timerEvent(**QTimerEvent**  *) override {
                incubateFor(5);
            }
        };

    Although the previous example would work, it is not optimal. Real world incubation controllers should try and maximize the amount of idle time they consume - rather than a static amount like 5 milliseconds - while not disturbing the application.
    """

    def __init__(self) -> None:
        """
        **QQmlIncubationController::QQmlIncubationController()**

        Create a new incubation controller.
        """
        ...

    def engine(self) -> PySide2.QtQml.QQmlEngine:
        """
        **QQmlEngine *QQmlIncubationController::engine() const**

        Return the **QQmlEngine**  this incubation controller is set on, or 0 if it has not been set on any engine.
        """
        ...

    def incubateFor(self, msecs: int) -> None:
        """
        **void QQmlIncubationController::incubateFor(int msecs )**

        Incubate objects for **msecs** , or until there are no more objects to incubate.
        """
        ...

    def incubateWhile(self, msecs: int = ...) -> bool:
        """
        **void QQmlIncubationController::incubateWhile(std::atomic<bool> * flag , int msecs = 0)**

        Incubate objects while the atomic bool pointed to by **flag** is true, or until there are no more objects to incubate, or up to **msecs** if **msecs** is not zero.

        Generally this method is used in conjunction with a thread or a UNIX signal that sets the bool pointed to by **flag** to false when it wants incubation to be interrupted.

        **Note:** **flag** is read using acquire memory ordering.

        This function was introduced in Qt 5.15.
        """
        ...

    def incubatingObjectCount(self) -> int:
        """
        **int QQmlIncubationController::incubatingObjectCount() const**

        Return the number of objects currently incubating.
        """
        ...

    def incubatingObjectCountChanged(self, arg__1: int) -> None:
        """
        **[virtual protected] void QQmlIncubationController::incubatingObjectCountChanged(int incubatingObjectCount )**

        Called when the number of incubating objects changes. **incubatingObjectCount** is the new number of incubating objects.

        The default implementation does nothing.
        """
        ...
