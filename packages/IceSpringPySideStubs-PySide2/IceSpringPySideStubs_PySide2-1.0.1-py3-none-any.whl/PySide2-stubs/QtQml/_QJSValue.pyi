"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtNetwork
import PySide2.QtQml

bytes = str


class QJSValue(object):
    """
    **Detailed Description**

    QJSValue supports the types defined in the **ECMA-262**  standard: The primitive types, which are Undefined, Null, Boolean, Number, and String; and the Object and Array types. Additionally, built-in support is provided for Qt/C++ types such as **QVariant**  and **QObject** .

    For the object-based types (including Date and RegExp), use the newT() functions in **QJSEngine**  (e.g. **QJSEngine::newObject** ()) to create a QJSValue of the desired type. For the primitive types, use one of the QJSValue constructor overloads. For other types, e.g. registered gadget types such as **QPoint** , you can use **QJSEngine::toScriptValue** .

    The methods named isT() (e.g. **isBool** (), **isUndefined** ()) can be used to test if a value is of a certain type. The methods named toT() (e.g. **toBool** (), **toString** ()) can be used to convert a QJSValue to another type. You can also use the generic qjsvalue_cast() function.

    Object values have zero or more properties which are themselves QJSValues. Use **setProperty** () to set a property of an object, and call **property** () to retrieve the value of a property.

    **QJSEngine**  myEngine;
        **QJSValue**  myObject = myEngine.newObject();
        **QJSValue**  myOtherObject = myEngine.newObject();
        myObject.setProperty("myChild", myOtherObject);
        myObject.setProperty("name", "John Doe");

    If you want to iterate over the properties of a script object, use the **QJSValueIterator**  class.

    Object values have an internal `prototype` property, which can be accessed with **prototype** () and **setPrototype** ().

    Function objects (objects for which **isCallable** ()) returns true) can be invoked by calling **call** (). Constructor functions can be used to construct new objects by calling **callAsConstructor** ().

    Use **equals** () or **strictlyEquals** () to compare a QJSValue to another.

    Note that a QJSValue for which **isObject** () is true only carries a reference to an actual object; copying the QJSValue will only copy the object reference, not the object itself. If you want to clone an object (i.e. copy an object\'s properties to another object), you can do so with the help of a `for-in` statement in script code, or **QJSValueIterator**  in C++.

    **Working With Arrays**

    To create an array using QJSValue, use **QJSEngine::newArray** ():

    // Assumes that this class was declared in QML.
        **QJSValue**  jsArray = engine->newArray(3);

    To set individual elements in the array, use the **setProperty(quint32 arrayIndex, const QJSValue &value)**  overload. For example, to fill the array above with integers:

    for (int i = 0; i < 3; ++i) {
            jsArray.setProperty(i, **QRandomGenerator** ::global().generate());
        }

    To determine the length of the array, access the `"length"` property. To access array elements, use the **property** (quint32 arrayIndex) overload. The following code reads the array we created above back into a list:

    **QVector** <int> integers;
        const int length = jsArray.property("length").toInt();
        for (int i = 0; i < length; ++i) {
            integers.append(jsArray.property(i).toInt());
        }

    **See also** **QJSEngine**  and **QJSValueIterator** .
    """

    NoError: QJSValue = ...
    NullValue: QJSValue = ...
    GenericError: QJSValue = ...
    UndefinedValue: QJSValue = ...
    EvalError: QJSValue = ...
    RangeError: QJSValue = ...
    ReferenceError: QJSValue = ...
    SyntaxError: QJSValue = ...
    TypeError: QJSValue = ...
    URIError: QJSValue = ...

    class ErrorType(object):
        NoError: QJSValue.ErrorType = ...
        GenericError: QJSValue.ErrorType = ...
        EvalError: QJSValue.ErrorType = ...
        RangeError: QJSValue.ErrorType = ...
        ReferenceError: QJSValue.ErrorType = ...
        SyntaxError: QJSValue.ErrorType = ...
        TypeError: QJSValue.ErrorType = ...
        URIError: QJSValue.ErrorType = ...

    class SpecialValue(object):
        NullValue: QJSValue.SpecialValue = ...
        UndefinedValue: QJSValue.SpecialValue = ...

    @typing.overload
    def __init__(self, other: PySide2.QtQml.QJSValue) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, str: bytes) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: PySide2.QtQml.QJSValue.SpecialValue = ...) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: str) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: bool) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: float) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: int) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @typing.overload
    def __init__(self, value: int) -> None:
        """
        **QJSValue::QJSValue(QJSValue::SpecialValue value = UndefinedValue)**

        Constructs a new QJSValue with a special **value**.
        """
        ...

    @staticmethod
    def __copy__() -> None:
        ...

    def call(self, args: typing.Sequence = ...) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::call(const QJSValueList & args = QJSValueList())**

        Calls this **QJSValue**  as a function, passing **args** as arguments to the function, and using the globalObject() as the "this"-object. Returns the value returned from the function.

        If this **QJSValue**  is not callable, call() does nothing and returns an undefined **QJSValue** .

        Calling call() can cause an exception to occur in the script engine; in that case, call() returns the value that was thrown (typically an `Error` object). You can call **isError** () on the return value to determine whether an exception occurred.

        **See also** **isCallable** (), **callWithInstance** (), and **callAsConstructor** ().
        """
        ...

    def callAsConstructor(self, args: typing.Sequence = ...) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::callAsConstructor(const QJSValueList & args = QJSValueList())**

        Creates a new `Object` and calls this **QJSValue**  as a constructor, using the created object as the `this' object and passing **args** as arguments. If the return value from the constructor call is an object, then that object is returned; otherwise the default constructed object is returned.

        If this **QJSValue**  is not a function, callAsConstructor() does nothing and returns an undefined **QJSValue** .

        Calling this function can cause an exception to occur in the script engine; in that case, the value that was thrown (typically an `Error` object) is returned. You can call **isError** () on the return value to determine whether an exception occurred.

        **See also** **call** () and **QJSEngine::newObject** ().
        """
        ...

    def callWithInstance(
        self, instance: PySide2.QtQml.QJSValue, args: typing.Sequence = ...
    ) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::callWithInstance(const QJSValue & instance , const QJSValueList & args = QJSValueList())**

        Calls this **QJSValue**  as a function, using **instance** as the `this' object in the function call, and passing **args** as arguments to the function. Returns the value returned from the function.

        If this **QJSValue**  is not a function, **call** () does nothing and returns an undefined **QJSValue** .

        Note that if **instance** is not an object, the global object (see **QJSEngine::globalObject** ()) will be used as the `this' object.

        Calling **call** () can cause an exception to occur in the script engine; in that case, **call** () returns the value that was thrown (typically an `Error` object). You can call **isError** () on the return value to determine whether an exception occurred.

        **See also** **call** ().
        """
        ...

    def deleteProperty(self, name: str) -> bool:
        """
        **bool QJSValue::deleteProperty(const QString & name )**

        Attempts to delete this object\'s property of the given **name**. Returns true if the property was deleted, otherwise returns false.

        The behavior of this function is consistent with the JavaScript delete operator. In particular:

        * Non-configurable properties cannot be deleted.
          * This function will return true even if this object doesn\'t have a property of the given **name** (i.e., non-existent properties are "trivially deletable").
          * If this object doesn\'t have an own property of the given **name** , but an object in the **prototype** () chain does, the prototype object\'s property is not deleted, and this function returns true.

        **See also** **setProperty** () and **hasOwnProperty** ().
        """
        ...

    def engine(self) -> PySide2.QtQml.QJSEngine:
        ...

    def equals(self, other: PySide2.QtQml.QJSValue) -> bool:
        """
        **bool QJSValue::equals(const QJSValue & other ) const**

        Returns true if this **QJSValue**  is equal to **other** , otherwise returns false. The comparison follows the behavior described in **ECMA-262**  section 11.9.3, "The Abstract Equality Comparison Algorithm".

        This function can return true even if the type of this **QJSValue**  is different from the type of the **other** value; i.e. the comparison is not strict. For example, comparing the number 9 to the string "9" returns true; comparing an undefined value to a null value returns true; comparing a `Number` object whose primitive value is 6 to a `String` object whose primitive value is "6" returns true; and comparing the number 1 to the boolean value `true` returns true. If you want to perform a comparison without such implicit value conversion, use **strictlyEquals** ().

        Note that if this **QJSValue**  or the **other** value are objects, calling this function has side effects on the script engine, since the engine will call the object\'s valueOf() function (and possibly **toString** ()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **strictlyEquals** ().
        """
        ...

    def errorType(self) -> PySide2.QtQml.QJSValue.ErrorType:
        """
        **QJSValue::ErrorType QJSValue::errorType() const**

        Returns the error type this **QJSValue**  represents if it is an Error object. Otherwise, returns `NoError."`

        This function was introduced in Qt 5.12.

        **See also** **isError** () and **QJSEngine - Script Exceptions** .
        """
        ...

    def hasOwnProperty(self, name: str) -> bool:
        """
        **bool QJSValue::hasOwnProperty(const QString & name ) const**

        Returns true if this object has an own (not prototype-inherited) property of the given **name** , otherwise returns false.

        **See also** **property** () and **hasProperty** ().
        """
        ...

    def hasProperty(self, name: str) -> bool:
        """
        **bool QJSValue::hasProperty(const QString & name ) const**

        Returns true if this object has a property of the given **name** , otherwise returns false.

        **See also** **property** () and **hasOwnProperty** ().
        """
        ...

    def isArray(self) -> bool:
        """
        **bool QJSValue::isArray() const**

        Returns true if this **QJSValue**  is an object of the Array class; otherwise returns false.

        **See also** **QJSEngine::newArray** ().
        """
        ...

    def isBool(self) -> bool:
        """
        **bool QJSValue::isBool() const**

        Returns true if this **QJSValue**  is of the primitive type Boolean; otherwise returns false.

        **See also** **toBool** ().
        """
        ...

    def isCallable(self) -> bool:
        """
        **bool QJSValue::isCallable() const**

        Returns true if this **QJSValue**  is a function, otherwise returns false.

        **See also** **call** ().
        """
        ...

    def isDate(self) -> bool:
        """
        **bool QJSValue::isDate() const**

        Returns true if this **QJSValue**  is an object of the Date class; otherwise returns false.
        """
        ...

    def isError(self) -> bool:
        """
        **bool QJSValue::isError() const**

        Returns true if this **QJSValue**  is an object of the Error class; otherwise returns false.

        **See also** **errorType** () and **QJSEngine - Script Exceptions** .
        """
        ...

    def isNull(self) -> bool:
        """
        **bool QJSValue::isNull() const**

        Returns true if this **QJSValue**  is of the primitive type Null; otherwise returns false.
        """
        ...

    def isNumber(self) -> bool:
        """
        **bool QJSValue::isNumber() const**

        Returns true if this **QJSValue**  is of the primitive type Number; otherwise returns false.

        **See also** **toNumber** ().
        """
        ...

    def isObject(self) -> bool:
        """
        **bool QJSValue::isObject() const**

        Returns true if this **QJSValue**  is of the Object type; otherwise returns false.

        Note that function values, variant values, and **QObject**  values are objects, so this function returns true for such values.

        **See also** **QJSEngine::newObject** ().
        """
        ...

    def isQMetaObject(self) -> bool:
        """
        **bool QJSValue::isQMetaObject() const**

        Returns true if this **QJSValue**  is a **QMetaObject** ; otherwise returns false.

        This function was introduced in Qt 5.8.

        **See also** **toQMetaObject** () and **QJSEngine::newQMetaObject** ().
        """
        ...

    def isQObject(self) -> bool:
        """
        **bool QJSValue::isQObject() const**

        Returns true if this **QJSValue**  is a **QObject** ; otherwise returns false.

        Note: This function returns true even if the **QObject**  that this **QJSValue**  wraps has been deleted.

        **See also** **toQObject** () and **QJSEngine::newQObject** ().
        """
        ...

    def isRegExp(self) -> bool:
        """
        **bool QJSValue::isRegExp() const**

        Returns true if this **QJSValue**  is an object of the RegExp class; otherwise returns false.
        """
        ...

    def isString(self) -> bool:
        """
        **bool QJSValue::isString() const**

        Returns true if this **QJSValue**  is of the primitive type String; otherwise returns false.

        **See also** **toString** ().
        """
        ...

    def isUndefined(self) -> bool:
        """
        **bool QJSValue::isUndefined() const**

        Returns true if this **QJSValue**  is of the primitive type Undefined; otherwise returns false.
        """
        ...

    def isVariant(self) -> bool:
        """
        **bool QJSValue::isVariant() const**

        Returns true if this **QJSValue**  is a variant value; otherwise returns false.

        **See also** **toVariant** ().
        """
        ...

    @typing.overload
    def property(self, arrayIndex: int) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::property(const QString & name ) const**

        Returns the value of this **QJSValue** 's property with the given **name**. If no such property exists, an undefined **QJSValue**  is returned.

        If the property is implemented using a getter function (i.e. has the PropertyGetter flag set), calling property() has side-effects on the script engine, since the getter function will be called (possibly resulting in an uncaught script exception). If an exception occurred, property() returns the value that was thrown (typically an `Error` object).

        To access array elements, use the **setProperty(quint32 arrayIndex, const QJSValue &value)**  overload instead.

        **See also** **setProperty** (), **hasProperty** (), and **QJSValueIterator** .
        """
        ...

    @typing.overload
    def property(self, name: str) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::property(const QString & name ) const**

        Returns the value of this **QJSValue** 's property with the given **name**. If no such property exists, an undefined **QJSValue**  is returned.

        If the property is implemented using a getter function (i.e. has the PropertyGetter flag set), calling property() has side-effects on the script engine, since the getter function will be called (possibly resulting in an uncaught script exception). If an exception occurred, property() returns the value that was thrown (typically an `Error` object).

        To access array elements, use the **setProperty(quint32 arrayIndex, const QJSValue &value)**  overload instead.

        **See also** **setProperty** (), **hasProperty** (), and **QJSValueIterator** .
        """
        ...

    def prototype(self) -> PySide2.QtQml.QJSValue:
        """
        **QJSValue QJSValue::prototype() const**

        If this **QJSValue**  is an object, returns the internal prototype (`__proto__` property) of this object; otherwise returns an undefined **QJSValue** .

        **See also** **setPrototype** () and **isObject** ().
        """
        ...

    @typing.overload
    def setProperty(self, arrayIndex: int, value: PySide2.QtQml.QJSValue) -> None:
        """
        **void QJSValue::setProperty(const QString & name , const QJSValue & value )**

        Sets the value of this **QJSValue** 's property with the given **name** to the given **value**.

        If this **QJSValue**  is not an object, this function does nothing.

        If this **QJSValue**  does not already have a property with name **name** , a new property is created.

        To modify array elements, use the **setProperty(quint32 arrayIndex, const QJSValue &value)**  overload instead.

        **See also** **property** () and **deleteProperty** ().
        """
        ...

    @typing.overload
    def setProperty(self, name: str, value: PySide2.QtQml.QJSValue) -> None:
        """
        **void QJSValue::setProperty(const QString & name , const QJSValue & value )**

        Sets the value of this **QJSValue** 's property with the given **name** to the given **value**.

        If this **QJSValue**  is not an object, this function does nothing.

        If this **QJSValue**  does not already have a property with name **name** , a new property is created.

        To modify array elements, use the **setProperty(quint32 arrayIndex, const QJSValue &value)**  overload instead.

        **See also** **property** () and **deleteProperty** ().
        """
        ...

    def setPrototype(self, prototype: PySide2.QtQml.QJSValue) -> None:
        """
        **void QJSValue::setPrototype(const QJSValue & prototype )**

        If this **QJSValue**  is an object, sets the internal prototype (`__proto__` property) of this object to be **prototype** ; if the **QJSValue**  is null, it sets the prototype to null; otherwise does nothing.

        The internal prototype should not be confused with the public property with name "prototype"; the public prototype is usually only set on functions that act as constructors.

        **See also** **prototype** () and **isObject** ().
        """
        ...

    def strictlyEquals(self, other: PySide2.QtQml.QJSValue) -> bool:
        """
        **bool QJSValue::strictlyEquals(const QJSValue & other ) const**

        Returns true if this **QJSValue**  is equal to **other** using strict comparison (no conversion), otherwise returns false. The comparison follows the behavior described in **ECMA-262**  section 11.9.6, "The Strict Equality Comparison Algorithm".

        If the type of this **QJSValue**  is different from the type of the **other** value, this function returns false. If the types are equal, the result depends on the type, as shown in the following table:

        TypeResult
        Undefinedtrue
        Nulltrue
        Booleantrue if both values are true, false otherwise
        Numberfalse if either value is NaN (Not-a-Number); true if values are equal, false otherwise
        Stringtrue if both values are exactly the same sequence of characters, false otherwise
        Objecttrue if both values refer to the same object, false otherwise

        **See also** **equals** ().
        """
        ...

    def toBool(self) -> bool:
        """
        **bool QJSValue::toBool() const**

        Returns the boolean value of this **QJSValue** , using the conversion rules described in **ECMA-262**  section 9.2, "ToBoolean".

        Note that if this **QJSValue**  is an object, calling this function has side effects on the script engine, since the engine will call the object\'s valueOf() function (and possibly **toString** ()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **isBool** ().
        """
        ...

    def toDateTime(self) -> PySide2.QtCore.QDateTime:
        """
        **QDateTime QJSValue::toDateTime() const**

        Returns a **QDateTime**  representation of this value, in local time. If this **QJSValue**  is not a date, or the value of the date is NaN (Not-a-Number), an invalid **QDateTime**  is returned.

        **See also** **isDate** ().
        """
        ...

    def toInt(self) -> int:
        """
        **qint32 QJSValue::toInt() const**

        Returns the signed 32-bit integer value of this **QJSValue** , using the conversion rules described in **ECMA-262**  section 9.5, "ToInt32".

        Note that if this **QJSValue**  is an object, calling this function has side effects on the script engine, since the engine will call the object\'s valueOf() function (and possibly **toString** ()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **toNumber** () and **toUInt** ().
        """
        ...

    def toNumber(self) -> float:
        """
        **double QJSValue::toNumber() const**

        Returns the number value of this **QJSValue** , as defined in **ECMA-262**  section 9.3, "ToNumber".

        Note that if this **QJSValue**  is an object, calling this function has side effects on the script engine, since the engine will call the object\'s valueOf() function (and possibly **toString** ()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **isNumber** (), **toInt** (), and **toUInt** ().
        """
        ...

    def toQMetaObject(self) -> PySide2.QtCore.QMetaObject:
        """
        **const QMetaObject *QJSValue::toQMetaObject() const**

        * If this **QJSValue**  is a **QMetaObject** , returns the **QMetaObject**  pointer * that the **QJSValue**  represents; otherwise, returns `nullptr`. * *

        This function was introduced in Qt 5.8.

        **See also** **isQMetaObject** ().
        """
        ...

    def toQObject(self) -> PySide2.QtCore.QObject:
        """
        **QObject *QJSValue::toQObject() const**

        If this **QJSValue**  is a **QObject** , returns the **QObject**  pointer that the **QJSValue**  represents; otherwise, returns `nullptr`.

        If the **QObject**  that this **QJSValue**  wraps has been deleted, this function returns `nullptr` (i.e. it is possible for toQObject() to return `nullptr` even when **isQObject** () returns true).

        **See also** **isQObject** ().
        """
        ...

    def toString(self) -> str:
        """
        **QString QJSValue::toString() const**

        Returns the string value of this **QJSValue** , as defined in **ECMA-262**  section 9.8, "ToString".

        Note that if this **QJSValue**  is an object, calling this function has side effects on the script engine, since the engine will call the object\'s toString() function (and possibly valueOf()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **isString** ().
        """
        ...

    def toUInt(self) -> int:
        """
        **quint32 QJSValue::toUInt() const**

        Returns the unsigned 32-bit integer value of this **QJSValue** , using the conversion rules described in **ECMA-262**  section 9.6, "ToUint32".

        Note that if this **QJSValue**  is an object, calling this function has side effects on the script engine, since the engine will call the object\'s valueOf() function (and possibly **toString** ()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).

        **See also** **toNumber** () and **toInt** ().
        """
        ...

    def toVariant(self) -> typing.Any:
        """
        **QVariant QJSValue::toVariant() const**

        Returns the **QVariant**  value of this **QJSValue** , if it can be converted to a **QVariant** ; otherwise returns an invalid **QVariant** . The conversion is performed according to the following table:

        Input TypeResult
        UndefinedAn invalid **QVariant** .
        NullA **QVariant**  containing a null pointer (**QMetaType::Nullptr** ).
        BooleanA **QVariant**  containing the value of the boolean.
        NumberA **QVariant**  containing the value of the number.
        StringA **QVariant**  containing the value of the string.
        **QVariant**  ObjectThe result is the **QVariant**  value of the object (no conversion).
        **QObject**  ObjectA **QVariant**  containing a pointer to the **QObject** .
        Date ObjectA **QVariant**  containing the date value (**toDateTime** ()).
        RegExp ObjectA **QVariant**  containing the regular expression value.
        Array ObjectThe array is converted to a **QVariantList** . Each element is converted to a **QVariant** , recursively; cyclic references are not followed.
        ObjectThe object is converted to a **QVariantMap** . Each property is converted to a **QVariant** , recursively; cyclic references are not followed.

        **See also** **isVariant** ().
        """
        ...
