"""
PySide stub files generated by **IceSpringPySideStubs**

Home: https://baijifeilong.github.io/2022/01/06/ice-spring-pyside-stubs/index.html

Github: https://github.com/baijifeilong/IceSpringPySideStubs

PyPI(PySide2): https://pypi.org/project/IceSpringPySideStubs-PySide2

PyPI(PySide6): https://pypi.org/project/IceSpringPySideStubs-PySide6

Generated by BaiJiFeiLong@gmail.com

Licence: GPLv3
"""
import PySide2
import typing
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtWidgets
import PySide2.QtOpenGL

bytes = str


class QGLFramebufferObject(PySide2.QtGui.QPaintDevice):
    """
    https://doc.qt.io/qt-5/qglframebufferobject.html

    **Detailed Description**

    The QGLFramebufferObject class encapsulates an OpenGL framebuffer object,
    defined by the `GL_EXT_framebuffer_object` extension. In addition it
    provides a rendering surface that can be painted on with a **QPainter** ,
    rendered to using native GL calls, or both. This surface can be bound and
    used as a regular texture in your own GL drawing code. By default, the
    QGLFramebufferObject class generates a 2D GL texture (using the
    `GL_TEXTURE_2D` target), which is used as the internal rendering target.

    **It is important to have a current GL context when creating a
    QGLFramebufferObject, otherwise initialization will fail.**

    OpenGL framebuffer objects and pbuffers (see **QGLPixelBuffer** ) can both
    be used to render to offscreen surfaces, but there are a number of
    advantages with using framebuffer objects instead of pbuffers:

    1. A framebuffer object does not require a separate rendering context, so no
    context switching will occur when switching rendering targets. There is an
    overhead involved in switching targets, but in general it is cheaper than a
    context switch to a pbuffer.
      2. Rendering to dynamic textures (i.e.
    render-to-texture functionality) works on all platforms. No need to do
    explicit copy calls from a render buffer into a texture, as was necessary on
    systems that did not support the `render_texture` extension.
      3. It is
    possible to attach several rendering buffers (or texture objects) to the
    same framebuffer object, and render to all of them without doing a context
    switch.
      4. The OpenGL framebuffer extension is a pure GL extension with no
    system dependant WGL, CGL, or GLX parts. This makes using framebuffer
    objects more portable.

    When using a **QPainter**  to paint to a QGLFramebufferObject you should
    take care that the QGLFramebufferObject is created with the
    **CombinedDepthStencil**  attachment for **QPainter**  to be able to render
    correctly. Note that you need to create a QGLFramebufferObject with more
    than one sample per pixel for primitives to be antialiased when drawing
    using a **QPainter** . To create a multisample framebuffer object you should
    use one of the constructors that take a **QGLFramebufferObjectFormat**
    parameter, and set the **QGLFramebufferObjectFormat::samples** () property
    to a non-zero value.

    When painting to a QGLFramebufferObject using **QPainter** , the state of
    the current GL context will be altered by the paint engine to reflect its
    needs. Applications should not rely upon the GL state being reset to its
    original conditions, particularly the current shader program, GL viewport,
    texture units, and drawing modes.

    For multisample framebuffer objects a color render buffer is created,
    otherwise a texture with the specified texture target is created. The color
    render buffer or texture will have the specified internal format, and will
    be bound to the `GL_COLOR_ATTACHMENT0` attachment in the framebuffer object.

    If you want to use a framebuffer object with multisampling enabled as a
    texture, you first need to copy from it to a regular framebuffer object
    using QGLContext::blitFramebuffer().

    **Threading**

    As of Qt 4.8, it's possible to draw into a QGLFramebufferObject using a
    **QPainter**  in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is
    required for this to work.

    **Note:** This class has been deprecated in favor of
    **QOpenGLFramebufferObject** .
    """

    NoAttachment: QGLFramebufferObject = ...
    CombinedDepthStencil: QGLFramebufferObject = ...
    Depth: QGLFramebufferObject = ...

    class Attachment(object):
        NoAttachment: QGLFramebufferObject.Attachment = ...
        CombinedDepthStencil: QGLFramebufferObject.Attachment = ...
        Depth: QGLFramebufferObject.Attachment = ...

    @typing.overload
    def __init__(
        self,
        size: PySide2.QtCore.QSize,
        attachment: PySide2.QtOpenGL.QGLFramebufferObject.Attachment,
        target: int = ...,
        internal_format: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject

        **QGLFramebufferObject::QGLFramebufferObject(const QSize & size , GLenum
        target = GL_TEXTURE_2D)**

        Constructs an OpenGL framebuffer object and binds a 2D GL texture to the
        buffer of the size **size**. The texture is bound to the
        `GL_COLOR_ATTACHMENT0` target in the framebuffer object.

        The **target** parameter is used to specify the GL texture target. The
        default target is `GL_TEXTURE_2D`. Keep in mind that `GL_TEXTURE_2D`
        textures must have a power of 2 width and height (e.g. 256x512), unless
        you are using OpenGL 2.0 or higher.

        By default, no depth and stencil buffers are attached. This behavior can
        be toggled using one of the overloaded constructors.

        The default internal texture format is `GL_RGBA8` for desktop OpenGL,
        and `GL_RGBA` for OpenGL/ES.

        It is important that you have a current GL context set when creating the
        QGLFramebufferObject, otherwise the initialization will fail.

        **See also** **size** (), **texture** (), and **attachment** ().
        """
        ...

    @typing.overload
    def __init__(
        self,
        size: PySide2.QtCore.QSize,
        format: PySide2.QtOpenGL.QGLFramebufferObjectFormat,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject-1

        **QGLFramebufferObject::QGLFramebufferObject(int width , int height ,
        GLenum target = GL_TEXTURE_2D)**

        This is an overloaded function.

        Constructs an OpenGL framebuffer object and binds a 2D GL texture to the
        buffer of the given **width** and **height**.

        **See also** **size** () and **texture** ().
        """
        ...

    @typing.overload
    def __init__(self, size: PySide2.QtCore.QSize, target: int = ...) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject-2

        **QGLFramebufferObject::QGLFramebufferObject(const QSize & size ,
        QGLFramebufferObject::Attachment attachment , GLenum target =
        GL_TEXTURE_2D, GLenum internal_format = 0)**

        This is an overloaded function.

        Constructs an OpenGL framebuffer object and binds a texture to the
        buffer of the given **size**.

        The **attachment** parameter describes the depth/stencil buffer
        configuration, **target** the texture target and **internal_format** the
        internal texture format. The default texture target is `GL_TEXTURE_2D`,
        while the default internal format is `GL_RGBA8` for desktop OpenGL and
        `GL_RGBA` for OpenGL/ES.

        **See also** **size** (), **texture** (), and **attachment** ().
        """
        ...

    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        attachment: PySide2.QtOpenGL.QGLFramebufferObject.Attachment,
        target: int = ...,
        internal_format: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject-3

        **QGLFramebufferObject::QGLFramebufferObject(int width , int height ,
        QGLFramebufferObject::Attachment attachment , GLenum target =
        GL_TEXTURE_2D, GLenum internal_format = 0)**

        This is an overloaded function.

        Constructs an OpenGL framebuffer object and binds a texture to the
        buffer of the given **width** and **height**.

        The **attachment** parameter describes the depth/stencil buffer
        configuration, **target** the texture target and **internal_format** the
        internal texture format. The default texture target is `GL_TEXTURE_2D`,
        while the default internal format is `GL_RGBA8` for desktop OpenGL and
        `GL_RGBA` for OpenGL/ES.

        **See also** **size** (), **texture** (), and **attachment** ().
        """
        ...

    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        format: PySide2.QtOpenGL.QGLFramebufferObjectFormat,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject-4

        **QGLFramebufferObject::QGLFramebufferObject(const QSize & size , const
        QGLFramebufferObjectFormat & format )**

        This is an overloaded function.

        Constructs an OpenGL framebuffer object of the given **size** based on
        the supplied **format**.
        """
        ...

    @typing.overload
    def __init__(self, width: int, height: int, target: int = ...) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#QGLFramebufferObject-5

        **QGLFramebufferObject::QGLFramebufferObject(int width , int height ,
        const QGLFramebufferObjectFormat & format )**

        This is an overloaded function.

        Constructs an OpenGL framebuffer object of the given **width** and
        **height** based on the supplied **format**.
        """
        ...

    def attachment(self) -> PySide2.QtOpenGL.QGLFramebufferObject.Attachment:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#attachment

        **QGLFramebufferObject::Attachment QGLFramebufferObject::attachment()
        const**

        Returns the status of the depth and stencil buffers attached to this
        framebuffer object.
        """
        ...

    def bind(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#bind

        **bool QGLFramebufferObject::bind()**

        Switches rendering from the default, windowing system provided
        framebuffer to this framebuffer object. Returns `true` upon success,
        false otherwise.

        **See also** **release** ().
        """
        ...

    @staticmethod
    def bindDefault() -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#bindDefault

        **[static] bool QGLFramebufferObject::bindDefault()**

        Switches rendering back to the default, windowing system provided
        framebuffer. Returns `true` upon success, false otherwise.

        **See also** **bind** () and **release** ().
        """
        ...

    @staticmethod
    def blitFramebuffer(
        target: PySide2.QtOpenGL.QGLFramebufferObject,
        targetRect: PySide2.QtCore.QRect,
        source: PySide2.QtOpenGL.QGLFramebufferObject,
        sourceRect: PySide2.QtCore.QRect,
        buffers: int = ...,
        filter: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#blitFramebuffer

        **[static] void
        QGLFramebufferObject::blitFramebuffer(QGLFramebufferObject * target ,
        const QRect & targetRect , QGLFramebufferObject * source , const QRect &
        sourceRect , GLbitfield buffers = GL_COLOR_BUFFER_BIT, GLenum filter =
        GL_NEAREST)**

        Blits from the **sourceRect** rectangle in the **source** framebuffer
        object to the **targetRect** rectangle in the **target** framebuffer
        object.

        If **source** or **target** is `nullptr`, the default framebuffer will
        be used instead of a framebuffer object as source or target
        respectively.

        The **buffers** parameter should be a mask consisting of any combination
        of `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and
        `GL_STENCIL_BUFFER_BIT`. Any buffer type that is not present both in the
        source and target buffers is ignored.

        The **sourceRect** and **targetRect** rectangles may have different
        sizes; in this case **buffers** should not contain `GL_DEPTH_BUFFER_BIT`
        or `GL_STENCIL_BUFFER_BIT`. The **filter** parameter should be set to
        `GL_LINEAR` or `GL_NEAREST`, and specifies whether linear or nearest
        interpolation should be used when scaling is performed.

        If **source** equals **target** a copy is performed within the same
        buffer. Results are undefined if the source and target rectangles
        overlap and have different sizes. The sizes must also be the same if any
        of the framebuffer objects are multisample framebuffers.

        Note that the scissor test will restrict the blit area if enabled.

        This function will have no effect unless **hasOpenGLFramebufferBlit** ()
        returns true.

        This function was introduced in Qt 4.6.

        **See also** **hasOpenGLFramebufferBlit** ().
        """
        ...

    def devType(self) -> int:
        ...

    @typing.overload
    def drawTexture(
        self, point: PySide2.QtCore.QPointF, textureId: int, textureTarget: int = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#drawTexture

        **void QGLFramebufferObject::drawTexture(const QRectF & target , GLuint
        textureId , GLenum textureTarget = GL_TEXTURE_2D)**

        Draws the given texture, **textureId** , to the given target rectangle,
        **target** , in OpenGL model space. The **textureTarget** should be a 2D
        texture target.

        The framebuffer object should be bound when calling this function.

        Equivalent to the corresponding **QGLContext::drawTexture** ().

        This function was introduced in Qt 4.4.
        """
        ...

    @typing.overload
    def drawTexture(
        self, target: PySide2.QtCore.QRectF, textureId: int, textureTarget: int = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#drawTexture-1

        **void QGLFramebufferObject::drawTexture(const QPointF & point , GLuint
        textureId , GLenum textureTarget = GL_TEXTURE_2D)**

        Draws the given texture, **textureId** , at the given **point** in
        OpenGL model space. The **textureTarget** should be a 2D texture target.

        The framebuffer object should be bound when calling this function.

        Equivalent to the corresponding **QGLContext::drawTexture** ().

        This function was introduced in Qt 4.4.
        """
        ...

    def format(self) -> PySide2.QtOpenGL.QGLFramebufferObjectFormat:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#format

        **QGLFramebufferObjectFormat QGLFramebufferObject::format() const**

        Returns the format of this framebuffer object.
        """
        ...

    def handle(self) -> int:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#handle

        **GLuint QGLFramebufferObject::handle() const**

        Returns the GL framebuffer object handle for this framebuffer object
        (returned by the `glGenFrameBuffersEXT()` function). This handle can be
        used to attach new images or buffers to the framebuffer. The user is
        responsible for cleaning up and destroying these objects.
        """
        ...

    @staticmethod
    def hasOpenGLFramebufferBlit() -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#hasOpenGLFramebufferBli
        t

        **[static] bool QGLFramebufferObject::hasOpenGLFramebufferBlit()**

        Returns `true` if the OpenGL `GL_EXT_framebuffer_blit` extension is
        present on this system; otherwise returns `false`.

        This function was introduced in Qt 4.6.

        **See also** **blitFramebuffer** ().
        """
        ...

    @staticmethod
    def hasOpenGLFramebufferObjects() -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#hasOpenGLFramebufferObj
        ects

        **[static] bool QGLFramebufferObject::hasOpenGLFramebufferObjects()**

        Returns `true` if the OpenGL `GL_EXT_framebuffer_object` extension is
        present on this system; otherwise returns `false`.
        """
        ...

    def isBound(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#isBound

        **bool QGLFramebufferObject::isBound() const**

        Returns `true` if the framebuffer object is currently bound to a
        context, otherwise false is returned.

        This function was introduced in Qt 4.5.
        """
        ...

    def isValid(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#isValid

        **bool QGLFramebufferObject::isValid() const**

        Returns `true` if the framebuffer object is valid.

        The framebuffer can become invalid if the initialization process fails,
        the user attaches an invalid buffer to the framebuffer object, or a non-
        power of two width/height is specified as the texture size if the
        texture target is `GL_TEXTURE_2D`. The non-power of two limitation does
        not apply if the OpenGL version is 2.0 or higher, or if the
        GL_ARB_texture_non_power_of_two extension is present.

        The framebuffer can also become invalid if the QGLContext that the
        framebuffer was created within is destroyed and there are no other
        shared contexts that can take over ownership of the framebuffer.
        """
        ...

    def metric(self, metric: PySide2.QtGui.QPaintDevice.PaintDeviceMetric) -> int:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#metric

        **[override virtual protected] int
        QGLFramebufferObject::metric(QPaintDevice::PaintDeviceMetric metric )
        const**

        Reimplements: **QPaintDevice::metric** (QPaintDevice::PaintDeviceMetric
        metric) const.
        """
        ...

    def paintEngine(self) -> PySide2.QtGui.QPaintEngine:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#paintEngine

        **[override virtual] QPaintEngine *QGLFramebufferObject::paintEngine()
        const**

        Reimplements: **QPaintDevice::paintEngine** () const.
        """
        ...

    def release(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#release

        **bool QGLFramebufferObject::release()**

        Switches rendering back to the default, windowing system provided
        framebuffer. Returns `true` upon success, false otherwise.

        **See also** **bind** ().
        """
        ...

    def size(self) -> PySide2.QtCore.QSize:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#size

        **QSize QGLFramebufferObject::size() const**

        Returns the size of the texture attached to this framebuffer object.
        """
        ...

    def texture(self) -> int:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#texture

        **GLuint QGLFramebufferObject::texture() const**

        Returns the texture id for the texture attached as the default rendering
        target in this framebuffer object. This texture id can be bound as a
        normal texture in your own GL code.

        If a multisample framebuffer object is used then the value returned from
        this function will be invalid.
        """
        ...

    def toImage(self) -> PySide2.QtGui.QImage:
        """
        https://doc.qt.io/qt-5/qglframebufferobject.html#toImage

        **QImage QGLFramebufferObject::toImage() const**

        Returns the contents of this framebuffer object as a **QImage** .

        The returned image has a format of premultiplied ARGB32 or RGB32. The
        latter is used only when internalTextureFormat() is set to `GL_RGB`.

        If the rendering in the framebuffer was not done with premultiplied
        alpha in mind, create a wrapper **QImage**  with a non-premultiplied
        format. This is necessary before performing operations like
        **QImage::save** () because otherwise the image data would get
        unpremultiplied, even though it was not premultiplied in the first
        place. To create such a wrapper without performing a copy of the pixel
        data, do the following:

        **QImage**  fboImage(fbo.toImage());
            **QImage**
        image(fboImage.constBits(), fboImage.width(), fboImage.height(),
        **QImage** ::Format_ARGB32);

        On QNX the back buffer is not preserved when a buffer swap occures. So
        this function might return old content.
        """
        ...
