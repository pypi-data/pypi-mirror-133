"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore

bytes = str


class QAbstractEventDispatcher(PySide2.QtCore.QObject):
    """
    https://doc.qt.io/qt-5/qabstracteventdispatcher.html

    **Detailed Description**

    An event dispatcher receives events from the window system and other sources. It then sends them to the **QCoreApplication**  or **QApplication**  instance for processing and delivery. QAbstractEventDispatcher provides fine-grained control over event delivery.

    For simple control of event processing use **QCoreApplication::processEvents** ().

    For finer control of the application's event loop, call **instance** () and call functions on the QAbstractEventDispatcher object that is returned. If you want to use your own instance of QAbstractEventDispatcher or of a QAbstractEventDispatcher subclass, you must install it with **QCoreApplication::setEventDispatcher** () or **QThread::setEventDispatcher** () **before** a default event dispatcher has been installed.

    The main event loop is started by calling **QCoreApplication::exec** (), and stopped by calling **QCoreApplication::exit** (). Local event loops can be created using **QEventLoop** .

    Programs that perform long operations can call **processEvents** () with a bitwise OR combination of various **QEventLoop::ProcessEventsFlag**  values to control which events should be delivered.

    QAbstractEventDispatcher also allows the integration of an external event loop with the Qt event loop.

    **See also** **QEventLoop** , **QCoreApplication** , and **QThread** .
    """

    class TimerInfo(object):
        def __init__(self, id: int, i: int, t: PySide2.QtCore.Qt.TimerType) -> None:
            ...

    def __init__(self, parent: typing.Optional[PySide2.QtCore.QObject] = ...) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#QAbstractEventDispatcher

        **QAbstractEventDispatcher::QAbstractEventDispatcher(QObject * parent = nullptr)**

        Constructs a new event dispatcher with the given **parent**.
        """
        ...

    def closingDown(self) -> None:
        ...

    def filterNativeEvent(
        self, eventType: PySide2.QtCore.QByteArray, message: int
    ) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#filterNativeEvent

        **bool QAbstractEventDispatcher::filterNativeEvent(const QByteArray & eventType , void * message , long * result )**

        Sends **message** through the event filters that were set by **installNativeEventFilter** (). This function returns `true` as soon as an event filter returns `true`, and false otherwise to indicate that the processing of the event should continue.

        Subclasses of **QAbstractEventDispatcher**  **must** call this function for **all** messages received from the system to ensure compatibility with any extensions that may be used in the application. The type of event **eventType** is specific to the platform plugin chosen at run-time, and can be used to cast message to the right type. The **result** pointer is only used on Windows, and corresponds to the LRESULT pointer.

        Note that the type of **message** is platform dependent. See **QAbstractNativeEventFilter**  for details.

        This function was introduced in Qt 5.0.

        **See also** **installNativeEventFilter** () and **QAbstractNativeEventFilter::nativeEventFilter** ().
        """
        ...

    def flush(self) -> None:
        ...

    def hasPendingEvents(self) -> bool:
        ...

    def installNativeEventFilter(
        self, filterObj: PySide2.QtCore.QAbstractNativeEventFilter
    ) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#installNativeEventFilter

        **void QAbstractEventDispatcher::installNativeEventFilter(QAbstractNativeEventFilter * filterObj )**

        Installs an event filter **filterObj** for all native events received by the application.

        The event filter **filterObj** receives events via its **nativeEventFilter()**  function, which is called for all events received by all threads.

        The **nativeEventFilter()**  function should return true if the event should be filtered, (in this case, stopped). It should return false to allow normal Qt processing to continue: the native event can then be translated into a **QEvent**  and handled by the standard Qt **event**  filtering, e.g. **QObject::installEventFilter** ().

        If multiple event filters are installed, the filter that was installed last is activated first.

        **Note:** The filter function set here receives native messages, that is, MSG or XEvent structs.

        For maximum portability, you should always try to use **QEvent**  objects and **QObject::installEventFilter** () whenever possible.

        This function was introduced in Qt 5.0.

        **See also** **QObject::installEventFilter** ().
        """
        ...

    @staticmethod
    def instance(
        thread: typing.Optional[PySide2.QtCore.QThread] = ...,
    ) -> PySide2.QtCore.QAbstractEventDispatcher:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#instance

        **[static] QAbstractEventDispatcher *QAbstractEventDispatcher::instance(QThread * thread = nullptr)**

        Returns a pointer to the event dispatcher object for the specified **thread**. If **thread** is `nullptr`, the current thread is used. If no event dispatcher exists for the specified thread, this function returns `nullptr`.

        **Note:** If Qt is built without thread support, the **thread** argument is ignored.
        """
        ...

    def interrupt(self) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#interrupt

        **[pure virtual] void QAbstractEventDispatcher::interrupt()**

        Interrupts event dispatching. The event dispatcher will return from **processEvents** () as soon as possible.
        """
        ...

    def processEvents(
        self, flags: PySide2.QtCore.QEventLoop.ProcessEventsFlags
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#processEvents

        **[pure virtual] bool QAbstractEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags )**

        Processes pending events that match **flags** until there are no more events to process. Returns `true` if an event was processed; otherwise returns `false`.

        This function is especially useful if you have a long running operation, and want to show its progress without allowing user input by using the **QEventLoop::ExcludeUserInputEvents**  flag.

        If the **QEventLoop::WaitForMoreEvents**  flag is set in **flags** , the behavior of this function is as follows:

        * If events are available, this function returns after processing them.
          * If no events are available, this function will wait until more are available and return after processing newly available events.

        If the **QEventLoop::WaitForMoreEvents**  flag is not set in **flags** , and no events are available, this function will return immediately.

        **Note:** This function does not process events continuously; it returns after all available events are processed.

        **See also** **hasPendingEvents** ().
        """
        ...

    def registerEventNotifier(self, notifier: PySide2.QtCore.QWinEventNotifier) -> bool:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#registerEventNotifier

        **[pure virtual] bool QAbstractEventDispatcher::registerEventNotifier(QWinEventNotifier * notifier )**

        This pure virtual method exists on windows only and has to be reimplemented by a Windows specific event dispatcher implementation. **notifier** is the **QWinEventNotifier**  instance to be registered.

        The method should return true if the registration of **notifier** was successful, otherwise false.

        **QWinEventNotifier**  calls this method in it's constructor and there should never be a need to call this method directly.

        **See also** **QWinEventNotifier**  and **unregisterEventNotifier** ().
        """
        ...

    def registerSocketNotifier(self, notifier: PySide2.QtCore.QSocketNotifier) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#registerSocketNotifier

        **[pure virtual] void QAbstractEventDispatcher::registerSocketNotifier(QSocketNotifier * notifier )**

        Registers **notifier** with the event loop. Subclasses must implement this method to tie a socket notifier into another event loop.
        """
        ...

    @typing.overload
    def registerTimer(
        self,
        interval: int,
        timerType: PySide2.QtCore.Qt.TimerType,
        object: PySide2.QtCore.QObject,
    ) -> int:
        ...

    @typing.overload
    def registerTimer(
        self,
        timerId: int,
        interval: int,
        timerType: PySide2.QtCore.Qt.TimerType,
        object: PySide2.QtCore.QObject,
    ) -> None:
        ...

    def registeredTimers(self, object: PySide2.QtCore.QObject) -> typing.List:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#registeredTimers

        **[pure virtual] QList<QAbstractEventDispatcher::TimerInfo> QAbstractEventDispatcher::registeredTimers(QObject * object ) const**

        Returns a list of registered timers for **object**. The **TimerInfo**  struct has `timerId`, `interval`, and `timerType` members.

        **See also** **Qt::TimerType** .
        """
        ...

    def remainingTime(self, timerId: int) -> int:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#remainingTime

        **[pure virtual] int QAbstractEventDispatcher::remainingTime(int timerId )**

        Returns the remaining time in milliseconds with the given **timerId**. If the timer is inactive, the returned value will be -1. If the timer is overdue, the returned value will be 0.

        **See also** **Qt::TimerType** .
        """
        ...

    def removeNativeEventFilter(
        self, filterObj: PySide2.QtCore.QAbstractNativeEventFilter
    ) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#removeNativeEventFilter

        **void QAbstractEventDispatcher::removeNativeEventFilter(QAbstractNativeEventFilter * filter )**

        Removes the event filter **filter** from this object. The request is ignored if such an event filter has not been installed.

        All event filters for this object are automatically removed when this object is destroyed.

        It is always safe to remove an event filter, even during event filter filter activation (that is, even from within the **nativeEventFilter()**  function).

        This function was introduced in Qt 5.0.

        **See also** **installNativeEventFilter** () and **QAbstractNativeEventFilter** .
        """
        ...

    def startingUp(self) -> None:
        ...

    def unregisterEventNotifier(
        self, notifier: PySide2.QtCore.QWinEventNotifier
    ) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#unregisterEventNotifier

        **[pure virtual] void QAbstractEventDispatcher::unregisterEventNotifier(QWinEventNotifier * notifier )**

        This pure virtual method exists on windows only and has to be reimplemented by a Windows specific event dispatcher implementation. **notifier** is the **QWinEventNotifier**  instance to be unregistered.

        **QWinEventNotifier**  calls this method in it's destructor and there should never be a need to call this method directly.

        **See also** **QWinEventNotifier**  and **registerEventNotifier** ().
        """
        ...

    def unregisterSocketNotifier(
        self, notifier: PySide2.QtCore.QSocketNotifier
    ) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#unregisterSocketNotifier

        **[pure virtual] void QAbstractEventDispatcher::unregisterSocketNotifier(QSocketNotifier * notifier )**

        Unregisters **notifier** from the event dispatcher. Subclasses must reimplement this method to tie a socket notifier into another event loop. Reimplementations must call the base implementation.
        """
        ...

    def unregisterTimer(self, timerId: int) -> bool:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#unregisterTimer

        **[pure virtual] bool QAbstractEventDispatcher::unregisterTimer(int timerId )**

        Unregisters the timer with the given **timerId**. Returns `true` if successful; otherwise returns `false`.

        **See also** **registerTimer** () and **unregisterTimers** ().
        """
        ...

    def unregisterTimers(self, object: PySide2.QtCore.QObject) -> bool:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#unregisterTimers

        **[pure virtual] bool QAbstractEventDispatcher::unregisterTimers(QObject * object )**

        Unregisters all the timers associated with the given **object**. Returns `true` if all timers were successful removed; otherwise returns `false`.

        **See also** **unregisterTimer** () and **registeredTimers** ().
        """
        ...

    def wakeUp(self) -> None:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#wakeUp

        **[pure virtual] void QAbstractEventDispatcher::wakeUp()**

        Wakes up the event loop.

        **Note:** This function is **thread-safe** .

        **See also** **awake** ().
        """
        ...

    @property
    def aboutToBlock(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#aboutToBlock

        **[signal] void QAbstractEventDispatcher::aboutToBlock()**

        This signal is emitted before the event loop calls a function that could block.

        **See also** **awake** ().
        """
        ...

    @property
    def awake(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qabstracteventdispatcher.html#awake

        **[signal] void QAbstractEventDispatcher::awake()**

        This signal is emitted after the event loop returns from a function that could block.

        **See also** **wakeUp** () and **aboutToBlock** ().
        """
        ...
