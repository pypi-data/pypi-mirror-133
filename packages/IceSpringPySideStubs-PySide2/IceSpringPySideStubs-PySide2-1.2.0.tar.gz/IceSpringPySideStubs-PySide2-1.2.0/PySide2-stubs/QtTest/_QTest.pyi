"""
PySide stub files generated by **IceSpringPySideStubs**

Home: https://baijifeilong.github.io/2022/01/06/ice-spring-pyside-stubs/index.html

Github: https://github.com/baijifeilong/IceSpringPySideStubs

PyPI(PySide2): https://pypi.org/project/IceSpringPySideStubs-PySide2

PyPI(PySide6): https://pypi.org/project/IceSpringPySideStubs-PySide6

PyPI(PyQt5): https://pypi.org/project/IceSpringPySideStubs-PyQt5

Generated by BaiJiFeiLong@gmail.com

Licence: GPLv3
"""
"""
This file contains the exact signatures for all functions in module
PySide2.QtTest, except for defaults which are replaced by "...".
"""
import PySide2
import typing
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtWidgets
import PySide2.QtTest

bytes = str


class QTest(object):
    """
    https://doc.qt.io/qt-5/qtest.html

    **Detailed Description**

    See the **Qt Test Overview**  for information about how to write unit tests.
    """

    FramesPerSecond: QTest = ...
    MousePress: QTest = ...
    Press: QTest = ...
    Abort: QTest = ...
    BitsPerSecond: QTest = ...
    MouseRelease: QTest = ...
    Release: QTest = ...
    BytesPerSecond: QTest = ...
    Click: QTest = ...
    Continue: QTest = ...
    MouseClick: QTest = ...
    MouseDClick: QTest = ...
    Shortcut: QTest = ...
    WalltimeMilliseconds: QTest = ...
    CPUTicks: QTest = ...
    MouseMove: QTest = ...
    InstructionReads: QTest = ...
    Events: QTest = ...
    WalltimeNanoseconds: QTest = ...
    BytesAllocated: QTest = ...
    CPUMigrations: QTest = ...
    CPUCycles: QTest = ...
    BusCycles: QTest = ...
    StalledCycles: QTest = ...
    Instructions: QTest = ...
    BranchInstructions: QTest = ...
    BranchMisses: QTest = ...
    CacheReferences: QTest = ...
    CacheReads: QTest = ...
    CacheWrites: QTest = ...
    CachePrefetches: QTest = ...
    CacheMisses: QTest = ...
    CacheReadMisses: QTest = ...
    CacheWriteMisses: QTest = ...
    CachePrefetchMisses: QTest = ...
    ContextSwitches: QTest = ...
    PageFaults: QTest = ...
    MinorPageFaults: QTest = ...
    MajorPageFaults: QTest = ...
    AlignmentFaults: QTest = ...
    EmulationFaults: QTest = ...
    RefCPUCycles: QTest = ...

    class KeyAction(object):
        Press: QTest.KeyAction = ...
        Release: QTest.KeyAction = ...
        Click: QTest.KeyAction = ...
        Shortcut: QTest.KeyAction = ...

    class MouseAction(object):
        MousePress: QTest.MouseAction = ...
        MouseRelease: QTest.MouseAction = ...
        MouseClick: QTest.MouseAction = ...
        MouseDClick: QTest.MouseAction = ...
        MouseMove: QTest.MouseAction = ...

    class QBenchmarkMetric(object):
        FramesPerSecond: QTest.QBenchmarkMetric = ...
        BitsPerSecond: QTest.QBenchmarkMetric = ...
        BytesPerSecond: QTest.QBenchmarkMetric = ...
        WalltimeMilliseconds: QTest.QBenchmarkMetric = ...
        CPUTicks: QTest.QBenchmarkMetric = ...
        InstructionReads: QTest.QBenchmarkMetric = ...
        Events: QTest.QBenchmarkMetric = ...
        WalltimeNanoseconds: QTest.QBenchmarkMetric = ...
        BytesAllocated: QTest.QBenchmarkMetric = ...
        CPUMigrations: QTest.QBenchmarkMetric = ...
        CPUCycles: QTest.QBenchmarkMetric = ...
        BusCycles: QTest.QBenchmarkMetric = ...
        StalledCycles: QTest.QBenchmarkMetric = ...
        Instructions: QTest.QBenchmarkMetric = ...
        BranchInstructions: QTest.QBenchmarkMetric = ...
        BranchMisses: QTest.QBenchmarkMetric = ...
        CacheReferences: QTest.QBenchmarkMetric = ...
        CacheReads: QTest.QBenchmarkMetric = ...
        CacheWrites: QTest.QBenchmarkMetric = ...
        CachePrefetches: QTest.QBenchmarkMetric = ...
        CacheMisses: QTest.QBenchmarkMetric = ...
        CacheReadMisses: QTest.QBenchmarkMetric = ...
        CacheWriteMisses: QTest.QBenchmarkMetric = ...
        CachePrefetchMisses: QTest.QBenchmarkMetric = ...
        ContextSwitches: QTest.QBenchmarkMetric = ...
        PageFaults: QTest.QBenchmarkMetric = ...
        MinorPageFaults: QTest.QBenchmarkMetric = ...
        MajorPageFaults: QTest.QBenchmarkMetric = ...
        AlignmentFaults: QTest.QBenchmarkMetric = ...
        EmulationFaults: QTest.QBenchmarkMetric = ...
        RefCPUCycles: QTest.QBenchmarkMetric = ...

    class QTouchEventSequence(object):
        def commit(self, processEvents: bool = ...) -> None:
            ...

        @typing.overload
        def move(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def move(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def press(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def press(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def release(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def release(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        def stationary(self, touchId: int) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

    class TestFailMode(object):
        Abort: QTest.TestFailMode = ...
        Continue: QTest.TestFailMode = ...

    @staticmethod
    def addColumnInternal(id: int, name: bytes) -> None:
        ...

    @staticmethod
    def asciiToKey(ascii: int) -> PySide2.QtCore.Qt.Key:
        ...

    @staticmethod
    def compare_ptr_helper(
        t1: int, t2: int, actual: bytes, expected: bytes, file: bytes, line: int
    ) -> bool:
        ...

    @staticmethod
    def compare_string_helper(
        t1: bytes, t2: bytes, actual: bytes, expected: bytes, file: bytes, line: int
    ) -> bool:
        ...

    @staticmethod
    def createTouchDevice(
        devType: PySide2.QtGui.QTouchDevice.DeviceType = ...,
    ) -> PySide2.QtGui.QTouchDevice:
        """
        https://doc.qt.io/qt-5/qtest.html#createTouchDevice

        **QTouchDevice *QTest::createTouchDevice(QTouchDevice::DeviceType
        devType = QTouchDevice::TouchScreen)**

        Creates a dummy touch device of type **devType** for simulation of touch
        events.

        The touch device will be registered with the QPA window system
        interface, and deleted automatically when the **QCoreApplication**  is
        deleted. So you should typically use createTouchDevice() to initialize a
        **QTouchDevice**  member variable in your test case class, and use the
        same instance for all tests.

        This function was introduced in Qt 5.8.

        **See also** **QTest::QTouchEventSequence** .
        """
        ...

    @staticmethod
    def currentAppName() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentAppName

        **const char *QTest::currentAppName()**

        Returns the name of the binary that is currently executed.
        """
        ...

    @staticmethod
    def currentDataTag() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentDataTag

        **const char *QTest::currentDataTag()**

        Returns the name of the current test data. If the test doesn't have any
        assigned testdata, the function returns 0.
        """
        ...

    @staticmethod
    def currentTestFailed() -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#currentTestFailed

        **bool QTest::currentTestFailed()**

        Returns `true` if the current test function failed, otherwise false.
        """
        ...

    @staticmethod
    def currentTestFunction() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentTestFunction

        **const char *QTest::currentTestFunction()**

        Returns the name of the test function that is currently executed.

        Example:

        void MyTestClass::cleanup()
            {
                if
        (qstrcmp(QTest::currentTestFunction(), "myDatabaseTest") == 0) {
        // clean up all database connections
                    closeAllDatabases();
        }
            }
        """
        ...

    @typing.overload
    @staticmethod
    def ignoreMessage(type: PySide2.QtCore.QtMsgType, message: bytes) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#ignoreMessage

        **void QTest::ignoreMessage(QtMsgType type , const char * message )**

        Ignores messages created by **qDebug** (), **qInfo** () or **qWarning**
        (). If the **message** with the corresponding **type** is outputted, it
        will be removed from the test log. If the test finished and the
        **message** was not outputted, a test failure is appended to the test
        log.

        **Note:** Invoking this function will only ignore one message. If the
        message you want to ignore is outputted twice, you have to call
        ignoreMessage() twice, too.

        Example:

        **QDir**  dir;
            QTest::ignoreMessage(**QtWarningMsg** , "QDir::mkdir:
        Empty or null file name(s)");
            dir.mkdir("");

        The example above tests that **QDir::mkdir** () outputs the right
        warning when invoked with an invalid file name.
        """
        ...

    @typing.overload
    @staticmethod
    def ignoreMessage(
        type: PySide2.QtCore.QtMsgType,
        messagePattern: PySide2.QtCore.QRegularExpression,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#ignoreMessage-1

        **void QTest::ignoreMessage(QtMsgType type , const QRegularExpression &
        messagePattern )**

        This is an overloaded function.

        Ignores messages created by **qDebug** (), **qInfo** () or **qWarning**
        (). If the message matching **messagePattern** with the corresponding
        **type** is outputted, it will be removed from the test log. If the test
        finished and the message was not outputted, a test failure is appended
        to the test log.

        **Note:** Invoking this function will only ignore one message. If the
        message you want to ignore is outputted twice, you have to call
        ignoreMessage() twice, too.

        This function was introduced in Qt 5.3.
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick

        **void QTest::keyClick(QWidget * widget , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking of **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(myWidget, Qt::Key_Escape);
        QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on
        `myWidget` without any keyboard modifiers and without delay. The second
        example simulates clicking `shift-escape` on `myWidget` following a 200
        ms delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick-1

        **void QTest::keyClick(QWindow * window , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates clicking of **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(&myWindow, Qt::Key_Escape);
        QTest::keyClick(&myWindow, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on
        `myWindow` without any keyboard modifiers and without delay. The second
        example simulates clicking `shift-escape` on `myWindow` following a 200
        ms delay of the test.

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick-2

        **void QTest::keyClick(QWindow * window , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates clicking of **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before clicking the key.

        Example:

        **QWidget**  myWindow;
            QTest::keyClick(&myWindow, Qt::Key_Tab);

        The example above simulates clicking `a` on `myWindow` without any
        keyboard modifiers and without delay of the test.

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick-3

        **void QTest::keyClick(QWidget * widget , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates clicking of **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before clicking the key.

        Example:

        QTest::keyClick(myWidget, 'a');

        The example above simulates clicking `a` on `myWidget` without any
        keyboard modifiers and without delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @staticmethod
    def keyClicks(
        widget: PySide2.QtWidgets.QWidget,
        sequence: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClicks

        **void QTest::keyClicks(QWidget * widget , const QString & sequence ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking a **sequence** of keys on a **widget**. Optionally, a
        keyboard **modifier** can be specified as well as a **delay** (in
        milliseconds) of the test before each key click.

        Example:

        QTest::keyClicks(myWidget, "hello world");

        The example above simulates clicking the sequence of keys representing
        "hello world" on `myWidget` without any keyboard modifiers and without
        delay of the test.

        **See also** **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget ,
        Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay
        = -1)**

        Sends a Qt key event to **widget** with the given **key** and an
        associated **action**. Optionally, a keyboard **modifier** can be
        specified, as well as a **delay** (in milliseconds) of the test before
        sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent-1

        **void QTest::keyEvent(QTest::KeyAction action , QWindow * window , char
        ascii , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay =
        -1)**

        This is an overloaded function.

        Sends a Qt key event to **window** with the given key **ascii** and an
        associated **action**. Optionally, a keyboard **modifier** can be
        specified, as well as a **delay** (in milliseconds) of the test before
        sending the event.

        This function was introduced in Qt 5.0.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent-2

        **void QTest::keyEvent(QTest::KeyAction action , QWindow * window ,
        Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay
        = -1)**

        This is an overloaded function.

        Sends a Qt key event to **window** with the given **key** and an
        associated **action**. Optionally, a keyboard **modifier** can be
        specified, as well as a **delay** (in milliseconds) of the test before
        sending the event.

        This function was introduced in Qt 5.0.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent-3

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget , char
        ascii , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay =
        -1)**

        This is an overloaded function.

        Sends a Qt key event to **widget** with the given key **ascii** and an
        associated **action**. Optionally, a keyboard **modifier** can be
        specified, as well as a **delay** (in milliseconds) of the test before
        sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress

        **void QTest::keyPress(QWidget * widget , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates pressing a **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease**
        ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress-1

        **void QTest::keyPress(QWindow * window , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates pressing a **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease**
        ().

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress-2

        **void QTest::keyPress(QWindow * window , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates pressing a **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease**
        ().

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress-3

        **void QTest::keyPress(QWidget * widget , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates pressing a **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease**
        ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease

        **void QTest::keyRelease(QWidget * widget , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates releasing a **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before releasing the key.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease-1

        **void QTest::keyRelease(QWindow * window , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates releasing a **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before releasing the key.

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease-2

        **void QTest::keyRelease(QWindow * window , Qt::Key key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates releasing a **key** with an optional **modifier** on a
        **window**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before releasing the key.

        This function was introduced in Qt 5.0.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease-3

        **void QTest::keyRelease(QWidget * widget , char key ,
        Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        This is an overloaded function.

        Simulates releasing a **key** with an optional **modifier** on a
        **widget**. If **delay** is larger than 0, the test will wait for
        **delay** milliseconds before releasing the key.

        **See also** **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keySequence(
        widget: PySide2.QtWidgets.QWidget, keySequence: PySide2.QtGui.QKeySequence
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keySequence

        **void QTest::keySequence(QWindow * window , const QKeySequence &
        keySequence )**

        This is an overloaded function.

        Simulates typing of **keySequence** into a **window**.

        This function was introduced in Qt 5.10.

        **See also** **QTest::keyClick** () and **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keySequence(
        window: PySide2.QtGui.QWindow, keySequence: PySide2.QtGui.QKeySequence
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keySequence-1

        **void QTest::keySequence(QWidget * widget , const QKeySequence &
        keySequence )**

        This is an overloaded function.

        Simulates typing of **keySequence** into a **widget**.

        This function was introduced in Qt 5.10.

        **See also** **QTest::keyClick** () and **QTest::keyClicks** ().
        """
        ...

    @staticmethod
    def keyToAscii(key: PySide2.QtCore.Qt.Key) -> int:
        ...

    @typing.overload
    @staticmethod
    def mouseClick(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseClick

        **void QTest::mouseClick(QWidget * widget , Qt::MouseButton button ,
        Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay =
        -1)**

        Simulates clicking a mouse **button** with an optional **modifier** on a
        **widget**. The position of the click is defined by **pos** ; the
        default position is the center of the widget. If **delay** is specified,
        the test will wait for the specified amount of milliseconds before
        pressing and before releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseRelease** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseClick(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseClick-1

        **void QTest::mouseClick(QWindow * window , Qt::MouseButton button ,
        Qt::KeyboardModifiers stateKey = 0, QPoint pos = QPoint(), int delay =
        -1)**

        This is an overloaded function.

        Simulates clicking a mouse **button** with an optional **stateKey**
        modifier on a **window**. The position of the click is defined by
        **pos** ; the default position is the center of the window. If **delay**
        is specified, the test will wait for the specified amount of
        milliseconds before pressing and before releasing the button.

        This function was introduced in Qt 5.0.

        **See also** **QTest::mousePress** () and **QTest::mouseRelease** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseDClick(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseDClick

        **void QTest::mouseDClick(QWidget * widget , Qt::MouseButton button ,
        Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay =
        -1)**

        Simulates double clicking a mouse **button** with an optional
        **modifier** on a **widget**. The position of the click is defined by
        **pos** ; the default position is the center of the widget. If **delay**
        is specified, the test will wait for the specified amount of
        milliseconds before each press and release.

        **See also** **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseDClick(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseDClick-1

        **void QTest::mouseDClick(QWindow * window , Qt::MouseButton button ,
        Qt::KeyboardModifiers stateKey = 0, QPoint pos = QPoint(), int delay =
        -1)**

        This is an overloaded function.

        Simulates double clicking a mouse **button** with an optional
        **stateKey** modifier on a **window**. The position of the click is
        defined by **pos** ; the default position is the center of the window.
        If **delay** is specified, the test will wait for the specified amount
        of milliseconds before each press and release.

        This function was introduced in Qt 5.0.

        **See also** **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseEvent(
        action: PySide2.QtTest.QTest.MouseAction,
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers,
        pos: PySide2.QtCore.QPoint,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def mouseEvent(
        action: PySide2.QtTest.QTest.MouseAction,
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers,
        pos: PySide2.QtCore.QPoint,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def mouseMove(
        widget: PySide2.QtWidgets.QWidget,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseMove

        **void QTest::mouseMove(QWidget * widget , QPoint pos = QPoint(), int
        delay = -1)**

        Moves the mouse pointer to a **widget**. If **pos** is not specified,
        the mouse pointer moves to the center of the widget. If a **delay** (in
        milliseconds) is given, the test will wait before moving the mouse
        pointer.
        """
        ...

    @typing.overload
    @staticmethod
    def mouseMove(
        window: PySide2.QtGui.QWindow,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseMove-1

        **void QTest::mouseMove(QWindow * window , QPoint pos = QPoint(), int
        delay = -1)**

        This is an overloaded function.

        Moves the mouse pointer to a **window**. If **pos** is not specified,
        the mouse pointer moves to the center of the window. If a **delay** (in
        milliseconds) is given, the test will wait before moving the mouse
        pointer.

        This function was introduced in Qt 5.0.
        """
        ...

    @typing.overload
    @staticmethod
    def mousePress(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mousePress

        **void QTest::mousePress(QWidget * widget , Qt::MouseButton button ,
        Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay =
        -1)**

        Simulates pressing a mouse **button** with an optional **modifier** on a
        **widget**. The position is defined by **pos** ; the default position is
        the center of the widget. If **delay** is specified, the test will wait
        for the specified amount of milliseconds before the press.

        **See also** **QTest::mouseRelease** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mousePress(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mousePress-1

        **void QTest::mousePress(QWindow * window , Qt::MouseButton button ,
        Qt::KeyboardModifiers stateKey = 0, QPoint pos = QPoint(), int delay =
        -1)**

        This is an overloaded function.

        Simulates pressing a mouse **button** with an optional **stateKey**
        modifier on a **window**. The position is defined by **pos** ; the
        default position is the center of the window. If **delay** is specified,
        the test will wait for the specified amount of milliseconds before the
        press.

        This function was introduced in Qt 5.0.

        **See also** **QTest::mouseRelease** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseRelease(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseRelease

        **void QTest::mouseRelease(QWidget * widget , Qt::MouseButton button ,
        Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay =
        -1)**

        Simulates releasing a mouse **button** with an optional **modifier** on
        a **widget**. The position of the release is defined by **pos** ; the
        default position is the center of the widget. If **delay** is specified,
        the test will wait for the specified amount of milliseconds before
        releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseRelease(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseRelease-1

        **void QTest::mouseRelease(QWindow * window , Qt::MouseButton button ,
        Qt::KeyboardModifiers stateKey = 0, QPoint pos = QPoint(), int delay =
        -1)**

        This is an overloaded function.

        Simulates releasing a mouse **button** with an optional **stateKey**
        modifier on a **window**. The position of the release is defined by
        **pos** ; the default position is the center of the window. If **delay**
        is specified, the test will wait for the specified amount of
        milliseconds before releasing the button.

        This function was introduced in Qt 5.0.

        **See also** **QTest::mousePress** () and **QTest::mouseClick** ().
        """
        ...

    @staticmethod
    def qCleanup() -> None:
        ...

    @staticmethod
    def qElementData(elementName: bytes, metaTypeId: int) -> int:
        ...

    @staticmethod
    def qExpectFail(
        dataIndex: bytes,
        comment: bytes,
        mode: PySide2.QtTest.QTest.TestFailMode,
        file: bytes,
        line: int,
    ) -> bool:
        ...

    @typing.overload
    @staticmethod
    def qFindTestData(
        basepath: str,
        file: typing.Optional[bytes] = ...,
        line: int = ...,
        builddir: typing.Optional[bytes] = ...,
    ) -> str:
        ...

    @typing.overload
    @staticmethod
    def qFindTestData(
        basepath: bytes,
        file: typing.Optional[bytes] = ...,
        line: int = ...,
        builddir: typing.Optional[bytes] = ...,
    ) -> str:
        ...

    @staticmethod
    def qGlobalData(tagName: bytes, typeId: int) -> int:
        ...

    @staticmethod
    def qRun() -> int:
        ...

    @staticmethod
    def qSkip(message: bytes, file: bytes, line: int) -> None:
        ...

    @staticmethod
    def qWaitForWindowActive(
        widget: PySide2.QtWidgets.QWidget, timeout: int = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#qWaitForWindowActive

        **bool QTest::qWaitForWindowActive(QWindow * window , int timeout =
        5000)**

        Waits for **timeout** milliseconds or until the **window** is active.

        Returns `true` if `window` is active within **timeout** milliseconds,
        otherwise returns `false`.

        This function was introduced in Qt 5.0.

        **See also** **qWaitForWindowExposed** () and **QWindow::isActive** ().
        """
        ...

    @staticmethod
    def qWaitForWindowExposed(
        widget: PySide2.QtWidgets.QWidget, timeout: int = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#qWaitForWindowExposed

        **bool QTest::qWaitForWindowExposed(QWindow * window , int timeout =
        5000)**

        Waits for **timeout** milliseconds or until the **window** is exposed.
        Returns `true` if `window` is exposed within **timeout** milliseconds,
        otherwise returns `false`.

        This is mainly useful for asynchronous systems like X11, where a window
        will be mapped to screen some time after being asked to show itself on
        the screen.

        Note that a window that is mapped to screen may still not be considered
        exposed if the window client area is completely covered by other
        windows, or if the window is otherwise not visible. This function will
        then time out when waiting for such a window.

        This function was introduced in Qt 5.0.

        **See also** **qWaitForWindowActive** () and **QWindow::isExposed** ().
        """
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        code: PySide2.QtCore.Qt.Key,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        code: PySide2.QtCore.Qt.Key,
        text: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        code: PySide2.QtCore.Qt.Key,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        code: PySide2.QtCore.Qt.Key,
        text: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @staticmethod
    def setBenchmarkResult(
        result: float, metric: PySide2.QtTest.QTest.QBenchmarkMetric
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#setBenchmarkResult

        **void QTest::setBenchmarkResult(qreal result , QTest::QBenchmarkMetric
        metric )**

        Sets the benchmark result for this test function to **result**.

        Use this function if you want to report benchmark results without using
        the QBENCHMARK macro. Use **metric** to specify how Qt Test should
        interpret the results.

        The context for the result will be the test function name and any data
        tag from the _data function. This function can only be called once in
        each test function, subsequent calls will replace the earlier reported
        results.

        Note that the -iterations command line argument has no effect on test
        functions without the QBENCHMARK macro.

        This function was introduced in Qt 4.7.
        """
        ...

    @staticmethod
    def setMainSourcePath(file: bytes, builddir: typing.Optional[bytes] = ...) -> None:
        ...

    @typing.overload
    @staticmethod
    def simulateEvent(
        widget: PySide2.QtWidgets.QWidget,
        press: bool,
        code: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        text: str,
        repeat: bool,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def simulateEvent(
        window: PySide2.QtGui.QWindow,
        press: bool,
        code: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        text: str,
        repeat: bool,
        delay: int = ...,
    ) -> None:
        ...

    @staticmethod
    def testObject() -> PySide2.QtCore.QObject:
        ...

    @staticmethod
    def toPrettyCString(unicode: bytes, length: int) -> bytes:
        ...

    @typing.overload
    @staticmethod
    def touchEvent(
        widget: PySide2.QtWidgets.QWidget,
        device: PySide2.QtGui.QTouchDevice,
        autoCommit: bool = ...,
    ) -> PySide2.QtTest.QTest.QTouchEventSequence:
        """
        https://doc.qt.io/qt-5/qtest.html#touchEvent

        **QTest::QTouchEventSequence QTest::touchEvent(QWidget * widget ,
        QTouchDevice * device , bool autoCommit )**

        Creates and returns a **QTouchEventSequence**  for the **device** to
        simulate events for **widget**.

        When adding touch events to the sequence, **widget** will also be used
        to translate the position provided to screen coordinates, unless another
        widget is provided in the respective calls to press(), move() etc.

        The touch events are committed to the event system when the destructor
        of the **QTouchEventSequence**  is called (ie when the object returned
        runs out of scope), unless **autoCommit** is set to false. When
        **autoCommit** is false, commit() has to be called manually.
        """
        ...

    @typing.overload
    @staticmethod
    def touchEvent(
        window: PySide2.QtGui.QWindow,
        device: PySide2.QtGui.QTouchDevice,
        autoCommit: bool = ...,
    ) -> PySide2.QtTest.QTest.QTouchEventSequence:
        """
        https://doc.qt.io/qt-5/qtest.html#touchEvent-1

        **QTest::QTouchEventSequence QTest::touchEvent(QWindow * window ,
        QTouchDevice * device , bool autoCommit )**

        Creates and returns a **QTouchEventSequence**  for the **device** to
        simulate events for **window**.

        When adding touch events to the sequence, **window** will also be used
        to translate the position provided to screen coordinates, unless another
        window is provided in the respective calls to press(), move() etc.

        The touch events are committed to the event system when the destructor
        of the **QTouchEventSequence**  is called (ie when the object returned
        runs out of scope), unless **autoCommit** is set to false. When
        **autoCommit** is false, commit() has to be called manually.

        This function was introduced in Qt 5.0.
        """
        ...
