"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtNetwork
import PySide2.QtMultimediaWidgets
import PySide2.QtMultimedia

bytes = str


class QAudioOutput(PySide2.QtCore.QObject):
    """
    https://doc.qt.io/qt-5/qaudiooutput.html

    **Detailed Description**

    You can construct an audio output with the system\'s **default audio output device** . It is also possible to create QAudioOutput with a specific **QAudioDeviceInfo** . When you create the audio output, you should also send in the **QAudioFormat**  to be used for the playback (see the **QAudioFormat**  class description for details).

    To play a file:

    Starting to play an audio stream is simply a matter of calling **start** () with a **QIODevice** . QAudioOutput will then fetch the data it needs from the io device. So playing back an audio file is as simple as:

    **QFile**  sourceFile;   // class member.
        **QAudioOutput** * audio; // class member.
        {
            sourceFile.setFileName("/tmp/test.raw");
            sourceFile.open(**QIODevice** ::ReadOnly);

            **QAudioFormat**  format;
            // Set up the format, eg.
            format.setSampleRate(8000);
            format.setChannelCount(1);
            format.setSampleSize(8);
            format.setCodec("audio/pcm");
            format.setByteOrder(**QAudioFormat** ::LittleEndian);
            format.setSampleType(**QAudioFormat** ::UnSignedInt);

            **QAudioDeviceInfo**  info(**QAudioDeviceInfo** ::defaultOutputDevice());
            if (!info.isFormatSupported(format)) {
                **qWarning** () << "Raw audio format not supported by backend, cannot play audio.";
                return;
            }

            audio = new **QAudioOutput** (format, this);
            connect(audio, SIGNAL(stateChanged(QAudio::State)), this, SLOT(handleStateChanged(QAudio::State)));
            audio->start(&sourceFile);
        }

    The file will start playing assuming that the audio system and output device support it. If you run out of luck, check what\'s up with the **error** () function.

    After the file has finished playing, we need to stop the device:

    void AudioOutputExample::handleStateChanged(QAudio::State newState)
        {
            switch (newState) {
                case QAudio::IdleState:
                    // Finished playing (no more data)
                    audio->stop();
                    sourceFile.close();
                    delete audio;
                    break;

                case QAudio::StoppedState:
                    // Stopped for other reasons
                    if (audio->error() != QAudio::NoError) {
                        // Error handling
                    }
                    break;

                default:
                    // ... other cases as appropriate
                    break;
            }
        }

    At any given time, the QAudioOutput will be in one of four states: active, suspended, stopped, or idle. These states are described by the **QAudio::State**  enum. State changes are reported through the **stateChanged** () signal. You can use this signal to, for instance, update the GUI of the application; the mundane example here being changing the state of a `play/pause` button. You request a state change directly with **suspend** (), **stop** (), **reset** (), **resume** (), and **start** ().

    While the stream is playing, you can set a notify interval in milliseconds with **setNotifyInterval** (). This interval specifies the time between two emissions of the **notify** () signal. This is relative to the position in the stream, i.e., if the QAudioOutput is in the SuspendedState or the IdleState, the **notify** () signal is not emitted. A typical use-case would be to update a **slider**  that allows seeking in the stream. If you want the time since playback started regardless of which states the audio output has been in, **elapsedUSecs** () is the function for you.

    If an error occurs, you can fetch the **error type**  with the **error** () function. Please see the **QAudio::Error**  enum for a description of the possible errors that are reported. When an error is encountered, the state changes to **QAudio::StoppedState** . You can check for errors by connecting to the **stateChanged** () signal:

    void AudioOutputExample::handleStateChanged(QAudio::State newState)
        {
            switch (newState) {
                case QAudio::IdleState:
                    // Finished playing (no more data)
                    audio->stop();
                    sourceFile.close();
                    delete audio;
                    break;

                case QAudio::StoppedState:
                    // Stopped for other reasons
                    if (audio->error() != QAudio::NoError) {
                        // Error handling
                    }
                    break;

                default:
                    // ... other cases as appropriate
                    break;
            }
        }

    **See also** **QAudioInput**  and **QAudioDeviceInfo** .
    """

    @typing.overload
    def __init__(
        self,
        audioDeviceInfo: PySide2.QtMultimedia.QAudioDeviceInfo,
        format: PySide2.QtMultimedia.QAudioFormat = ...,
        parent: typing.Optional[PySide2.QtCore.QObject] = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#QAudioOutput

        **QAudioOutput::QAudioOutput(const QAudioFormat & format = QAudioFormat(), QObject * parent = nullptr)**

        Construct a new audio output and attach it to **parent**. The default audio output device is used with the output **format** parameters.
        """
        ...

    @typing.overload
    def __init__(
        self,
        format: PySide2.QtMultimedia.QAudioFormat = ...,
        parent: typing.Optional[PySide2.QtCore.QObject] = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#QAudioOutput

        **QAudioOutput::QAudioOutput(const QAudioFormat & format = QAudioFormat(), QObject * parent = nullptr)**

        Construct a new audio output and attach it to **parent**. The default audio output device is used with the output **format** parameters.
        """
        ...

    def bufferSize(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#bufferSize

        **int QAudioOutput::bufferSize() const**

        Returns the audio buffer size in bytes.

        If called before **start** (), returns platform default value. If called before **start** () but **setBufferSize** () was called prior, returns value set by **setBufferSize** (). If called after **start** (), returns the actual buffer size being used. This may not be what was set previously by **setBufferSize** ().

        **See also** **setBufferSize** ().
        """
        ...

    def bytesFree(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#bytesFree

        **int QAudioOutput::bytesFree() const**

        Returns the number of free bytes available in the audio buffer.

        **Note:** The returned value is only valid while in **QAudio::ActiveState**  or **QAudio::IdleState**  state, otherwise returns zero.
        """
        ...

    def category(self) -> str:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#category

        **QString QAudioOutput::category() const**

        Returns the audio category of this audio stream.

        Some platforms can group audio streams into categories and manage their volumes independently, or display them in a system mixer control. You can set this property to allow the platform to distinguish the purpose of your streams.

        **See also** **setCategory** ().
        """
        ...

    def elapsedUSecs(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#elapsedUSecs

        **qint64 QAudioOutput::elapsedUSecs() const**

        Returns the microseconds since **start** () was called, including time in Idle and Suspend states.
        """
        ...

    def error(self) -> PySide2.QtMultimedia.QAudio.Error:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#error

        **QAudio::Error QAudioOutput::error() const**

        Returns the error state.
        """
        ...

    def format(self) -> PySide2.QtMultimedia.QAudioFormat:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#format

        **QAudioFormat QAudioOutput::format() const**

        Returns the **QAudioFormat**  being used.
        """
        ...

    def notifyInterval(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#notifyInterval

        **int QAudioOutput::notifyInterval() const**

        Returns the notify interval in milliseconds.

        **See also** **setNotifyInterval** ().
        """
        ...

    def periodSize(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#periodSize

        **int QAudioOutput::periodSize() const**

        Returns the period size in bytes. This is the amount of data required each period to prevent buffer underrun, and to ensure uninterrupted playback.

        **Note:** It is recommended to provide at least enough data for a full period with each write operation.
        """
        ...

    def processedUSecs(self) -> int:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#processedUSecs

        **qint64 QAudioOutput::processedUSecs() const**

        Returns the amount of audio data processed since **start** () was called (in microseconds).
        """
        ...

    def reset(self) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#reset

        **void QAudioOutput::reset()**

        Drops all audio data in the buffers, resets buffers to zero.
        """
        ...

    def resume(self) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#resume

        **void QAudioOutput::resume()**

        Resumes processing audio data after a **suspend** ().

        Sets **error** () to **QAudio::NoError** . Sets **state** () to **QAudio::ActiveState**  if you previously called start(**QIODevice** *). Sets **state** () to **QAudio::IdleState**  if you previously called **start** (). emits **stateChanged** () signal.
        """
        ...

    def setBufferSize(self, bytes: int) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#setBufferSize

        **void QAudioOutput::setBufferSize(int value )**

        Sets the audio buffer size to **value** in bytes.

        **Note:** This function can be called anytime before **start** (). Calls to this are ignored after **start** (). It should not be assumed that the buffer size set is the actual buffer size used - call **bufferSize** () anytime after **start** () to return the actual buffer size being used.

        **See also** **bufferSize** ().
        """
        ...

    def setCategory(self, category: str) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#setCategory

        **void QAudioOutput::setCategory(const QString & category )**

        Sets the audio category of this audio stream to **category**.

        Some platforms can group audio streams into categories and manage their volumes independently, or display them in a system mixer control. You can set this property to allow the platform to distinguish the purpose of your streams.

        Not all platforms support audio stream categorization. In this case, the function call will be ignored.

        Changing an audio output stream's category while it is opened will not take effect until it is reopened.

        **See also** **category** ().
        """
        ...

    def setNotifyInterval(self, milliSeconds: int) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#setNotifyInterval

        **void QAudioOutput::setNotifyInterval(int ms )**

        Sets the interval for **notify** () signal to be emitted. This is based on the **ms** of audio data processed, not on wall clock time. The minimum resolution of the timer is platform specific and values should be checked with **notifyInterval** () to confirm the actual value being used.

        **See also** **notifyInterval** ().
        """
        ...

    def setVolume(self, arg__1: float) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#setVolume

        **void QAudioOutput::setVolume(qreal volume )**

        Sets the output volume to **volume**.

        The volume is scaled linearly from `0.0` (silence) to `1.0` (full volume). Values outside this range will be clamped.

        The default volume is `1.0`.

        Note: Adjustments to the volume will change the volume of this audio stream, not the global volume.

        UI volume controls should usually be scaled nonlinearly. For example, using a logarithmic scale will produce linear changes in perceived loudness, which is what a user would normally expect from a volume control. See **QAudio::convertVolume** () for more details.

        **See also** **volume** ().
        """
        ...

    @typing.overload
    def start(self) -> PySide2.QtCore.QIODevice:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#start

        **void QAudioOutput::start(QIODevice * device )**

        Starts transferring audio data from the **device** to the system's audio output. The **device** must have been opened in the **ReadOnly**  or **ReadWrite**  modes.

        If the **QAudioOutput**  is able to successfully output audio data, **state** () returns **QAudio::ActiveState** , **error** () returns **QAudio::NoError**  and the **stateChanged** () signal is emitted.

        If a problem occurs during this process, **error** () returns **QAudio::OpenError** , **state** () returns **QAudio::StoppedState**  and the **stateChanged** () signal is emitted.

        **See also** **QIODevice** .
        """
        ...

    @typing.overload
    def start(self, device: PySide2.QtCore.QIODevice) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#start

        **void QAudioOutput::start(QIODevice * device )**

        Starts transferring audio data from the **device** to the system's audio output. The **device** must have been opened in the **ReadOnly**  or **ReadWrite**  modes.

        If the **QAudioOutput**  is able to successfully output audio data, **state** () returns **QAudio::ActiveState** , **error** () returns **QAudio::NoError**  and the **stateChanged** () signal is emitted.

        If a problem occurs during this process, **error** () returns **QAudio::OpenError** , **state** () returns **QAudio::StoppedState**  and the **stateChanged** () signal is emitted.

        **See also** **QIODevice** .
        """
        ...

    def state(self) -> PySide2.QtMultimedia.QAudio.State:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#state

        **QAudio::State QAudioOutput::state() const**

        Returns the state of audio processing.
        """
        ...

    def stop(self) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#stop

        **void QAudioOutput::stop()**

        Stops the audio output, detaching from the system resource.

        Sets **error** () to **QAudio::NoError** , **state** () to **QAudio::StoppedState**  and emit **stateChanged** () signal.
        """
        ...

    def suspend(self) -> None:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#suspend

        **void QAudioOutput::suspend()**

        Stops processing audio data, preserving buffered audio data.

        Sets **error** () to **QAudio::NoError** , **state** () to **QAudio::SuspendedState**  and emits **stateChanged** () signal.
        """
        ...

    def volume(self) -> float:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#volume

        **qreal QAudioOutput::volume() const**

        Returns the volume between 0.0 and 1.0 inclusive.

        **See also** **setVolume** ().
        """
        ...

    @property
    def notify(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#notify

        **[signal] void QAudioOutput::notify()**

        This signal is emitted when a certain interval of milliseconds of audio data has been processed. The interval is set by **setNotifyInterval** ().
        """
        ...

    @property
    def stateChanged(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qaudiooutput.html#stateChanged

        **[signal] void QAudioOutput::stateChanged(QAudio::State state )**

        This signal is emitted when the device **state** has changed. This is the current state of the audio output.
        """
        ...
