"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtWidgets
import PySide2.QtOpenGL

bytes = str


class QGLPixelBuffer(PySide2.QtGui.QPaintDevice):
    """
    https://doc.qt.io/qt-5/qglpixelbuffer.html

    **Detailed Description**

    Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a **QPixmap** .

    There are three approaches to using this class:

    1.  **We can draw into the pbuffer and convert it to a**QImage**  using **toImage** ().** This is normally much faster than calling **QGLWidget::renderPixmap** ().
      2. **We can draw into the pbuffer and copy the contents into an OpenGL texture using**updateDynamicTexture** ().** This allows us to create dynamic textures and works on all systems with pbuffer support.
      3. **On systems that support it, we can bind the pbuffer to an OpenGL texture.** The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and macOS systems that provide the `render_texture` extension. Note that under Windows, a multi-sampled pbuffer can't be used in conjunction with the `render_texture` extension. If a multi-sampled pbuffer is requested under Windows, the `render_texture` extension is turned off for that pbuffer.

    **Note:** This class has been deprecated, use **QOpenGLFramebufferObject**  for offscreen rendering.

    **Threading**

    As of Qt 4.8, it's possible to render into a QGLPixelBuffer using a **QPainter**  in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.

    Pbuffers are provided by the OpenGL `pbuffer` extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.
    """

    @typing.overload
    def __init__(
        self,
        size: PySide2.QtCore.QSize,
        format: PySide2.QtOpenGL.QGLFormat = ...,
        shareWidget: typing.Optional[PySide2.QtOpenGL.QGLWidget] = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#QGLPixelBuffer

        **QGLPixelBuffer::QGLPixelBuffer(const QSize & size , const QGLFormat & format = QGLFormat::defaultFormat(), QGLWidget * shareWidget = nullptr)**

        Constructs an OpenGL pbuffer of the given **size**. If no **format** is specified, the **default format**  is used. If the **shareWidget** parameter points to a valid QGLWidget, the pbuffer will share its context with **shareWidget**.

        If you intend to bind this pbuffer as a dynamic texture, the width and height components of `size` must be powers of two (e.g., 512 x 128).

        **See also** **size** () and **format** ().
        """
        ...

    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        format: PySide2.QtOpenGL.QGLFormat = ...,
        shareWidget: typing.Optional[PySide2.QtOpenGL.QGLWidget] = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#QGLPixelBuffer

        **QGLPixelBuffer::QGLPixelBuffer(const QSize & size , const QGLFormat & format = QGLFormat::defaultFormat(), QGLWidget * shareWidget = nullptr)**

        Constructs an OpenGL pbuffer of the given **size**. If no **format** is specified, the **default format**  is used. If the **shareWidget** parameter points to a valid QGLWidget, the pbuffer will share its context with **shareWidget**.

        If you intend to bind this pbuffer as a dynamic texture, the width and height components of `size` must be powers of two (e.g., 512 x 128).

        **See also** **size** () and **format** ().
        """
        ...

    @typing.overload
    def bindTexture(self, fileName: str) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#bindTexture

        **GLuint QGLPixelBuffer::bindTexture(const QImage & image , GLenum target = GL_TEXTURE_2D)**

        Generates and binds a 2D GL texture to the current context, based on **image**. The generated texture id is returned and can be used in later glBindTexture() calls.

        The **target** parameter specifies the texture target.

        Equivalent to calling **QGLContext::bindTexture** ().

        **See also** **deleteTexture** ().
        """
        ...

    @typing.overload
    def bindTexture(self, image: PySide2.QtGui.QImage, target: int = ...) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#bindTexture

        **GLuint QGLPixelBuffer::bindTexture(const QImage & image , GLenum target = GL_TEXTURE_2D)**

        Generates and binds a 2D GL texture to the current context, based on **image**. The generated texture id is returned and can be used in later glBindTexture() calls.

        The **target** parameter specifies the texture target.

        Equivalent to calling **QGLContext::bindTexture** ().

        **See also** **deleteTexture** ().
        """
        ...

    @typing.overload
    def bindTexture(self, pixmap: PySide2.QtGui.QPixmap, target: int = ...) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#bindTexture

        **GLuint QGLPixelBuffer::bindTexture(const QImage & image , GLenum target = GL_TEXTURE_2D)**

        Generates and binds a 2D GL texture to the current context, based on **image**. The generated texture id is returned and can be used in later glBindTexture() calls.

        The **target** parameter specifies the texture target.

        Equivalent to calling **QGLContext::bindTexture** ().

        **See also** **deleteTexture** ().
        """
        ...

    def bindToDynamicTexture(self, texture: int) -> bool:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#bindToDynamicTexture

        **bool QGLPixelBuffer::bindToDynamicTexture(GLuint texture_id )**

        Binds the texture specified by **texture_id** to this pbuffer. Returns `true` on success; otherwise returns `false`.

        The texture must be of the same size and format as the pbuffer.

        To unbind the texture, call **releaseFromDynamicTexture** (). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.

        Example:

        **QGLPixelBuffer**  pbuffer(...);
            ...
            pbuffer.makeCurrent();
            GLuint dynamicTexture = pbuffer.generateDynamicTexture();
            pbuffer.bindToDynamicTexture(dynamicTexture);
            ...
            pbuffer.releaseFromDynamicTexture();

        **Warning:** This function uses the `render_texture` extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using **updateDynamicTexture** ().

        **Warning:** For the bindToDynamicTexture() call to succeed on the macOS, the pbuffer needs a shared context, i.e. the **QGLPixelBuffer**  must be created with a share widget.

        **See also** **generateDynamicTexture** () and **releaseFromDynamicTexture** ().
        """
        ...

    def context(self) -> PySide2.QtOpenGL.QGLContext:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#context

        **QGLContext *QGLPixelBuffer::context() const**

        Returns the context of this pixelbuffer.
        """
        ...

    def deleteTexture(self, texture_id: int) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#deleteTexture

        **void QGLPixelBuffer::deleteTexture(GLuint texture_id )**

        Removes the texture identified by **texture_id** from the texture cache.

        Equivalent to calling **QGLContext::deleteTexture** ().
        """
        ...

    def devType(self) -> int:
        ...

    def doneCurrent(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#doneCurrent

        **bool QGLPixelBuffer::doneCurrent()**

        Makes no context the current OpenGL context. Returns `true` on success; otherwise returns `false`.
        """
        ...

    @typing.overload
    def drawTexture(
        self, point: PySide2.QtCore.QPointF, textureId: int, textureTarget: int = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#drawTexture

        **void QGLPixelBuffer::drawTexture(const QRectF & target , GLuint textureId , GLenum textureTarget = GL_TEXTURE_2D)**

        Draws the given texture, **textureId** , to the given target rectangle, **target** , in OpenGL model space. The **textureTarget** should be a 2D texture target.

        Equivalent to the corresponding **QGLContext::drawTexture** ().

        This function was introduced in Qt 4.4.
        """
        ...

    @typing.overload
    def drawTexture(
        self, target: PySide2.QtCore.QRectF, textureId: int, textureTarget: int = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#drawTexture

        **void QGLPixelBuffer::drawTexture(const QRectF & target , GLuint textureId , GLenum textureTarget = GL_TEXTURE_2D)**

        Draws the given texture, **textureId** , to the given target rectangle, **target** , in OpenGL model space. The **textureTarget** should be a 2D texture target.

        Equivalent to the corresponding **QGLContext::drawTexture** ().

        This function was introduced in Qt 4.4.
        """
        ...

    def format(self) -> PySide2.QtOpenGL.QGLFormat:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#format

        **QGLFormat QGLPixelBuffer::format() const**

        Returns the format of the pbuffer. The format may be different from the one that was requested.
        """
        ...

    def generateDynamicTexture(self) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#generateDynamicTexture

        **GLuint QGLPixelBuffer::generateDynamicTexture() const**

        Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with **bindToDynamicTexture** () and **updateDynamicTexture** ().

        **See also** **size** ().
        """
        ...

    def handle(self) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#handle

        **Qt::HANDLE QGLPixelBuffer::handle() const**

        Returns the native pbuffer handle.
        """
        ...

    @staticmethod
    def hasOpenGLPbuffers() -> bool:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#hasOpenGLPbuffers

        **[static] bool QGLPixelBuffer::hasOpenGLPbuffers()**

        Returns `true` if the OpenGL `pbuffer` extension is present on this system; otherwise returns `false`.
        """
        ...

    def isValid(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#isValid

        **bool QGLPixelBuffer::isValid() const**

        Returns `true` if this pbuffer is valid; otherwise returns `false`.
        """
        ...

    def makeCurrent(self) -> bool:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#makeCurrent

        **bool QGLPixelBuffer::makeCurrent()**

        Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns `false`.

        **See also** **QGLContext::makeCurrent** () and **doneCurrent** ().
        """
        ...

    def metric(self, metric: PySide2.QtGui.QPaintDevice.PaintDeviceMetric) -> int:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#metric

        **[override virtual protected] int QGLPixelBuffer::metric(QPaintDevice::PaintDeviceMetric metric ) const**

        Reimplements: **QPaintDevice::metric** (QPaintDevice::PaintDeviceMetric metric) const.
        """
        ...

    def paintEngine(self) -> PySide2.QtGui.QPaintEngine:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#paintEngine

        **[override virtual] QPaintEngine *QGLPixelBuffer::paintEngine() const**

        Reimplements: **QPaintDevice::paintEngine** () const.
        """
        ...

    def releaseFromDynamicTexture(self) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#releaseFromDynamicTexture

        **void QGLPixelBuffer::releaseFromDynamicTexture()**

        Releases the pbuffer from any previously bound texture.

        **See also** **bindToDynamicTexture** ().
        """
        ...

    def size(self) -> PySide2.QtCore.QSize:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#size

        **QSize QGLPixelBuffer::size() const**

        Returns the size of the pbuffer.
        """
        ...

    def toImage(self) -> PySide2.QtGui.QImage:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#toImage

        **QImage QGLPixelBuffer::toImage() const**

        Returns the contents of the pbuffer as a **QImage** .
        """
        ...

    def updateDynamicTexture(self, texture_id: int) -> None:
        """
        https://doc.qt.io/qt-5/qglpixelbuffer.html#updateDynamicTexture

        **void QGLPixelBuffer::updateDynamicTexture(GLuint texture_id ) const**

        Copies the pbuffer contents into the texture specified with **texture_id**.

        The texture must be of the same size and format as the pbuffer.

        Example:

        **QGLPixelBuffer**  pbuffer(...);
            ...
            pbuffer.makeCurrent();
            GLuint dynamicTexture = pbuffer.generateDynamicTexture();
            ...
            pbuffer.updateDynamicTexture(dynamicTexture);

        An alternative on Windows and macOS systems that support the `render_texture` extension is to use **bindToDynamicTexture** () to get dynamic updates of the texture.

        **See also** **generateDynamicTexture** () and **bindToDynamicTexture** ().
        """
        ...
