"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtWidgets
import PySide2.QtTest

bytes = str


class QTest(object):
    """
    https://doc.qt.io/qt-5/qtest.html

    **Detailed Description**

    See the **Qt Test Overview**  for information about how to write unit tests.
    """

    FramesPerSecond: QTest = ...
    MousePress: QTest = ...
    Press: QTest = ...
    Abort: QTest = ...
    BitsPerSecond: QTest = ...
    MouseRelease: QTest = ...
    Release: QTest = ...
    BytesPerSecond: QTest = ...
    Click: QTest = ...
    Continue: QTest = ...
    MouseClick: QTest = ...
    MouseDClick: QTest = ...
    Shortcut: QTest = ...
    WalltimeMilliseconds: QTest = ...
    CPUTicks: QTest = ...
    MouseMove: QTest = ...
    InstructionReads: QTest = ...
    Events: QTest = ...
    WalltimeNanoseconds: QTest = ...
    BytesAllocated: QTest = ...
    CPUMigrations: QTest = ...
    CPUCycles: QTest = ...
    BusCycles: QTest = ...
    StalledCycles: QTest = ...
    Instructions: QTest = ...
    BranchInstructions: QTest = ...
    BranchMisses: QTest = ...
    CacheReferences: QTest = ...
    CacheReads: QTest = ...
    CacheWrites: QTest = ...
    CachePrefetches: QTest = ...
    CacheMisses: QTest = ...
    CacheReadMisses: QTest = ...
    CacheWriteMisses: QTest = ...
    CachePrefetchMisses: QTest = ...
    ContextSwitches: QTest = ...
    PageFaults: QTest = ...
    MinorPageFaults: QTest = ...
    MajorPageFaults: QTest = ...
    AlignmentFaults: QTest = ...
    EmulationFaults: QTest = ...
    RefCPUCycles: QTest = ...

    class KeyAction(object):
        Press: QTest.KeyAction = ...
        Release: QTest.KeyAction = ...
        Click: QTest.KeyAction = ...
        Shortcut: QTest.KeyAction = ...

    class MouseAction(object):
        MousePress: QTest.MouseAction = ...
        MouseRelease: QTest.MouseAction = ...
        MouseClick: QTest.MouseAction = ...
        MouseDClick: QTest.MouseAction = ...
        MouseMove: QTest.MouseAction = ...

    class QBenchmarkMetric(object):
        FramesPerSecond: QTest.QBenchmarkMetric = ...
        BitsPerSecond: QTest.QBenchmarkMetric = ...
        BytesPerSecond: QTest.QBenchmarkMetric = ...
        WalltimeMilliseconds: QTest.QBenchmarkMetric = ...
        CPUTicks: QTest.QBenchmarkMetric = ...
        InstructionReads: QTest.QBenchmarkMetric = ...
        Events: QTest.QBenchmarkMetric = ...
        WalltimeNanoseconds: QTest.QBenchmarkMetric = ...
        BytesAllocated: QTest.QBenchmarkMetric = ...
        CPUMigrations: QTest.QBenchmarkMetric = ...
        CPUCycles: QTest.QBenchmarkMetric = ...
        BusCycles: QTest.QBenchmarkMetric = ...
        StalledCycles: QTest.QBenchmarkMetric = ...
        Instructions: QTest.QBenchmarkMetric = ...
        BranchInstructions: QTest.QBenchmarkMetric = ...
        BranchMisses: QTest.QBenchmarkMetric = ...
        CacheReferences: QTest.QBenchmarkMetric = ...
        CacheReads: QTest.QBenchmarkMetric = ...
        CacheWrites: QTest.QBenchmarkMetric = ...
        CachePrefetches: QTest.QBenchmarkMetric = ...
        CacheMisses: QTest.QBenchmarkMetric = ...
        CacheReadMisses: QTest.QBenchmarkMetric = ...
        CacheWriteMisses: QTest.QBenchmarkMetric = ...
        CachePrefetchMisses: QTest.QBenchmarkMetric = ...
        ContextSwitches: QTest.QBenchmarkMetric = ...
        PageFaults: QTest.QBenchmarkMetric = ...
        MinorPageFaults: QTest.QBenchmarkMetric = ...
        MajorPageFaults: QTest.QBenchmarkMetric = ...
        AlignmentFaults: QTest.QBenchmarkMetric = ...
        EmulationFaults: QTest.QBenchmarkMetric = ...
        RefCPUCycles: QTest.QBenchmarkMetric = ...

    class QTouchEventSequence(object):
        def commit(self, processEvents: bool = ...) -> None:
            ...

        @typing.overload
        def move(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def move(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def press(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def press(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def release(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            widget: typing.Optional[PySide2.QtWidgets.QWidget] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        @typing.overload
        def release(
            self,
            touchId: int,
            pt: PySide2.QtCore.QPoint,
            window: typing.Optional[PySide2.QtGui.QWindow] = ...,
        ) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

        def stationary(self, touchId: int) -> PySide2.QtTest.QTest.QTouchEventSequence:
            ...

    class TestFailMode(object):
        Abort: QTest.TestFailMode = ...
        Continue: QTest.TestFailMode = ...

    @staticmethod
    def addColumnInternal(id: int, name: bytes) -> None:
        ...

    @staticmethod
    def asciiToKey(ascii: int) -> PySide2.QtCore.Qt.Key:
        ...

    @staticmethod
    def compare_ptr_helper(
        t1: int, t2: int, actual: bytes, expected: bytes, file: bytes, line: int
    ) -> bool:
        ...

    @staticmethod
    def compare_string_helper(
        t1: bytes, t2: bytes, actual: bytes, expected: bytes, file: bytes, line: int
    ) -> bool:
        ...

    @staticmethod
    def createTouchDevice(
        devType: PySide2.QtGui.QTouchDevice.DeviceType = ...,
    ) -> PySide2.QtGui.QTouchDevice:
        """
        https://doc.qt.io/qt-5/qtest.html#createTouchDevice

        **QTouchDevice *QTest::createTouchDevice(QTouchDevice::DeviceType devType = QTouchDevice::TouchScreen)**

        Creates a dummy touch device of type **devType** for simulation of touch events.

        The touch device will be registered with the QPA window system interface, and deleted automatically when the **QCoreApplication**  is deleted. So you should typically use createTouchDevice() to initialize a **QTouchDevice**  member variable in your test case class, and use the same instance for all tests.

        This function was introduced in Qt 5.8.

        **See also** **QTest::QTouchEventSequence** .
        """
        ...

    @staticmethod
    def currentAppName() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentAppName

        **const char *QTest::currentAppName()**

        Returns the name of the binary that is currently executed.
        """
        ...

    @staticmethod
    def currentDataTag() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentDataTag

        **const char *QTest::currentDataTag()**

        Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns 0.
        """
        ...

    @staticmethod
    def currentTestFailed() -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#currentTestFailed

        **bool QTest::currentTestFailed()**

        Returns `true` if the current test function failed, otherwise false.
        """
        ...

    @staticmethod
    def currentTestFunction() -> bytes:
        """
        https://doc.qt.io/qt-5/qtest.html#currentTestFunction

        **const char *QTest::currentTestFunction()**

        Returns the name of the test function that is currently executed.

        Example:

        void MyTestClass::cleanup()
            {
                if (qstrcmp(QTest::currentTestFunction(), "myDatabaseTest") == 0) {
                    // clean up all database connections
                    closeAllDatabases();
                }
            }
        """
        ...

    @typing.overload
    @staticmethod
    def ignoreMessage(type: PySide2.QtCore.QtMsgType, message: bytes) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#ignoreMessage

        **void QTest::ignoreMessage(QtMsgType type , const char * message )**

        Ignores messages created by **qDebug** (), **qInfo** () or **qWarning** (). If the **message** with the corresponding **type** is outputted, it will be removed from the test log. If the test finished and the **message** was not outputted, a test failure is appended to the test log.

        **Note:** Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.

        Example:

        **QDir**  dir;
            QTest::ignoreMessage(**QtWarningMsg** , "QDir::mkdir: Empty or null file name(s)");
            dir.mkdir("");

        The example above tests that **QDir::mkdir** () outputs the right warning when invoked with an invalid file name.
        """
        ...

    @typing.overload
    @staticmethod
    def ignoreMessage(
        type: PySide2.QtCore.QtMsgType,
        messagePattern: PySide2.QtCore.QRegularExpression,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#ignoreMessage

        **void QTest::ignoreMessage(QtMsgType type , const char * message )**

        Ignores messages created by **qDebug** (), **qInfo** () or **qWarning** (). If the **message** with the corresponding **type** is outputted, it will be removed from the test log. If the test finished and the **message** was not outputted, a test failure is appended to the test log.

        **Note:** Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.

        Example:

        **QDir**  dir;
            QTest::ignoreMessage(**QtWarningMsg** , "QDir::mkdir: Empty or null file name(s)");
            dir.mkdir("");

        The example above tests that **QDir::mkdir** () outputs the right warning when invoked with an invalid file name.
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick

        **void QTest::keyClick(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking of **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(myWidget, Qt::Key_Escape);

            QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on `myWidget` without any keyboard modifiers and without delay. The second example simulates clicking `shift-escape` on `myWidget` following a 200 ms delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick

        **void QTest::keyClick(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking of **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(myWidget, Qt::Key_Escape);

            QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on `myWidget` without any keyboard modifiers and without delay. The second example simulates clicking `shift-escape` on `myWidget` following a 200 ms delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick

        **void QTest::keyClick(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking of **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(myWidget, Qt::Key_Escape);

            QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on `myWidget` without any keyboard modifiers and without delay. The second example simulates clicking `shift-escape` on `myWidget` following a 200 ms delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyClick(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClick

        **void QTest::keyClick(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking of **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before clicking the key.

        Examples:

        QTest::keyClick(myWidget, Qt::Key_Escape);

            QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);

        The first example above simulates clicking the `escape` key on `myWidget` without any keyboard modifiers and without delay. The second example simulates clicking `shift-escape` on `myWidget` following a 200 ms delay of the test.

        **See also** **QTest::keyClicks** ().
        """
        ...

    @staticmethod
    def keyClicks(
        widget: PySide2.QtWidgets.QWidget,
        sequence: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyClicks

        **void QTest::keyClicks(QWidget * widget , const QString & sequence , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates clicking a **sequence** of keys on a **widget**. Optionally, a keyboard **modifier** can be specified as well as a **delay** (in milliseconds) of the test before each key click.

        Example:

        QTest::keyClicks(myWidget, "hello world");

        The example above simulates clicking the sequence of keys representing "hello world" on `myWidget` without any keyboard modifiers and without delay of the test.

        **See also** **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Sends a Qt key event to **widget** with the given **key** and an associated **action**. Optionally, a keyboard **modifier** can be specified, as well as a **delay** (in milliseconds) of the test before sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Sends a Qt key event to **widget** with the given **key** and an associated **action**. Optionally, a keyboard **modifier** can be specified, as well as a **delay** (in milliseconds) of the test before sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Sends a Qt key event to **widget** with the given **key** and an associated **action**. Optionally, a keyboard **modifier** can be specified, as well as a **delay** (in milliseconds) of the test before sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyEvent

        **void QTest::keyEvent(QTest::KeyAction action , QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Sends a Qt key event to **widget** with the given **key** and an associated **action**. Optionally, a keyboard **modifier** can be specified, as well as a **delay** (in milliseconds) of the test before sending the event.
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress

        **void QTest::keyPress(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates pressing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease** ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress

        **void QTest::keyPress(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates pressing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease** ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress

        **void QTest::keyPress(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates pressing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease** ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyPress(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyPress

        **void QTest::keyPress(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates pressing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before pressing the key.

        **Note:** At some point you should release the key using **keyRelease** ().

        **See also** **QTest::keyRelease** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        widget: PySide2.QtWidgets.QWidget,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease

        **void QTest::keyRelease(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates releasing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before releasing the key.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        widget: PySide2.QtWidgets.QWidget,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease

        **void QTest::keyRelease(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates releasing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before releasing the key.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        window: PySide2.QtGui.QWindow,
        key: PySide2.QtCore.Qt.Key,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease

        **void QTest::keyRelease(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates releasing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before releasing the key.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keyRelease(
        window: PySide2.QtGui.QWindow,
        key: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keyRelease

        **void QTest::keyRelease(QWidget * widget , Qt::Key key , Qt::KeyboardModifiers modifier = Qt::NoModifier, int delay = -1)**

        Simulates releasing a **key** with an optional **modifier** on a **widget**. If **delay** is larger than 0, the test will wait for **delay** milliseconds before releasing the key.

        **See also** **QTest::keyPress** () and **QTest::keyClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keySequence(
        widget: PySide2.QtWidgets.QWidget, keySequence: PySide2.QtGui.QKeySequence
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keySequence

        **void QTest::keySequence(QWindow * window , const QKeySequence & keySequence )**

        This is an overloaded function.

        Simulates typing of **keySequence** into a **window**.

        This function was introduced in Qt 5.10.

        **See also** **QTest::keyClick** () and **QTest::keyClicks** ().
        """
        ...

    @typing.overload
    @staticmethod
    def keySequence(
        window: PySide2.QtGui.QWindow, keySequence: PySide2.QtGui.QKeySequence
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#keySequence

        **void QTest::keySequence(QWindow * window , const QKeySequence & keySequence )**

        This is an overloaded function.

        Simulates typing of **keySequence** into a **window**.

        This function was introduced in Qt 5.10.

        **See also** **QTest::keyClick** () and **QTest::keyClicks** ().
        """
        ...

    @staticmethod
    def keyToAscii(key: PySide2.QtCore.Qt.Key) -> int:
        ...

    @typing.overload
    @staticmethod
    def mouseClick(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseClick

        **void QTest::mouseClick(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates clicking a mouse **button** with an optional **modifier** on a **widget**. The position of the click is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseRelease** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseClick(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseClick

        **void QTest::mouseClick(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates clicking a mouse **button** with an optional **modifier** on a **widget**. The position of the click is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseRelease** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseDClick(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseDClick

        **void QTest::mouseDClick(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates double clicking a mouse **button** with an optional **modifier** on a **widget**. The position of the click is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before each press and release.

        **See also** **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseDClick(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseDClick

        **void QTest::mouseDClick(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates double clicking a mouse **button** with an optional **modifier** on a **widget**. The position of the click is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before each press and release.

        **See also** **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseEvent(
        action: PySide2.QtTest.QTest.MouseAction,
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers,
        pos: PySide2.QtCore.QPoint,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def mouseEvent(
        action: PySide2.QtTest.QTest.MouseAction,
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers,
        pos: PySide2.QtCore.QPoint,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def mouseMove(
        widget: PySide2.QtWidgets.QWidget,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseMove

        **void QTest::mouseMove(QWidget * widget , QPoint pos = QPoint(), int delay = -1)**

        Moves the mouse pointer to a **widget**. If **pos** is not specified, the mouse pointer moves to the center of the widget. If a **delay** (in milliseconds) is given, the test will wait before moving the mouse pointer.
        """
        ...

    @typing.overload
    @staticmethod
    def mouseMove(
        window: PySide2.QtGui.QWindow,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseMove

        **void QTest::mouseMove(QWidget * widget , QPoint pos = QPoint(), int delay = -1)**

        Moves the mouse pointer to a **widget**. If **pos** is not specified, the mouse pointer moves to the center of the widget. If a **delay** (in milliseconds) is given, the test will wait before moving the mouse pointer.
        """
        ...

    @typing.overload
    @staticmethod
    def mousePress(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mousePress

        **void QTest::mousePress(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates pressing a mouse **button** with an optional **modifier** on a **widget**. The position is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before the press.

        **See also** **QTest::mouseRelease** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mousePress(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mousePress

        **void QTest::mousePress(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates pressing a mouse **button** with an optional **modifier** on a **widget**. The position is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before the press.

        **See also** **QTest::mouseRelease** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseRelease(
        widget: PySide2.QtWidgets.QWidget,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseRelease

        **void QTest::mouseRelease(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates releasing a mouse **button** with an optional **modifier** on a **widget**. The position of the release is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseClick** ().
        """
        ...

    @typing.overload
    @staticmethod
    def mouseRelease(
        window: PySide2.QtGui.QWindow,
        button: PySide2.QtCore.Qt.MouseButton,
        stateKey: PySide2.QtCore.Qt.KeyboardModifiers = ...,
        pos: PySide2.QtCore.QPoint = ...,
        delay: int = ...,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#mouseRelease

        **void QTest::mouseRelease(QWidget * widget , Qt::MouseButton button , Qt::KeyboardModifiers modifier = 0, QPoint pos = QPoint(), int delay = -1)**

        Simulates releasing a mouse **button** with an optional **modifier** on a **widget**. The position of the release is defined by **pos** ; the default position is the center of the widget. If **delay** is specified, the test will wait for the specified amount of milliseconds before releasing the button.

        **See also** **QTest::mousePress** () and **QTest::mouseClick** ().
        """
        ...

    @staticmethod
    def qCleanup() -> None:
        ...

    @staticmethod
    def qElementData(elementName: bytes, metaTypeId: int) -> int:
        ...

    @staticmethod
    def qExpectFail(
        dataIndex: bytes,
        comment: bytes,
        mode: PySide2.QtTest.QTest.TestFailMode,
        file: bytes,
        line: int,
    ) -> bool:
        ...

    @typing.overload
    @staticmethod
    def qFindTestData(
        basepath: str,
        file: typing.Optional[bytes] = ...,
        line: int = ...,
        builddir: typing.Optional[bytes] = ...,
    ) -> str:
        ...

    @typing.overload
    @staticmethod
    def qFindTestData(
        basepath: bytes,
        file: typing.Optional[bytes] = ...,
        line: int = ...,
        builddir: typing.Optional[bytes] = ...,
    ) -> str:
        ...

    @staticmethod
    def qGlobalData(tagName: bytes, typeId: int) -> int:
        ...

    @staticmethod
    def qRun() -> int:
        ...

    @staticmethod
    def qSkip(message: bytes, file: bytes, line: int) -> None:
        ...

    @staticmethod
    def qWaitForWindowActive(
        widget: PySide2.QtWidgets.QWidget, timeout: int = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#qWaitForWindowActive

        **bool QTest::qWaitForWindowActive(QWindow * window , int timeout = 5000)**

        Waits for **timeout** milliseconds or until the **window** is active.

        Returns `true` if `window` is active within **timeout** milliseconds, otherwise returns `false`.

        This function was introduced in Qt 5.0.

        **See also** **qWaitForWindowExposed** () and **QWindow::isActive** ().
        """
        ...

    @staticmethod
    def qWaitForWindowExposed(
        widget: PySide2.QtWidgets.QWidget, timeout: int = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qtest.html#qWaitForWindowExposed

        **bool QTest::qWaitForWindowExposed(QWindow * window , int timeout = 5000)**

        Waits for **timeout** milliseconds or until the **window** is exposed. Returns `true` if `window` is exposed within **timeout** milliseconds, otherwise returns `false`.

        This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some time after being asked to show itself on the screen.

        Note that a window that is mapped to screen may still not be considered exposed if the window client area is completely covered by other windows, or if the window is otherwise not visible. This function will then time out when waiting for such a window.

        This function was introduced in Qt 5.0.

        **See also** **qWaitForWindowActive** () and **QWindow::isExposed** ().
        """
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        code: PySide2.QtCore.Qt.Key,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        widget: PySide2.QtWidgets.QWidget,
        code: PySide2.QtCore.Qt.Key,
        text: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        code: PySide2.QtCore.Qt.Key,
        ascii: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def sendKeyEvent(
        action: PySide2.QtTest.QTest.KeyAction,
        window: PySide2.QtGui.QWindow,
        code: PySide2.QtCore.Qt.Key,
        text: str,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        delay: int = ...,
    ) -> None:
        ...

    @staticmethod
    def setBenchmarkResult(
        result: float, metric: PySide2.QtTest.QTest.QBenchmarkMetric
    ) -> None:
        """
        https://doc.qt.io/qt-5/qtest.html#setBenchmarkResult

        **void QTest::setBenchmarkResult(qreal result , QTest::QBenchmarkMetric metric )**

        Sets the benchmark result for this test function to **result**.

        Use this function if you want to report benchmark results without using the QBENCHMARK macro. Use **metric** to specify how Qt Test should interpret the results.

        The context for the result will be the test function name and any data tag from the _data function. This function can only be called once in each test function, subsequent calls will replace the earlier reported results.

        Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.

        This function was introduced in Qt 4.7.
        """
        ...

    @staticmethod
    def setMainSourcePath(file: bytes, builddir: typing.Optional[bytes] = ...) -> None:
        ...

    @typing.overload
    @staticmethod
    def simulateEvent(
        widget: PySide2.QtWidgets.QWidget,
        press: bool,
        code: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        text: str,
        repeat: bool,
        delay: int = ...,
    ) -> None:
        ...

    @typing.overload
    @staticmethod
    def simulateEvent(
        window: PySide2.QtGui.QWindow,
        press: bool,
        code: int,
        modifier: PySide2.QtCore.Qt.KeyboardModifiers,
        text: str,
        repeat: bool,
        delay: int = ...,
    ) -> None:
        ...

    @staticmethod
    def testObject() -> PySide2.QtCore.QObject:
        ...

    @staticmethod
    def toPrettyCString(unicode: bytes, length: int) -> bytes:
        ...

    @typing.overload
    @staticmethod
    def touchEvent(
        widget: PySide2.QtWidgets.QWidget,
        device: PySide2.QtGui.QTouchDevice,
        autoCommit: bool = ...,
    ) -> PySide2.QtTest.QTest.QTouchEventSequence:
        """
        https://doc.qt.io/qt-5/qtest.html#touchEvent

        **QTest::QTouchEventSequence QTest::touchEvent(QWidget * widget , QTouchDevice * device , bool autoCommit )**

        Creates and returns a **QTouchEventSequence**  for the **device** to simulate events for **widget**.

        When adding touch events to the sequence, **widget** will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.

        The touch events are committed to the event system when the destructor of the **QTouchEventSequence**  is called (ie when the object returned runs out of scope), unless **autoCommit** is set to false. When **autoCommit** is false, commit() has to be called manually.
        """
        ...

    @typing.overload
    @staticmethod
    def touchEvent(
        window: PySide2.QtGui.QWindow,
        device: PySide2.QtGui.QTouchDevice,
        autoCommit: bool = ...,
    ) -> PySide2.QtTest.QTest.QTouchEventSequence:
        """
        https://doc.qt.io/qt-5/qtest.html#touchEvent

        **QTest::QTouchEventSequence QTest::touchEvent(QWidget * widget , QTouchDevice * device , bool autoCommit )**

        Creates and returns a **QTouchEventSequence**  for the **device** to simulate events for **widget**.

        When adding touch events to the sequence, **widget** will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.

        The touch events are committed to the event system when the destructor of the **QTouchEventSequence**  is called (ie when the object returned runs out of scope), unless **autoCommit** is set to false. When **autoCommit** is false, commit() has to be called manually.
        """
        ...
