"""
PySide stub files generated by **IceSpringPySideStubs**

Home: https://baijifeilong.github.io/2022/01/06/ice-spring-pyside-stubs/index.html

Github: https://github.com/baijifeilong/IceSpringPySideStubs

PyPI(PySide2): https://pypi.org/project/IceSpringPySideStubs-PySide2

PyPI(PySide6): https://pypi.org/project/IceSpringPySideStubs-PySide6

PyPI(PyQt5): https://pypi.org/project/IceSpringPySideStubs-PyQt5

PyPI(PyQt6): https://pypi.org/project/IceSpringPySideStubs-PyQt6

Generated by BaiJiFeiLong@gmail.com

Licence: MIT
"""
"""
This file contains the exact signatures for all functions in module
PySide2.QtScript, except for defaults which are replaced by "...".
"""
import PySide2
import typing
import PySide2.QtCore
import PySide2.QtScript

bytes = str


class QScriptClass(object):
    """
    https://doc.qt.io/qt-5/qscriptclass.html

    **Detailed Description**

    The QScriptClass class defines an interface for handling various aspects of
    interaction with the Qt Script objects associated with the class. Such
    objects are created by calling **QScriptEngine::newObject** (), passing a
    pointer to the QScriptClass as argument.

    By subclassing QScriptClass, you can define precisely how access to
    properties of the objects that use your class is handled. This enables a
    fully dynamic handling of properties, e.g. it's more powerful than
    **QScriptEngine::newQObject** (). For example, you can use QScriptClass to
    implement array-type objects (i.e. objects that handle the `length`
    property, and properties whose names are valid array indexes, in a special
    way), or to implement a "live" (runtime-defined) proxy to an underlying
    object.

    If you just need to handle access to a set of properties that are known at
    the time an object is created (i.e. "semi-statically"), you might consider
    using **QScriptValue::setProperty** () to define getter/setter functions for
    the relevant properties, rather than subclassing QScriptClass.

    Reimplement **queryProperty** () to specify which properties are handled in
    a custom way by your script class (i.e. should be **delegated** to the
    QScriptClass), and which properties should be handled just like normal Qt
    Script object properties.

    Reimplement **property** () and **setProperty** () to perform the actual
    access (read or write) to the properties that your class handles.
    Additionally, you can reimplement **propertyFlags** () to specify custom
    flags for your properties.

    Reimplement **newIterator** () to provide an iterator for objects of your
    custom class. This is only necessary if objects of your class can have
    custom properties that you want to be reported when an object is used
    together with the **QScriptValueIterator**  class, or when an object is used
    in a for-in enumeration statement in a script.

    When implementing custom classes of objects, you typically use
    **QScriptValue::setData** () to store instance-specific data as part of
    object initialization; the data won't be accessible from scripts directly,
    but you can access it in e.g. your reimplementations of **property** () and
    **setProperty** () (by calling **QScriptValue::data** ()) to perform custom
    processing.

    Reimplement **prototype** () to provide a custom prototype object for your
    script class.

    Reimplement **supportsExtension** () and **extension** () if your custom
    script class supports one or more of the extensions specified by the
    Extension enum.

    **See also** **QScriptClassPropertyIterator** , **QScriptEngine::newObject**
    (), and **Defining Custom Script Classes with QScriptClass** .
    """

    Callable: QScriptClass = ...
    HandlesReadAccess: QScriptClass = ...
    HasInstance: QScriptClass = ...
    HandlesWriteAccess: QScriptClass = ...

    class Extension(object):
        Callable: QScriptClass.Extension = ...
        HasInstance: QScriptClass.Extension = ...

    class QueryFlag(object):
        HandlesReadAccess: QScriptClass.QueryFlag = ...
        HandlesWriteAccess: QScriptClass.QueryFlag = ...

    def __init__(self, engine: PySide2.QtScript.QScriptEngine) -> None:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#QScriptClass

        **QScriptClass::QScriptClass(QScriptEngine * engine )**

        Constructs a QScriptClass object to be used in the given **engine**.

        The engine does not take ownership of the QScriptClass object.
        """
        ...

    def engine(self) -> PySide2.QtScript.QScriptEngine:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#engine

        **QScriptEngine *QScriptClass::engine() const**

        Returns the engine that this **QScriptClass**  is associated with.
        """
        ...

    def extension(
        self,
        extension: PySide2.QtScript.QScriptClass.Extension,
        argument: typing.Any = ...,
    ) -> typing.Any:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#extension

        **[virtual] QVariant QScriptClass::extension(QScriptClass::Extension
        extension , const QVariant & argument = QVariant())**

        This virtual function can be reimplemented in a **QScriptClass**
        subclass to provide support for extensions. The optional **argument**
        can be provided as input to the **extension** ; the result must be
        returned in the form of a **QVariant** . You can call
        **supportsExtension** () to check if an extension is supported by the
        **QScriptClass** . By default, no extensions are supported, and this
        function returns an invalid **QVariant** .

        If you implement the Callable extension, Qt Script will call this
        function when an instance of your class is called as a function (e.g.
        from a script or using **QScriptValue::call** ()). The **argument** will
        contain a pointer to the **QScriptContext**  that represents the
        function call, and you should return a **QVariant**  that holds the
        result of the function call. In the following example the sum of the
        arguments to the script function are added up and returned:

        if (extension == Callable) {
                **QScriptContext**  *context =
        qvariant_cast<**QScriptContext** \\*>(argument);
        **QScriptEngine**  *engine = context->engine();
                double sum = 0;
        for (int i = 0; i < context->argumentCount(); ++i)
                    sum +=
        context->argument(i).toNumber();
                return sum;
            }

        If you implement the **HasInstance**  extension, Qt Script will call
        this function as part of evaluating the `instanceof` operator, as
        described in ECMA-262 Section 11.8.6. The **argument** is a
        QScriptValueList containing two items: The first item is the object that
        **HasInstance**  is being applied to (an instance of your class), and
        the second item can be any value. extension() should return true if the
        value delegates behavior to the object, false otherwise.

        **See also** **supportsExtension** ().
        """
        ...

    def name(self) -> str:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#name

        **[virtual] QString QScriptClass::name() const**

        Returns the name of the script class.

        Qt Script uses this name to generate a default string representation of
        objects in case you do not provide a toString function.

        The default implementation returns a null string.
        """
        ...

    def newIterator(
        self, object: PySide2.QtScript.QScriptValue
    ) -> PySide2.QtScript.QScriptClassPropertyIterator:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#newIterator

        **[virtual] QScriptClassPropertyIterator
        *QScriptClass::newIterator(const QScriptValue & object )**

        Returns an iterator for traversing custom properties of the given
        **object**.

        The default implementation returns 0, meaning that there are no custom
        properties to traverse.

        Reimplement this function if objects of your script class can have one
        or more custom properties (e.g. those reported to be handled by
        **queryProperty** ()) that you want to appear when an object's
        properties are enumerated (e.g. by a for-in statement in a script).

        Qt Script takes ownership of the new iterator object.

        **See also** **QScriptValueIterator** .
        """
        ...

    def property(
        self,
        object: PySide2.QtScript.QScriptValue,
        name: PySide2.QtScript.QScriptString,
        id: int,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#property

        **[virtual] QScriptValue QScriptClass::property(const QScriptValue &
        object , const QScriptString & name , uint id )**

        Returns the value of the property with the given **name** of the given
        **object**.

        The **id** argument is only useful if you assigned a value to it in
        **queryProperty** ().

        The default implementation does nothing and returns an invalid
        **QScriptValue** .

        **See also** **setProperty** () and **propertyFlags** ().
        """
        ...

    def propertyFlags(
        self,
        object: PySide2.QtScript.QScriptValue,
        name: PySide2.QtScript.QScriptString,
        id: int,
    ) -> PySide2.QtScript.QScriptValue.PropertyFlags:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#propertyFlags

        **[virtual] QScriptValue::PropertyFlags
        QScriptClass::propertyFlags(const QScriptValue & object , const
        QScriptString & name , uint id )**

        Returns the flags of the property with the given **name** of the given
        **object**.

        The **id** argument is only useful if you assigned a value to it in
        **queryProperty** ().

        The default implementation returns 0.

        **See also** **property** ().
        """
        ...

    def prototype(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#prototype

        **[virtual] QScriptValue QScriptClass::prototype() const**

        Returns the object to be used as the prototype of new instances of this
        class (created with **QScriptEngine::newObject** ()).

        The default implementation returns an invalid **QScriptValue** , meaning
        that the standard Object prototype will be used. Reimplement this
        function to provide your own custom prototype.

        Typically you initialize your prototype object in the constructor of
        your class, then return it in this function.

        See the "Making Use of Prototype-Based Inheritance" section in the Qt
        Script documentation for more information on how prototypes are used.
        """
        ...

    def setProperty(
        self,
        object: PySide2.QtScript.QScriptValue,
        name: PySide2.QtScript.QScriptString,
        id: int,
        value: PySide2.QtScript.QScriptValue,
    ) -> None:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#setProperty

        **[virtual] void QScriptClass::setProperty(QScriptValue & object , const
        QScriptString & name , uint id , const QScriptValue & value )**

        Sets the property with the given **name** of the given **object** to the
        given **value**.

        The **id** argument is only useful if you assigned a value to it in
        **queryProperty** ().

        The default implementation does nothing.

        An invalid **value** represents a request to remove the property.

        **See also** **property** ().
        """
        ...

    def supportsExtension(
        self, extension: PySide2.QtScript.QScriptClass.Extension
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qscriptclass.html#supportsExtension

        **[virtual] bool QScriptClass::supportsExtension(QScriptClass::Extension
        extension ) const**

        Returns true if the **QScriptClass**  supports the given **extension** ;
        otherwise, false is returned. By default, no extensions are supported.

        Reimplement this function to indicate which extensions your custom class
        supports.

        **See also** **extension** ().
        """
        ...
