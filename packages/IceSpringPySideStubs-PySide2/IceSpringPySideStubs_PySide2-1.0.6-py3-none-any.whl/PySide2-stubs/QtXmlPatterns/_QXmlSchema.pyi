"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com'Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtXmlPatterns

bytes = str


class QXmlSchema(object):
    """
    https://doc.qt.io/qt-5/qxmlschema.html

    **Detailed Description**

    The QXmlSchema class loads, compiles and validates W3C XML Schema files that
    can be used further for validation of XML instance documents via
    **QXmlSchemaValidator** .

    The following example shows how to load a XML Schema file from the network
    and test whether it is a valid schema document:

    **QUrl**  url("http://www.schema-example.org/myschema.xsd");
    **QXmlSchema**  schema;
            if (schema.load(url) == true)
    **qDebug** () << "schema is valid";
            else
                **qDebug** ()
    << "schema is invalid";

    **XML Schema Version**

    This class is used to represent schemas that conform to the **XML Schema**
    1.0 specification.

    **See also** **QXmlSchemaValidator**  and **XML Schema Validation Example**
    .
    """

    @typing.overload
    def __init__(self) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#QXmlSchema

        **QXmlSchema::QXmlSchema()**

        Constructs an invalid, empty schema that cannot be used until **load**
        () is called.
        """
        ...

    @typing.overload
    def __init__(self, other: PySide2.QtXmlPatterns.QXmlSchema) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#QXmlSchema

        **QXmlSchema::QXmlSchema()**

        Constructs an invalid, empty schema that cannot be used until **load**
        () is called.
        """
        ...

    def documentUri(self) -> PySide2.QtCore.QUrl:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#documentUri

        **QUrl QXmlSchema::documentUri() const**

        Returns the document URI of the schema or an empty URI if no schema has
        been set.
        """
        ...

    def isValid(self) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#isValid

        **bool QXmlSchema::isValid() const**

        Returns true if this schema is valid. Examples of invalid schemas are
        ones that contain syntax errors or that do not conform the W3C XML
        Schema specification.
        """
        ...

    @typing.overload
    def load(
        self, data: PySide2.QtCore.QByteArray, documentUri: PySide2.QtCore.QUrl = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is
        undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");
        **QXmlSchema**  schema;
                if (schema.load(url) == true)
        **qDebug** () << "schema is valid";
                else
                    **qDebug**
        () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    @typing.overload
    def load(
        self, source: PySide2.QtCore.QIODevice, documentUri: PySide2.QtCore.QUrl = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is
        undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");
        **QXmlSchema**  schema;
                if (schema.load(url) == true)
        **qDebug** () << "schema is valid";
                else
                    **qDebug**
        () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    @typing.overload
    def load(self, source: PySide2.QtCore.QUrl) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is
        undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");
        **QXmlSchema**  schema;
                if (schema.load(url) == true)
        **qDebug** () << "schema is valid";
                else
                    **qDebug**
        () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    def messageHandler(self) -> PySide2.QtXmlPatterns.QAbstractMessageHandler:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#messageHandler

        **QAbstractMessageHandler *QXmlSchema::messageHandler() const**

        Returns the message handler that handles compile and validation messages
        for this **QXmlSchema** .

        **See also** **setMessageHandler** ().
        """
        ...

    def namePool(self) -> PySide2.QtXmlPatterns.QXmlNamePool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#namePool

        **QXmlNamePool QXmlSchema::namePool() const**

        Returns the name pool used by this **QXmlSchema**  for constructing
        **names** . There is no setter for the name pool, because mixing name
        pools causes errors due to name confusion.
        """
        ...

    def setMessageHandler(
        self, handler: PySide2.QtXmlPatterns.QAbstractMessageHandler
    ) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#setMessageHandler

        **void QXmlSchema::setMessageHandler(QAbstractMessageHandler * handler
        )**

        Changes the **message handler**  for this **QXmlSchema**  to
        **handler**. The schema sends all compile and validation messages to
        this message handler. **QXmlSchema**  does not take ownership of
        **handler**.

        Normally, the default message handler is sufficient. It writes compile
        and validation messages to **stderr**. The default message handler
        includes color codes if **stderr** can render colors.

        When **QXmlSchema**  calls **QAbstractMessageHandler::message** (), the
        arguments are as follows:

        message() argumentSemantics
        **QtMsgType**  typeOnly **QtWarningMsg**
        and **QtFatalMsg**  are used. The former identifies a warning, while the
        latter identifies an error.
        const **QString**  & descriptionAn XHTML
        document which is the actual message. It is translated into the current
        language.
        const **QUrl**  &identifierIdentifies the error with a URI,
        where the fragment is the error code, and the rest of the URI is the
        error namespace.
        const **QSourceLocation**  & sourceLocationIdentifies
        where the error occurred.

        **See also** **messageHandler** ().
        """
        ...

    def setUriResolver(
        self, resolver: PySide2.QtXmlPatterns.QAbstractUriResolver
    ) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#setUriResolver

        **void QXmlSchema::setUriResolver(const QAbstractUriResolver * resolver
        )**

        Sets the URI resolver to **resolver**. **QXmlSchema**  does not take
        ownership of **resolver**.

        **See also** **uriResolver** ().
        """
        ...

    def uriResolver(self) -> PySide2.QtXmlPatterns.QAbstractUriResolver:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#uriResolver

        **const QAbstractUriResolver *QXmlSchema::uriResolver() const**

        Returns the schema's URI resolver. If no URI resolver has been set, Qt
        XML Patterns will use the URIs in schemas as they are.

        The URI resolver provides a level of abstraction, or **polymorphic
        URIs**. A resolver can rewrite **logical** URIs to physical ones, or it
        can translate obsolete or invalid URIs to valid ones.

        When Qt XML Patterns calls **QAbstractUriResolver::resolve** () the
        absolute URI is the URI mandated by the schema specification, and the
        relative URI is the URI specified by the user.

        **See also** **setUriResolver** ().
        """
        ...
