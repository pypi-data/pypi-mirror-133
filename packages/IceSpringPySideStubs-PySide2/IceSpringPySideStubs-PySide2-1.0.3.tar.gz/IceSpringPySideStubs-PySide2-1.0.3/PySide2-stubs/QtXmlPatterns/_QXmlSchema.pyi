"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtXmlPatterns

bytes = str


class QXmlSchema(object):
    """
    https://doc.qt.io/qt-5/qxmlschema.html

    **Detailed Description**

    The QXmlSchema class loads, compiles and validates W3C XML Schema files that can be used further for validation of XML instance documents via **QXmlSchemaValidator** .

    The following example shows how to load a XML Schema file from the network and test whether it is a valid schema document:

    **QUrl**  url("http://www.schema-example.org/myschema.xsd");

            **QXmlSchema**  schema;
            if (schema.load(url) == true)
                **qDebug** () << "schema is valid";
            else
                **qDebug** () << "schema is invalid";

    **XML Schema Version**

    This class is used to represent schemas that conform to the **XML Schema**  1.0 specification.

    **See also** **QXmlSchemaValidator**  and **XML Schema Validation Example** .
    """

    @typing.overload
    def __init__(self) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#QXmlSchema

        **QXmlSchema::QXmlSchema()**

        Constructs an invalid, empty schema that cannot be used until **load** () is called.
        """
        ...

    @typing.overload
    def __init__(self, other: PySide2.QtXmlPatterns.QXmlSchema) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#QXmlSchema

        **QXmlSchema::QXmlSchema()**

        Constructs an invalid, empty schema that cannot be used until **load** () is called.
        """
        ...

    def documentUri(self) -> PySide2.QtCore.QUrl:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#documentUri

        **QUrl QXmlSchema::documentUri() const**

        Returns the document URI of the schema or an empty URI if no schema has been set.
        """
        ...

    def isValid(self) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#isValid

        **bool QXmlSchema::isValid() const**

        Returns true if this schema is valid. Examples of invalid schemas are ones that contain syntax errors or that do not conform the W3C XML Schema specification.
        """
        ...

    @typing.overload
    def load(
        self, data: PySide2.QtCore.QByteArray, documentUri: PySide2.QtCore.QUrl = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");

                **QXmlSchema**  schema;
                if (schema.load(url) == true)
                    **qDebug** () << "schema is valid";
                else
                    **qDebug** () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    @typing.overload
    def load(
        self, source: PySide2.QtCore.QIODevice, documentUri: PySide2.QtCore.QUrl = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");

                **QXmlSchema**  schema;
                if (schema.load(url) == true)
                    **qDebug** () << "schema is valid";
                else
                    **qDebug** () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    @typing.overload
    def load(self, source: PySide2.QtCore.QUrl) -> bool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#load

        **bool QXmlSchema::load(const QUrl & source )**

        Sets this **QXmlSchema**  to a schema loaded from the **source** URI.

        If the schema **is invalid** , `false` is returned and the behavior is undefined.

        Example:

        **QUrl**  url("http://www.schema-example.org/myschema.xsd");

                **QXmlSchema**  schema;
                if (schema.load(url) == true)
                    **qDebug** () << "schema is valid";
                else
                    **qDebug** () << "schema is invalid";

        **See also** **isValid** ().
        """
        ...

    def messageHandler(self) -> PySide2.QtXmlPatterns.QAbstractMessageHandler:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#messageHandler

        **QAbstractMessageHandler *QXmlSchema::messageHandler() const**

        Returns the message handler that handles compile and validation messages for this **QXmlSchema** .

        **See also** **setMessageHandler** ().
        """
        ...

    def namePool(self) -> PySide2.QtXmlPatterns.QXmlNamePool:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#namePool

        **QXmlNamePool QXmlSchema::namePool() const**

        Returns the name pool used by this **QXmlSchema**  for constructing **names** . There is no setter for the name pool, because mixing name pools causes errors due to name confusion.
        """
        ...

    def setMessageHandler(
        self, handler: PySide2.QtXmlPatterns.QAbstractMessageHandler
    ) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#setMessageHandler

        **void QXmlSchema::setMessageHandler(QAbstractMessageHandler * handler )**

        Changes the **message handler**  for this **QXmlSchema**  to **handler**. The schema sends all compile and validation messages to this message handler. **QXmlSchema**  does not take ownership of **handler**.

        Normally, the default message handler is sufficient. It writes compile and validation messages to **stderr**. The default message handler includes color codes if **stderr** can render colors.

        When **QXmlSchema**  calls **QAbstractMessageHandler::message** (), the arguments are as follows:

        message() argumentSemantics
        **QtMsgType**  typeOnly **QtWarningMsg**  and **QtFatalMsg**  are used. The former identifies a warning, while the latter identifies an error.
        const **QString**  & descriptionAn XHTML document which is the actual message. It is translated into the current language.
        const **QUrl**  &identifierIdentifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.
        const **QSourceLocation**  & sourceLocationIdentifies where the error occurred.

        **See also** **messageHandler** ().
        """
        ...

    def setUriResolver(
        self, resolver: PySide2.QtXmlPatterns.QAbstractUriResolver
    ) -> None:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#setUriResolver

        **void QXmlSchema::setUriResolver(const QAbstractUriResolver * resolver )**

        Sets the URI resolver to **resolver**. **QXmlSchema**  does not take ownership of **resolver**.

        **See also** **uriResolver** ().
        """
        ...

    def uriResolver(self) -> PySide2.QtXmlPatterns.QAbstractUriResolver:
        """
        https://doc.qt.io/qt-5/qxmlschema.html#uriResolver

        **const QAbstractUriResolver *QXmlSchema::uriResolver() const**

        Returns the schema's URI resolver. If no URI resolver has been set, Qt XML Patterns will use the URIs in schemas as they are.

        The URI resolver provides a level of abstraction, or **polymorphic URIs**. A resolver can rewrite **logical** URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.

        When Qt XML Patterns calls **QAbstractUriResolver::resolve** () the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.

        **See also** **setUriResolver** ().
        """
        ...
