"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtScript

bytes = str


class QScriptEngine(PySide2.QtCore.QObject):
    """
    https://doc.qt.io/qt-5/qscriptengine.html

    **Detailed Description**

    See the **Qt Script**  documentation for information about the Qt Script language, and how to get started with scripting your C++ application.

    **Evaluating Scripts**

    Use **evaluate** () to evaluate script code; this is the C++ equivalent of the built-in script function `eval()`.

    **QScriptEngine**  myEngine;
        **QScriptValue**  three = myEngine.evaluate("1 + 2");

    **evaluate** () returns a **QScriptValue**  that holds the result of the evaluation. The **QScriptValue**  class provides functions for converting the result to various C++ types (e.g. **QScriptValue::toString** () and **QScriptValue::toNumber** ()).

    The following code snippet shows how a script function can be defined and then invoked from C++ using **QScriptValue::call** ():

    **QScriptValue**  fun = myEngine.evaluate("(function(a, b) { return a + b; })");
        QScriptValueList args;
        args << 1 << 2;
        **QScriptValue**  threeAgain = fun.call(**QScriptValue** (), args);

    As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to **evaluate** ():

    **QString**  fileName = "helloworld.qs";
        **QFile**  scriptFile(fileName);
        if (!scriptFile.open(**QIODevice** ::ReadOnly))
            // handle error
        **QTextStream**  stream(&scriptFile);
        **QString**  contents = stream.readAll();
        scriptFile.close();
        myEngine.evaluate(contents, fileName);

    Here we pass the name of the file as the second argument to **evaluate** (). This does not affect evaluation in any way; the second argument is a general-purpose string that is used to identify the script for debugging purposes (for example, our filename will now show up in any **uncaughtExceptionBacktrace** () involving the script).

    **Engine Configuration**

    The **globalObject** () function returns the **Global Object** associated with the script engine. Properties of the Global Object are accessible from any script code (i.e. they are global variables). Typically, before evaluating "user" scripts, you will want to configure a script engine by adding one or more properties to the Global Object:

    myEngine.globalObject().setProperty("myNumber", 123);
        ...
        **QScriptValue**  myNumberPlusOne = myEngine.evaluate("myNumber + 1");

    Adding custom properties to the scripting environment is one of the standard means of providing a scripting API that is specific to your application. Usually these custom properties are objects created by the **newQObject** () or **newObject** () functions, or constructor functions created by **newFunction** ().

    **Script Exceptions**

    **evaluate** () can throw a script exception (e.g. due to a syntax error); in that case, the return value is the value that was thrown (typically an `Error` object). You can check whether the evaluation caused an exception by calling **hasUncaughtException** (). In that case, you can call toString() on the error object to obtain an error message. The current uncaught exception is also available through **uncaughtException** (). Calling **clearExceptions** () will cause any uncaught exceptions to be cleared.

    **QScriptValue**  result = myEngine.evaluate(...);
        if (myEngine.hasUncaughtException()) {
            int line = myEngine.uncaughtExceptionLineNumber();
            **qDebug** () << "uncaught exception at line" << line << ":" << result.toString();
        }

    The **checkSyntax** () function can be used to determine whether code can be usefully passed to **evaluate** ().

    **Script Object Creation**

    Use **newObject** () to create a standard Qt Script object; this is the C++ equivalent of the script statement `new Object()`. You can use the object-specific functionality in **QScriptValue**  to manipulate the script object (e.g. **QScriptValue::setProperty** ()). Similarly, use **newArray** () to create a Qt Script array object. Use **newDate** () to create a `Date` object, and **newRegExp** () to create a `RegExp` object.

    **QObject Integration**

    Use **newQObject** () to wrap a **QObject**  (or subclass) pointer. **newQObject** () returns a proxy script object; properties, children, and signals and slots of the **QObject**  are available as properties of the proxy object. No binding code is needed because it is done dynamically using the Qt meta object system.

    **QPushButton**  button;
        **QScriptValue**  scriptButton = myEngine.newQObject(&button);
        myEngine.globalObject().setProperty("button", scriptButton);

        myEngine.evaluate("button.checkable = true");

        **qDebug** () << scriptButton.property("checkable").toBoolean();
        scriptButton.property("show").call(); // call the show() slot

    Use **qScriptConnect** () to connect a C++ signal to a script function; this is the Qt Script equivalent of **QObject::connect** (). When a script function is invoked in response to a C++ signal, it can cause a script exception; you can connect to the **signalHandlerException** () signal to catch such an exception.

    Use **newQMetaObject** () to wrap a **QMetaObject** ; this gives you a "script representation" of a **QObject** -based class. **newQMetaObject** () returns a proxy script object; enum values of the class are available as properties of the proxy object. You can also specify a function that will be used to construct objects of the class (e.g. when the constructor is invoked from a script). For classes that have a "standard" Qt constructor, Qt Script can provide a default script constructor for you; see **scriptValueFromQMetaObject** ().

    See **Making Applications Scriptable**  for more information on the **QObject**  integration.

    **Support for Custom C++ Types**

    Use **newVariant** () to wrap a **QVariant** . This can be used to store values of custom (non-**QObject** ) C++ types that have been registered with the Qt meta-type system. To make such types scriptable, you typically associate a prototype (delegate) object with the C++ type by calling **setDefaultPrototype** (); the prototype object defines the scripting API for the C++ type. Unlike the **QObject**  integration, there is no automatic binding possible here; i.e. you have to create the scripting API yourself, for example by using the **QScriptable**  class.

    Use **fromScriptValue** () to cast from a **QScriptValue**  to another type, and **toScriptValue** () to create a **QScriptValue**  from another value. You can specify how the conversion of C++ types is to be performed with **qScriptRegisterMetaType** () and **qScriptRegisterSequenceMetaType** (). By default, Qt Script will use **QVariant**  to store values of custom types.

    **Importing Extensions**

    Use **importExtension** () to import plugin-based extensions into the engine. Call **availableExtensions** () to obtain a list naming all the available extensions, and **importedExtensions** () to obtain a list naming only those extensions that have been imported.

    Call **pushContext** () to open up a new variable scope, and **popContext** () to close the current scope. This is useful if you are implementing an extension that evaluates script code containing temporary variable definitions (e.g. `var foo = 123;`) that are safe to discard when evaluation has completed.

    **Native Functions**

    Use **newFunction** () to wrap native (C++) functions, including constructors for your own custom types, so that these can be invoked from script code. Such functions must have the signature **QScriptEngine::FunctionSignature** . You may then pass the function as argument to **newFunction** (). Here is an example of a function that returns the sum of its first two arguments:

    **QScriptValue**  myAdd(**QScriptContext**  *context, **QScriptEngine**  *engine)
        {
           **QScriptValue**  a = context->argument(0);
           **QScriptValue**  b = context->argument(1);
           return a.toNumber() + b.toNumber();
        }

    To expose this function to script code, you can set it as a property of the Global Object:

    **QScriptValue**  fun = myEngine.newFunction(myAdd);
        myEngine.globalObject().setProperty("myAdd", fun);

    Once this is done, script code can call your function in the exact same manner as a "normal" script function:

    **QScriptValue**  result = myEngine.evaluate("myAdd(myNumber, 1)");

    **Long-running Scripts**

    If you need to evaluate possibly long-running scripts from the main (GUI) thread, you should first call **setProcessEventsInterval** () to make sure that the GUI stays responsive. You can abort a currently running script by calling **abortEvaluation** (). You can determine whether an engine is currently running a script by calling **isEvaluating** ().

    **Garbage Collection**

    Qt Script objects may be garbage collected when they are no longer referenced. There is no guarantee as to when automatic garbage collection will take place.

    The **collectGarbage** () function can be called to explicitly request garbage collection.

    The **reportAdditionalMemoryCost** () function can be called to indicate that a Qt Script object occupies memory that isn\'t managed by the scripting environment. Reporting the additional cost makes it more likely that the garbage collector will be triggered. This can be useful, for example, when many custom, native Qt Script objects are allocated.

    **Core Debugging/Tracing Facilities**

    Since Qt 4.4, you can be notified of events pertaining to script execution (e.g. script function calls and statement execution) through the **QScriptEngineAgent**  interface; see the **setAgent** () function. This can be used to implement debugging and profiling of a QScriptEngine.

    **See also** **QScriptValue** , **QScriptContext** , and **QScriptEngineAgent** .
    """

    QtOwnership: QScriptEngine = ...
    ExcludeChildObjects: QScriptEngine = ...
    ScriptOwnership: QScriptEngine = ...
    AutoOwnership: QScriptEngine = ...
    ExcludeSuperClassMethods: QScriptEngine = ...
    ExcludeSuperClassProperties: QScriptEngine = ...
    ExcludeSuperClassContents: QScriptEngine = ...
    SkipMethodsInEnumeration: QScriptEngine = ...
    ExcludeDeleteLater: QScriptEngine = ...
    ExcludeSlots: QScriptEngine = ...
    AutoCreateDynamicProperties: QScriptEngine = ...
    PreferExistingWrapperObject: QScriptEngine = ...

    class QObjectWrapOption(object):
        ExcludeChildObjects: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassMethods: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassProperties: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassContents: QScriptEngine.QObjectWrapOption = ...
        SkipMethodsInEnumeration: QScriptEngine.QObjectWrapOption = ...
        ExcludeDeleteLater: QScriptEngine.QObjectWrapOption = ...
        ExcludeSlots: QScriptEngine.QObjectWrapOption = ...
        AutoCreateDynamicProperties: QScriptEngine.QObjectWrapOption = ...
        PreferExistingWrapperObject: QScriptEngine.QObjectWrapOption = ...

    class QObjectWrapOptions(object):
        ...

    class ValueOwnership(object):
        QtOwnership: QScriptEngine.ValueOwnership = ...
        ScriptOwnership: QScriptEngine.ValueOwnership = ...
        AutoOwnership: QScriptEngine.ValueOwnership = ...

    @typing.overload
    def __init__(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#QScriptEngine

        **QScriptEngine::QScriptEngine()**

        Constructs a QScriptEngine object.

        The **globalObject** () is initialized to have properties as described in **ECMA-262** , Section 15.1.
        """
        ...

    @typing.overload
    def __init__(self, parent: PySide2.QtCore.QObject) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#QScriptEngine

        **QScriptEngine::QScriptEngine()**

        Constructs a QScriptEngine object.

        The **globalObject** () is initialized to have properties as described in **ECMA-262** , Section 15.1.
        """
        ...

    def abortEvaluation(self, result: PySide2.QtScript.QScriptValue = ...) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#abortEvaluation

        **void QScriptEngine::abortEvaluation(const QScriptValue & result = QScriptValue())**

        Aborts any script evaluation currently taking place in this engine. The given **result** is passed back as the result of the evaluation (i.e. it is returned from the call to **evaluate** () being aborted).

        If the engine isn't evaluating a script (i.e. **isEvaluating** () returns false), this function does nothing.

        Call this function if you need to abort a running script for some reason, e.g. when you have detected that the script has been running for several seconds without completing.

        This function was introduced in Qt 4.4.

        **See also** **evaluate** (), **isEvaluating** (), and **setProcessEventsInterval** ().
        """
        ...

    def agent(self) -> PySide2.QtScript.QScriptEngineAgent:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#agent

        **QScriptEngineAgent *QScriptEngine::agent() const**

        Returns the agent currently installed on this engine, or 0 if no agent is installed.

        This function was introduced in Qt 4.4.

        **See also** **setAgent** ().
        """
        ...

    def availableExtensions(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#availableExtensions

        **QStringList QScriptEngine::availableExtensions() const**

        Returns a list naming the available extensions that can be imported using the **importExtension** () function. This list includes extensions that have been imported.

        This function was introduced in Qt 4.4.

        **See also** **importExtension** () and **importedExtensions** ().
        """
        ...

    def canEvaluate(self, program: str) -> bool:
        ...

    def clearExceptions(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#clearExceptions

        **void QScriptEngine::clearExceptions()**

        Clears any uncaught exceptions in this engine.

        This function was introduced in Qt 4.4.

        **See also** **hasUncaughtException** ().
        """
        ...

    def collectGarbage(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#collectGarbage

        **void QScriptEngine::collectGarbage()**

        Runs the garbage collector.

        The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.

        Normally you don't need to call this function; the garbage collector will automatically be invoked when the **QScriptEngine**  decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.

        **See also** **reportAdditionalMemoryCost** ().
        """
        ...

    def currentContext(self) -> PySide2.QtScript.QScriptContext:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#currentContext

        **QScriptContext *QScriptEngine::currentContext() const**

        Returns the current context.

        The current context is typically accessed to retrieve the arguments and `this' object in native functions; for convenience, it is available as the first argument in **QScriptEngine::FunctionSignature** .
        """
        ...

    def defaultPrototype(self, metaTypeId: int) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#defaultPrototype

        **QScriptValue QScriptEngine::defaultPrototype(int metaTypeId ) const**

        Returns the default prototype associated with the given **metaTypeId** , or an invalid **QScriptValue**  if no default prototype has been set.

        **See also** **setDefaultPrototype** ().
        """
        ...

    @typing.overload
    def evaluate(
        self, program: PySide2.QtScript.QScriptProgram
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#evaluate

        **QScriptValue QScriptEngine::evaluate(const QString & program , const QString & fileName = QString(), int lineNumber = 1)**

        Evaluates **program** , using **lineNumber** as the base line number, and returns the result of the evaluation.

        The script code will be evaluated in the current context.

        The evaluation of **program** can cause an exception in the engine; in this case the return value will be the exception that was thrown (typically an `Error` object). You can call **hasUncaughtException** () to determine if an exception occurred in the last call to evaluate().

        **lineNumber** is used to specify a starting line number for **program** ; line number information reported by the engine that pertain to this evaluation (e.g. **uncaughtExceptionLineNumber** ()) will be based on this argument. For example, if **program** consists of two lines of code, and the statement on the second line causes a script exception, **uncaughtExceptionLineNumber** () would return the given **lineNumber** plus one. When no starting line number is specified, line numbers will be 1-based.

        **fileName** is used for error reporting. For example in error objects the file name is accessible through the "fileName" property if it\'s provided with this function.

        **See also** **canEvaluate** (), **hasUncaughtException** (), **isEvaluating** (), and **abortEvaluation** ().
        """
        ...

    @typing.overload
    def evaluate(
        self, program: str, fileName: str = ..., lineNumber: int = ...
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#evaluate

        **QScriptValue QScriptEngine::evaluate(const QString & program , const QString & fileName = QString(), int lineNumber = 1)**

        Evaluates **program** , using **lineNumber** as the base line number, and returns the result of the evaluation.

        The script code will be evaluated in the current context.

        The evaluation of **program** can cause an exception in the engine; in this case the return value will be the exception that was thrown (typically an `Error` object). You can call **hasUncaughtException** () to determine if an exception occurred in the last call to evaluate().

        **lineNumber** is used to specify a starting line number for **program** ; line number information reported by the engine that pertain to this evaluation (e.g. **uncaughtExceptionLineNumber** ()) will be based on this argument. For example, if **program** consists of two lines of code, and the statement on the second line causes a script exception, **uncaughtExceptionLineNumber** () would return the given **lineNumber** plus one. When no starting line number is specified, line numbers will be 1-based.

        **fileName** is used for error reporting. For example in error objects the file name is accessible through the "fileName" property if it\'s provided with this function.

        **See also** **canEvaluate** (), **hasUncaughtException** (), **isEvaluating** (), and **abortEvaluation** ().
        """
        ...

    def globalObject(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#globalObject

        **QScriptValue QScriptEngine::globalObject() const**

        Returns this engine's Global Object.

        By default, the Global Object contains the built-in objects that are part of **ECMA-262** , such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.

        **See also** **setGlobalObject** ().
        """
        ...

    def hasUncaughtException(self) -> bool:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#hasUncaughtException

        **bool QScriptEngine::hasUncaughtException() const**

        Returns true if the last script evaluation resulted in an uncaught exception; otherwise returns false.

        The exception state is cleared when **evaluate** () is called.

        **See also** **uncaughtException** () and **uncaughtExceptionLineNumber** ().
        """
        ...

    def importExtension(self, extension: str) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#importExtension

        **QScriptValue QScriptEngine::importExtension(const QString & extension )**

        Imports the given **extension** into this **QScriptEngine** . Returns **undefinedValue** () if the extension was successfully imported. You can call **hasUncaughtException** () to check if an error occurred; in that case, the return value is the value that was thrown by the exception (usually an `Error` object).

        **QScriptEngine**  ensures that a particular extension is only imported once; subsequent calls to importExtension() with the same extension name will do nothing and return **undefinedValue** ().

        **See also** **availableExtensions** (), **QScriptExtensionPlugin** , and **Creating Qt Script Extensions** .
        """
        ...

    def importedExtensions(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#importedExtensions

        **QStringList QScriptEngine::importedExtensions() const**

        Returns a list naming the extensions that have been imported using the **importExtension** () function.

        This function was introduced in Qt 4.4.

        **See also** **availableExtensions** ().
        """
        ...

    def installTranslatorFunctions(
        self, object: PySide2.QtScript.QScriptValue = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#installTranslatorFunctions

        **void QScriptEngine::installTranslatorFunctions(const QScriptValue & object = QScriptValue())**

        Installs translator functions on the given **object** , or on the Global Object if no object is specified.

        The relation between Qt Script translator functions and C++ translator functions is described in the following table:

        Script FunctionCorresponding C++ Function
        qsTr()**QObject::tr** ()
        **QT_TR_NOOP** ()**QT_TR_NOOP** ()
        qsTranslate()**QCoreApplication::translate** ()
        **QT_TRANSLATE_NOOP** ()**QT_TRANSLATE_NOOP** ()
        qsTrId() (since 4.7)**qtTrId** ()
        **QT_TRID_NOOP** () (since 4.7)**QT_TRID_NOOP** ()

        This function was introduced in Qt 4.5.

        **See also** **Internationalization with Qt** .
        """
        ...

    def isEvaluating(self) -> bool:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#isEvaluating

        **bool QScriptEngine::isEvaluating() const**

        Returns true if this engine is currently evaluating a script, otherwise returns false.

        This function was introduced in Qt 4.4.

        **See also** **evaluate** () and **abortEvaluation** ().
        """
        ...

    def newActivationObject(self) -> PySide2.QtScript.QScriptValue:
        ...

    def newArray(self, length: int = ...) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newArray

        **QScriptValue QScriptEngine::newArray(uint length = 0)**

        Creates a Qt Script object of class Array with the given **length**.

        **See also** **newObject** ().
        """
        ...

    @typing.overload
    def newDate(self, value: PySide2.QtCore.QDateTime) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newDate

        **QScriptValue QScriptEngine::newDate(qsreal value )**

        Creates a Qt Script object of class Date with the given **value** (the number of milliseconds since 01 January 1970, UTC).
        """
        ...

    @typing.overload
    def newDate(self, value: float) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newDate

        **QScriptValue QScriptEngine::newDate(qsreal value )**

        Creates a Qt Script object of class Date with the given **value** (the number of milliseconds since 01 January 1970, UTC).
        """
        ...

    @typing.overload
    def newObject(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newObject

        **QScriptValue QScriptEngine::newObject()**

        Creates a Qt Script object of class Object.

        The prototype of the created object will be the Object prototype object.

        **See also** **newArray** () and **QScriptValue::setProperty** ().
        """
        ...

    @typing.overload
    def newObject(
        self,
        scriptClass: PySide2.QtScript.QScriptClass,
        data: PySide2.QtScript.QScriptValue = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newObject

        **QScriptValue QScriptEngine::newObject()**

        Creates a Qt Script object of class Object.

        The prototype of the created object will be the Object prototype object.

        **See also** **newArray** () and **QScriptValue::setProperty** ().
        """
        ...

    def newQMetaObject(
        self,
        metaObject: PySide2.QtCore.QMetaObject,
        ctor: PySide2.QtScript.QScriptValue = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQMetaObject

        **QScriptValue QScriptEngine::newQMetaObject(const QMetaObject * metaObject , const QScriptValue & ctor = QScriptValue())**

        Creates a Qt Script object that represents a **QObject**  class, using the the given **metaObject** and constructor **ctor**.

        Enums of **metaObject** (declared with Q_ENUMS) are available as properties of the created **QScriptValue** . When the class is called as a function, **ctor** will be called to create a new instance of the class.

        Example:

        **QScriptValue**  mySpecialQObjectConstructor(**QScriptContext**  *context,
                                                     **QScriptEngine**  *engine)
            {
                **QObject**  *parent = context->argument(0).toQObject();
                **QObject**  *object = new **QObject** (parent);
                return engine->newQObject(object, **QScriptEngine** ::ScriptOwnership);
            }

            ...

            **QScriptValue**  ctor = engine.newFunction(mySpecialQObjectConstructor);
            **QScriptValue**  metaObject = engine.newQMetaObject(&**QObject** ::staticMetaObject, ctor);
            engine.globalObject().setProperty("QObject", metaObject);

            **QScriptValue**  result = engine.evaluate("new QObject()");

        **See also** **newQObject** () and **scriptValueFromQMetaObject** ().
        """
        ...

    @typing.overload
    def newQObject(
        self,
        object: PySide2.QtCore.QObject,
        ownership: PySide2.QtScript.QScriptEngine.ValueOwnership = ...,
        options: PySide2.QtScript.QScriptEngine.QObjectWrapOptions = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQObject

        **QScriptValue QScriptEngine::newQObject(QObject * object , QScriptEngine::ValueOwnership ownership = QtOwnership, const QScriptEngine::QObjectWrapOptions & options = QObjectWrapOptions())**

        Creates a Qt Script object that wraps the given **QObject**  **object** , using the given **ownership**. The given **options** control various aspects of the interaction with the resulting script object.

        Signals and slots, properties and children of **object** are available as properties of the created **QScriptValue** . For more information, see the **Qt Script**  documentation.

        If **object** is a null pointer, this function returns **nullValue** ().

        If a default prototype has been registered for the **object** 's class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.

        If the given **object** is deleted outside of Qt Script's control, any attempt to access the deleted **QObject** 's members through the Qt Script wrapper object (either by script code or C++) will result in a script exception.

        **See also** **QScriptValue::toQObject** () and **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newQObject(
        self,
        scriptObject: PySide2.QtScript.QScriptValue,
        qtObject: PySide2.QtCore.QObject,
        ownership: PySide2.QtScript.QScriptEngine.ValueOwnership = ...,
        options: PySide2.QtScript.QScriptEngine.QObjectWrapOptions = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQObject

        **QScriptValue QScriptEngine::newQObject(QObject * object , QScriptEngine::ValueOwnership ownership = QtOwnership, const QScriptEngine::QObjectWrapOptions & options = QObjectWrapOptions())**

        Creates a Qt Script object that wraps the given **QObject**  **object** , using the given **ownership**. The given **options** control various aspects of the interaction with the resulting script object.

        Signals and slots, properties and children of **object** are available as properties of the created **QScriptValue** . For more information, see the **Qt Script**  documentation.

        If **object** is a null pointer, this function returns **nullValue** ().

        If a default prototype has been registered for the **object** 's class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.

        If the given **object** is deleted outside of Qt Script's control, any attempt to access the deleted **QObject** 's members through the Qt Script wrapper object (either by script code or C++) will result in a script exception.

        **See also** **QScriptValue::toQObject** () and **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newRegExp(self, pattern: str, flags: str) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newRegExp

        **QScriptValue QScriptEngine::newRegExp(const QRegExp & regexp )**

        Creates a Qt Script object of class RegExp with the given **regexp**.

        **See also** **QScriptValue::toRegExp** ().
        """
        ...

    @typing.overload
    def newRegExp(
        self, regexp: PySide2.QtCore.QRegExp
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newRegExp

        **QScriptValue QScriptEngine::newRegExp(const QRegExp & regexp )**

        Creates a Qt Script object of class RegExp with the given **regexp**.

        **See also** **QScriptValue::toRegExp** ().
        """
        ...

    @typing.overload
    def newVariant(
        self, object: PySide2.QtScript.QScriptValue, value: typing.Any
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newVariant

        **QScriptValue QScriptEngine::newVariant(const QVariant & value )**

        Creates a Qt Script object holding the given variant **value**.

        If a default prototype has been registered with the meta type id of **value** , then the prototype of the created object will be that prototype; otherwise, the prototype will be the Object prototype object.

        **See also** **setDefaultPrototype** (), **QScriptValue::toVariant** (), and **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newVariant(self, value: typing.Any) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newVariant

        **QScriptValue QScriptEngine::newVariant(const QVariant & value )**

        Creates a Qt Script object holding the given variant **value**.

        If a default prototype has been registered with the meta type id of **value** , then the prototype of the created object will be that prototype; otherwise, the prototype will be the Object prototype object.

        **See also** **setDefaultPrototype** (), **QScriptValue::toVariant** (), and **reportAdditionalMemoryCost** ().
        """
        ...

    def nullValue(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#nullValue

        **QScriptValue QScriptEngine::nullValue()**

        Returns a **QScriptValue**  of the primitive type Null.

        **See also** **undefinedValue** ().
        """
        ...

    def objectById(self, id: int) -> PySide2.QtScript.QScriptValue:
        ...

    def popContext(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#popContext

        **void QScriptEngine::popContext()**

        Pops the current execution context and restores the previous one. This function must be used in conjunction with **pushContext** ().

        **See also** **pushContext** ().
        """
        ...

    def processEventsInterval(self) -> int:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#processEventsInterval

        **int QScriptEngine::processEventsInterval() const**

        Returns the interval in milliseconds between calls to **QCoreApplication::processEvents** () while the interpreter is running.

        **See also** **setProcessEventsInterval** ().
        """
        ...

    def pushContext(self) -> PySide2.QtScript.QScriptContext:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#pushContext

        **QScriptContext *QScriptEngine::pushContext()**

        Enters a new execution context and returns the associated **QScriptContext**  object.

        Once you are done with the context, you should call **popContext** () to restore the old context.

        By default, the `this\' object of the new context is the Global Object. The context\'s **callee** () will be invalid.

        This function is useful when you want to evaluate script code as if it were the body of a function. You can use the context\'s **activationObject** () to initialize local variables that will be available to scripts. Example:

        **QScriptEngine**  engine;
            **QScriptContext**  *context = engine.pushContext();
            context->activationObject().setProperty("myArg", 123);
            engine.evaluate("var tmp = myArg + 42");
            ...
            engine.popContext();

        In the above example, the new variable "tmp" defined in the script will be local to the context; in other words, the script doesn\'t have any effect on the global environment.

        Returns 0 in case of stack overflow

        **See also** **popContext** ().
        """
        ...

    def reportAdditionalMemoryCost(self, size: int) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#reportAdditionalMemoryCost

        **void QScriptEngine::reportAdditionalMemoryCost(int size )**

        Reports an additional memory cost of the given **size** , measured in bytes, to the garbage collector.

        This function can be called to indicate that a Qt Script object has memory associated with it that isn't managed by Qt Script itself. Reporting the additional cost makes it more likely that the garbage collector will be triggered.

        Note that if the additional memory is shared with objects outside the scripting environment, the cost should not be reported, since collecting the Qt Script object would not cause the memory to be freed anyway.

        Negative **size** values are ignored, i.e. this function can't be used to report that the additional memory has been deallocated.

        This function was introduced in Qt 4.7.

        **See also** **collectGarbage** ().
        """
        ...

    def setAgent(self, agent: PySide2.QtScript.QScriptEngineAgent) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setAgent

        **void QScriptEngine::setAgent(QScriptEngineAgent * agent )**

        Installs the given **agent** on this engine. The agent will be notified of various events pertaining to script execution. This is useful when you want to find out exactly what the engine is doing, e.g. when **evaluate** () is called. The agent interface is the basis of tools like debuggers and profilers.

        The engine maintains ownership of the **agent**.

        Calling this function will replace the existing agent, if any.

        This function was introduced in Qt 4.4.

        **See also** **agent** ().
        """
        ...

    def setDefaultPrototype(
        self, metaTypeId: int, prototype: PySide2.QtScript.QScriptValue
    ) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setDefaultPrototype

        **void QScriptEngine::setDefaultPrototype(int metaTypeId , const QScriptValue & prototype )**

        Sets the default prototype of the C++ type identified by the given **metaTypeId** to **prototype**.

        The default prototype provides a script interface for values of type **metaTypeId** when a value of that type is accessed from script code. Whenever the script engine (implicitly or explicitly) creates a **QScriptValue**  from a value of type **metaTypeId** , the default prototype will be set as the **QScriptValue** 's prototype.

        The **prototype** object itself may be constructed using one of two principal techniques; the simplest is to subclass **QScriptable** , which enables you to define the scripting API of the type through **QObject**  properties and slots. Another possibility is to create a script object by calling **newObject** (), and populate the object with the desired properties (e.g. native functions wrapped with **newFunction** ()).

        **See also** **defaultPrototype** (), **qScriptRegisterMetaType** (), **QScriptable** , and **Default Prototypes Example** .
        """
        ...

    def setGlobalObject(self, object: PySide2.QtScript.QScriptValue) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setGlobalObject

        **void QScriptEngine::setGlobalObject(const QScriptValue & object )**

        Sets this engine's Global Object to be the given **object**. If **object** is not a valid script object, this function does nothing.

        When setting a custom global object, you may want to use **QScriptValueIterator**  to copy the properties of the standard Global Object; alternatively, you can set the internal prototype of your custom object to be the original Global Object.

        This function was introduced in Qt 4.5.

        **See also** **globalObject** ().
        """
        ...

    def setProcessEventsInterval(self, interval: int) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setProcessEventsInterval

        **void QScriptEngine::setProcessEventsInterval(int interval )**

        Sets the interval between calls to **QCoreApplication::processEvents**  to **interval** milliseconds.

        While the interpreter is running, all event processing is by default blocked. This means for instance that the gui will not be updated and timers will not be fired. To allow event processing during interpreter execution one can specify the processing interval to be a positive value, indicating the number of milliseconds between each time **QCoreApplication::processEvents** () is called.

        The default value is -1, which disables event processing during interpreter execution.

        You can use **QCoreApplication::postEvent** () to post an event that performs custom processing at the next interval. For example, you could keep track of the total running time of the script and call **abortEvaluation** () when you detect that the script has been running for a long time without completing.

        **See also** **processEventsInterval** ().
        """
        ...

    def toObject(
        self, value: PySide2.QtScript.QScriptValue
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#toObject

        **QScriptValue QScriptEngine::toObject(const QScriptValue & value )**

        Converts the given **value** to an object, if such a conversion is possible; otherwise returns an invalid **QScriptValue** . The conversion is performed according to the following table:

        Input TypeResult
        UndefinedAn invalid **QScriptValue** .
        NullAn invalid **QScriptValue** .
        BooleanA new Boolean object whose internal value is set to the value of the boolean.
        NumberA new Number object whose internal value is set to the value of the number.
        StringA new String object whose internal value is set to the value of the string.
        ObjectThe result is the object itself (no conversion).

        This function was introduced in Qt 4.5.

        **See also** **newObject** ().
        """
        ...

    def toStringHandle(self, str: str) -> PySide2.QtScript.QScriptString:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#toStringHandle

        **QScriptString QScriptEngine::toStringHandle(const QString & str )**

        Returns a handle that represents the given string, **str**.

        **QScriptString**  can be used to quickly look up properties, and compare property names, of script objects.

        This function was introduced in Qt 4.4.

        **See also** **QScriptValue::property** ().
        """
        ...

    def uncaughtException(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtException

        **QScriptValue QScriptEngine::uncaughtException() const**

        Returns the current uncaught exception, or an invalid **QScriptValue**  if there is no uncaught exception.

        The exception value is typically an `Error` object; in that case, you can call toString() on the return value to obtain an error message.

        **See also** **hasUncaughtException** () and **uncaughtExceptionLineNumber** ().
        """
        ...

    def uncaughtExceptionBacktrace(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtExceptionBacktrace

        **QStringList QScriptEngine::uncaughtExceptionBacktrace() const**

        Returns a human-readable backtrace of the last uncaught exception.

        It is in the form `<function-name>() at <file-name>:<line-number>`.

        **See also** **uncaughtException** ().
        """
        ...

    def uncaughtExceptionLineNumber(self) -> int:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtExceptionLineNumber

        **int QScriptEngine::uncaughtExceptionLineNumber() const**

        Returns the line number where the last uncaught exception occurred.

        Line numbers are 1-based, unless a different base was specified as the second argument to **evaluate** ().

        **See also** **hasUncaughtException** ().
        """
        ...

    def undefinedValue(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#undefinedValue

        **QScriptValue QScriptEngine::undefinedValue()**

        Returns a **QScriptValue**  of the primitive type Undefined.

        **See also** **nullValue** ().
        """
        ...

    @property
    def signalHandlerException(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#signalHandlerException

        **[signal] void QScriptEngine::signalHandlerException(const QScriptValue & exception )**

        This signal is emitted when a script function connected to a signal causes an **exception**.

        This function was introduced in Qt 4.4.

        **See also** **qScriptConnect** ().
        """
        ...
