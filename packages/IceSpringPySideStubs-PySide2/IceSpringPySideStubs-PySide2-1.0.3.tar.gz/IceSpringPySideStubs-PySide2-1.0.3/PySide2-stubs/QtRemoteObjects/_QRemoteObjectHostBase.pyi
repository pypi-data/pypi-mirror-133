"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtRemoteObjects

bytes = str


class QRemoteObjectHostBase(PySide2.QtRemoteObjects.QRemoteObjectNode):
    """
    https://doc.qt.io/qt-5/qremoteobjecthostbase.html

    **Detailed Description**

    QRemoteObjectHostBase is a base class that cannot be instantiated directly. It provides the **enableRemoting**  and **disableRemoting**  functionality shared by all host nodes (**Host**  and **RegistryHost** ) as well as the logic required to expose **Source**  objects on the Remote Objects network.
    """

    BuiltInSchemasOnly: QRemoteObjectHostBase = ...
    AllowExternalRegistration: QRemoteObjectHostBase = ...

    class AllowedSchemas(object):
        BuiltInSchemasOnly: QRemoteObjectHostBase.AllowedSchemas = ...
        AllowExternalRegistration: QRemoteObjectHostBase.AllowedSchemas = ...

    def addHostSideConnection(self, ioDevice: PySide2.QtCore.QIODevice) -> None:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#addHostSideConnection

        **void QRemoteObjectHostBase::addHostSideConnection(QIODevice * ioDevice )**

        In order to **QRemoteObjectHost::enableRemoting** () **Source**  objects over **External QIODevices** , Qt Remote Objects needs access to the communications channel (a **QIODevice** ) between the respective nodes. It is the addHostSideConnection() call that enables this on the **Source**  side, taking the **ioDevice** as input. Any **enableRemoting** () call will still work without calling addHostSideConnection, but the Node will not be able to share the **Source**  objects without being provided the connection to the Replica node. Before calling this function you must call **setHostUrl** () with a unique URL and **AllowExternalRegistration** .

        This function was introduced in Qt 5.12.

        **See also** **addClientSideConnection** .
        """
        ...

    def disableRemoting(self, remoteObject: PySide2.QtCore.QObject) -> bool:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#disableRemoting

        **bool QRemoteObjectHostBase::disableRemoting(QObject * remoteObject )**

        Disables remote access for the **QObject**  **remoteObject**. Returns `false` if the current node is a client node or if the **remoteObject** is not registered, and returns `true` if remoting is successfully disabled for the Source object.

        **Warning:** Replicas of this object will no longer be valid after calling this method.

        **Note:** This function can be invoked via the meta-object system and from QML. See **Q_INVOKABLE** .

        **See also** **enableRemoting** ().
        """
        ...

    @typing.overload
    def enableRemoting(
        self,
        model: PySide2.QtCore.QAbstractItemModel,
        name: str,
        roles: typing.List,
        selectionModel: typing.Optional[PySide2.QtCore.QItemSelectionModel] = ...,
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#enableRemoting

        **template <template <typename> class ApiDefinition, typename ObjectType> bool QRemoteObjectHostBase::enableRemoting(ObjectType * object )**

        This templated function overload enables a host node to provide remote access to a **QObject**  **object** with a specified (and compile-time checked) interface. Client nodes connected to the node hosting this object may obtain Replicas of this Source.

        This is best illustrated by example:

        #include "rep_TimeModel_source.h"
            MinuteTimer timer;
            hostNode.enableRemoting<MinuteTimerSourceAPI>(&timer);

        Here the MinuteTimerSourceAPI is the set of Signals/Slots/Properties defined by the TimeModel.rep file. Compile time checks are made to verify the input **QObject**  can expose the requested API, it will fail to compile otherwise. This allows a subset of **object** \'s interface to be exposed, and allows the types of conversions supported by Signal/Slot connections.

        Returns `false` if the current node is a client node, or if the **QObject**  is already registered to be remoted, and `true` if remoting is successfully enabled for the **QObject** .

        **See also** **disableRemoting** ().
        """
        ...

    @typing.overload
    def enableRemoting(self, object: PySide2.QtCore.QObject, name: str = ...) -> bool:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#enableRemoting

        **template <template <typename> class ApiDefinition, typename ObjectType> bool QRemoteObjectHostBase::enableRemoting(ObjectType * object )**

        This templated function overload enables a host node to provide remote access to a **QObject**  **object** with a specified (and compile-time checked) interface. Client nodes connected to the node hosting this object may obtain Replicas of this Source.

        This is best illustrated by example:

        #include "rep_TimeModel_source.h"
            MinuteTimer timer;
            hostNode.enableRemoting<MinuteTimerSourceAPI>(&timer);

        Here the MinuteTimerSourceAPI is the set of Signals/Slots/Properties defined by the TimeModel.rep file. Compile time checks are made to verify the input **QObject**  can expose the requested API, it will fail to compile otherwise. This allows a subset of **object** \'s interface to be exposed, and allows the types of conversions supported by Signal/Slot connections.

        Returns `false` if the current node is a client node, or if the **QObject**  is already registered to be remoted, and `true` if remoting is successfully enabled for the **QObject** .

        **See also** **disableRemoting** ().
        """
        ...

    def hostUrl(self) -> PySide2.QtCore.QUrl:
        ...

    def proxy(
        self, registryUrl: PySide2.QtCore.QUrl, hostUrl: PySide2.QtCore.QUrl = ...
    ) -> bool:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#proxy

        **bool QRemoteObjectHostBase::proxy(const QUrl & registryUrl , const QUrl & hostUrl = {}, QRemoteObjectHostBase::RemoteObjectNameFilter filter = [](const QString &, const QString &) {return true; })**

        Forward Remote Objects from another network

        The proxy functionality is useful when you want to share **Source**  objects over multiple networks. For instance, if you have an embedded target using target-only connections (like local) and you want to make some of those same objects available externally.

        As a concrete example, say you have a set of processes talking to each other on your target hardware using a registry, with the **Registry**  at "local:registry" and separate processes using a node at "local:MyHost" that holds **Source**  objects. If you wanted to access these objects, but over tcp, you could create a new proxyNode like so:

        // myInternalHost is a node only visible on the device...
            **QRemoteObjectHost**  myInternalHost("local:MyHost");
            myInternalHost.enableRemoting<SomeObject>(&someObject);

            // Regular host node, listening on port 12123, so visible to other
            // devices
            **QRemoteObjectHost**  proxyNode("tcp://localhost:12123");

            // Enable proxying objects from nodes on the local machine\'s internal
            // QtRO bus
            proxyNode.proxy("local:registry");

        And from another device you create another node:

        // NB: localhost resolves to a different ip address than proxyNode
            **QRemoteObjectHost**  nodeOnRemoteDevice("tcp://localhost:23234");

            // Connect to the target\'s proxyNode directly, or use a tcp registry...
            nodeOnRemoteDevice.connectToNode("tcp://<target device>:12123");

            // Because of the proxy, we can get the object over tcp/ip port 12123,
            // even though we can\'t connect directly to "local:MyHost"
            SomeObject *so = nodeOnRemoteDevice.acquire<SomeObject>();

        This would (internally) create a node in proxyNode, which (again internally/automatically) connects to the provided registry (given by the **registryUrl** parameter, "local:registry" in this example). Whenever local:registry emits the **remoteObjectAdded**  signal, the `QRemoteObjectSourceLocation` is passed to the **filter** given to the proxy call. If this method returns true (the default filter simply returns true without any filtering), the object is acquired() from the internal node and **enableRemoting** () (once the replica is initialized) is called on proxyNode.

        If a **hostUrl** is provided (which is required to enable **reverseProxy** , but not needed otherwise), the internal node will be a **QRemoteObjectHost**  node configured with the provided address. If no **hostUrl** is provided, the internal node will be a **QRemoteObjectNode**  (not HostNode).

        Returns `true` if the object is acquired from the internal node.

        This function was introduced in Qt 5.11.

        **See also** **reverseProxy** ().
        """
        ...

    def reverseProxy(self) -> bool:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#reverseProxy

        **bool QRemoteObjectHostBase::reverseProxy(QRemoteObjectHostBase::RemoteObjectNameFilter filter = [](const QString &, const QString &) {return true; })**

        Forwards remote objects to another network.

        The reverseProxy() function allows the **proxy** () functionality to be extended, in effect mirroring the proxy functionality in the "reverse" direction. These are distinct, because node communication is not symmetric, one side calls **enableRemoting** () with a **Source**  object, the other side calls **acquire** () to get a **Replica** . Using **proxy** () allows you to "observe" objects on a target device remotely via acquire, but it does not allow off-target **Source**  objects to be acquired from the device\'s local:* network. That is where reverseProxy() comes in. If a proxyNode is created like so:

        // myInternalHost is a node only visible on the device...
            **QRemoteObjectHost**  myInternalHost("local:MyHost");

            // RegistryHost node, listening on port 12123, so visible to other
            // devices.  The node must be a RegistryHost, so the Sources on
            // the "outside" network can be forwarded to the inner network.
            **QRemoteObjectRegistryHost**  proxyNode("tcp://localhost:12123");

            // Enable proxying objects from nodes on the local machine\'s internal
            // QtRO bus.  Note the hostUrl parameter is now needed.
            proxyNode.proxy("local:registry", "local:fromProxy");
            proxyNode.reverseProxy();

        And from another device you create another node:

        // NB: localhost resolves to a different ip address than proxyNode
            **QRemoteObjectHost**  nodeOnRemoteDevice("tcp://localhost:23234");

            // Connect to the target\'s proxyNode directly, or use a tcp registry...
            nodeOnRemoteDevice.connectToNode("tcp://<target device>:12123");

            // Because of the reverseProxy, we can expose objects on this device
            // and they will make their way to proxyNode...
            nodeOnRemoteDevice.enableRemoting<OtherObject>(&otherObject);

        // Acquire() can now see the objects on other devices through proxyNode,
            // due to the reverseProxy call.
            OtherObject *oo = myInternalHost.acquire<OtherObject>();

        While the **proxy** () functionality allows **Source**  objects on another network to be acquired(), reverseProxy() allows **Source**  objects to be "pushed" to an otherwise inaccessible network.

        **Note:****proxy** () needs to be called before reverseProxy(), and a hostUrl needs to be provided to **proxy**  for reverseProxy() to work. The reverseProxy() method allows a separate **filter** to be applied. This reverseProxy specific filter will receive notifications of new **Source**  objects on proxyNode and acquire them on the internal node if they pass the reverseFilter.

        Returns `true` on success, `false` otherwise.

        This function was introduced in Qt 5.11.

        **See also** **proxy** ().
        """
        ...

    def setHostUrl(
        self,
        hostAddress: PySide2.QtCore.QUrl,
        allowedSchemas: PySide2.QtRemoteObjects.QRemoteObjectHostBase.AllowedSchemas = ...,
    ) -> bool:
        ...

    def setName(self, name: str) -> None:
        """
        https://doc.qt.io/qt-5/qremoteobjecthostbase.html#setName

        **[override virtual] void QRemoteObjectHostBase::setName(const QString & name )**

        Reimplements: **QRemoteObjectNode::setName** (const QString &name).

        Similar to **QObject::setObjectName** () (which this method calls), but this version also applies the **name** to internal classes as well, which are used in some of the debugging output.
        """
        ...
