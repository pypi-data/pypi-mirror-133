"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore
import PySide2.QtGui
import PySide2.QtNetwork
import PySide2.QtMultimediaWidgets
import PySide2.QtMultimedia

bytes = str


class QVideoFrame(object):
    """
    **Detailed Description**

    A QVideoFrame encapsulates the pixel data of a video frame, and information about the frame.

    Video frames can come from several places - decoded **media** , a **camera** , or generated programmatically. The way pixels are described in these frames can vary greatly, and some pixel formats offer greater compression opportunities at the expense of ease of use.

    The pixel contents of a video frame can be mapped to memory using the **map** () function. While mapped, the video data can accessed using the **bits** () function, which returns a pointer to a buffer. The total size of this buffer is given by the **mappedBytes** () function, and the size of each line is given by **bytesPerLine** (). The return value of the **handle** () function may also be used to access frame data using the internal buffer's native APIs (for example - an OpenGL texture handle).

    A video frame can also have timestamp information associated with it. These timestamps can be used by an implementation of **QAbstractVideoSurface**  to determine when to start and stop displaying the frame, but not all surfaces might respect this setting.

    The video pixel data in a QVideoFrame is encapsulated in a **QAbstractVideoBuffer** . A QVideoFrame may be constructed from any buffer type by subclassing the **QAbstractVideoBuffer**  class.

    **Note:** Since video frames can be expensive to copy, QVideoFrame is explicitly shared, so any change made to a video frame will also apply to any copies.
    """

    Format_Invalid: QVideoFrame = ...
    ProgressiveFrame: QVideoFrame = ...
    Format_ARGB32: QVideoFrame = ...
    TopField: QVideoFrame = ...
    BottomField: QVideoFrame = ...
    Format_ARGB32_Premultiplied: QVideoFrame = ...
    Format_RGB32: QVideoFrame = ...
    InterlacedFrame: QVideoFrame = ...
    Format_RGB24: QVideoFrame = ...
    Format_RGB565: QVideoFrame = ...
    Format_RGB555: QVideoFrame = ...
    Format_ARGB8565_Premultiplied: QVideoFrame = ...
    Format_BGRA32: QVideoFrame = ...
    Format_BGRA32_Premultiplied: QVideoFrame = ...
    Format_BGR32: QVideoFrame = ...
    Format_BGR24: QVideoFrame = ...
    Format_BGR565: QVideoFrame = ...
    Format_BGR555: QVideoFrame = ...
    Format_BGRA5658_Premultiplied: QVideoFrame = ...
    Format_AYUV444: QVideoFrame = ...
    Format_AYUV444_Premultiplied: QVideoFrame = ...
    Format_YUV444: QVideoFrame = ...
    Format_YUV420P: QVideoFrame = ...
    Format_YV12: QVideoFrame = ...
    Format_UYVY: QVideoFrame = ...
    Format_YUYV: QVideoFrame = ...
    Format_NV12: QVideoFrame = ...
    Format_NV21: QVideoFrame = ...
    Format_IMC1: QVideoFrame = ...
    Format_IMC2: QVideoFrame = ...
    Format_IMC3: QVideoFrame = ...
    Format_IMC4: QVideoFrame = ...
    Format_Y8: QVideoFrame = ...
    Format_Y16: QVideoFrame = ...
    Format_Jpeg: QVideoFrame = ...
    Format_CameraRaw: QVideoFrame = ...
    Format_AdobeDng: QVideoFrame = ...
    Format_ABGR32: QVideoFrame = ...
    Format_YUV422P: QVideoFrame = ...
    NPixelFormats: QVideoFrame = ...
    Format_User: QVideoFrame = ...

    class FieldType(object):
        ProgressiveFrame: QVideoFrame.FieldType = ...
        TopField: QVideoFrame.FieldType = ...
        BottomField: QVideoFrame.FieldType = ...
        InterlacedFrame: QVideoFrame.FieldType = ...

    class PixelFormat(object):
        Format_Invalid: QVideoFrame.PixelFormat = ...
        Format_ARGB32: QVideoFrame.PixelFormat = ...
        Format_ARGB32_Premultiplied: QVideoFrame.PixelFormat = ...
        Format_RGB32: QVideoFrame.PixelFormat = ...
        Format_RGB24: QVideoFrame.PixelFormat = ...
        Format_RGB565: QVideoFrame.PixelFormat = ...
        Format_RGB555: QVideoFrame.PixelFormat = ...
        Format_ARGB8565_Premultiplied: QVideoFrame.PixelFormat = ...
        Format_BGRA32: QVideoFrame.PixelFormat = ...
        Format_BGRA32_Premultiplied: QVideoFrame.PixelFormat = ...
        Format_BGR32: QVideoFrame.PixelFormat = ...
        Format_BGR24: QVideoFrame.PixelFormat = ...
        Format_BGR565: QVideoFrame.PixelFormat = ...
        Format_BGR555: QVideoFrame.PixelFormat = ...
        Format_BGRA5658_Premultiplied: QVideoFrame.PixelFormat = ...
        Format_AYUV444: QVideoFrame.PixelFormat = ...
        Format_AYUV444_Premultiplied: QVideoFrame.PixelFormat = ...
        Format_YUV444: QVideoFrame.PixelFormat = ...
        Format_YUV420P: QVideoFrame.PixelFormat = ...
        Format_YV12: QVideoFrame.PixelFormat = ...
        Format_UYVY: QVideoFrame.PixelFormat = ...
        Format_YUYV: QVideoFrame.PixelFormat = ...
        Format_NV12: QVideoFrame.PixelFormat = ...
        Format_NV21: QVideoFrame.PixelFormat = ...
        Format_IMC1: QVideoFrame.PixelFormat = ...
        Format_IMC2: QVideoFrame.PixelFormat = ...
        Format_IMC3: QVideoFrame.PixelFormat = ...
        Format_IMC4: QVideoFrame.PixelFormat = ...
        Format_Y8: QVideoFrame.PixelFormat = ...
        Format_Y16: QVideoFrame.PixelFormat = ...
        Format_Jpeg: QVideoFrame.PixelFormat = ...
        Format_CameraRaw: QVideoFrame.PixelFormat = ...
        Format_AdobeDng: QVideoFrame.PixelFormat = ...
        Format_ABGR32: QVideoFrame.PixelFormat = ...
        Format_YUV422P: QVideoFrame.PixelFormat = ...
        NPixelFormats: QVideoFrame.PixelFormat = ...
        Format_User: QVideoFrame.PixelFormat = ...

    @typing.overload
    def __init__(self) -> None:
        """
        **QVideoFrame::QVideoFrame()**

        Constructs a null video frame.
        """
        ...

    @typing.overload
    def __init__(
        self,
        buffer: PySide2.QtMultimedia.QAbstractVideoBuffer,
        size: PySide2.QtCore.QSize,
        format: PySide2.QtMultimedia.QVideoFrame.PixelFormat,
    ) -> None:
        """
        **QVideoFrame::QVideoFrame()**

        Constructs a null video frame.
        """
        ...

    @typing.overload
    def __init__(
        self,
        bytes: int,
        size: PySide2.QtCore.QSize,
        bytesPerLine: int,
        format: PySide2.QtMultimedia.QVideoFrame.PixelFormat,
    ) -> None:
        """
        **QVideoFrame::QVideoFrame()**

        Constructs a null video frame.
        """
        ...

    @typing.overload
    def __init__(self, image: PySide2.QtGui.QImage) -> None:
        """
        **QVideoFrame::QVideoFrame()**

        Constructs a null video frame.
        """
        ...

    @typing.overload
    def __init__(self, other: PySide2.QtMultimedia.QVideoFrame) -> None:
        """
        **QVideoFrame::QVideoFrame()**

        Constructs a null video frame.
        """
        ...

    @staticmethod
    def __copy__() -> None:
        ...

    def availableMetaData(self) -> typing.Dict:
        """
        **QVariantMap QVideoFrame::availableMetaData() const**

        Returns any extra metadata associated with this frame.
        """
        ...

    def bits(self) -> bytes:
        """
        **uchar *QVideoFrame::bits()**

        Returns a pointer to the start of the frame data buffer.

        This value is only valid while the frame data is **mapped** .

        Changes made to data accessed via this pointer (when mapped with write access) are only guaranteed to have been persisted when **unmap** () is called and when the buffer has been mapped for writing.

        **See also** **map** (), **mappedBytes** (), and **bytesPerLine** ().
        """
        ...

    def buffer(self) -> PySide2.QtMultimedia.QAbstractVideoBuffer:
        """
        **QAbstractVideoBuffer *QVideoFrame::buffer() const**

        Returns underlying video buffer or `null` if there is none.

        This function was introduced in Qt 5.13.
        """
        ...

    @typing.overload
    def bytesPerLine(self) -> int:
        """
        **int QVideoFrame::bytesPerLine() const**

        Returns the number of bytes in a scan line.

        **Note:** For planar formats this is the bytes per line of the first plane only. The bytes per line of subsequent planes should be calculated as per the frame **pixel format** .

        This value is only valid while the frame data is **mapped** .

        **See also** **bits** (), **map** (), and **mappedBytes** ().
        """
        ...

    @typing.overload
    def bytesPerLine(self, plane: int) -> int:
        """
        **int QVideoFrame::bytesPerLine() const**

        Returns the number of bytes in a scan line.

        **Note:** For planar formats this is the bytes per line of the first plane only. The bytes per line of subsequent planes should be calculated as per the frame **pixel format** .

        This value is only valid while the frame data is **mapped** .

        **See also** **bits** (), **map** (), and **mappedBytes** ().
        """
        ...

    def endTime(self) -> int:
        """
        **qint64 QVideoFrame::endTime() const**

        Returns the presentation time (in microseconds) when a frame should stop being displayed.

        An invalid time is represented as -1.

        **See also** **setEndTime** ().
        """
        ...

    def fieldType(self) -> PySide2.QtMultimedia.QVideoFrame.FieldType:
        """
        **QVideoFrame::FieldType QVideoFrame::fieldType() const**

        Returns the field an interlaced video frame belongs to.

        If the video is not interlaced this will return WholeFrame.

        **See also** **setFieldType** ().
        """
        ...

    def handle(self) -> typing.Any:
        """
        **QVariant QVideoFrame::handle() const**

        Returns a type specific handle to a video frame's buffer.

        For an OpenGL texture this would be the texture ID.

        **See also** **QAbstractVideoBuffer::handle** ().
        """
        ...

    def handleType(self) -> PySide2.QtMultimedia.QAbstractVideoBuffer.HandleType:
        """
        **QAbstractVideoBuffer::HandleType QVideoFrame::handleType() const**

        Returns the type of a video frame's handle.
        """
        ...

    def height(self) -> int:
        """
        **int QVideoFrame::height() const**

        Returns the height of a video frame.
        """
        ...

    def image(self) -> PySide2.QtGui.QImage:
        """
        **QImage QVideoFrame::image() const**

        Based on the pixel format converts current video frame to image.

        This function was introduced in Qt 5.15.
        """
        ...

    @staticmethod
    def imageFormatFromPixelFormat(
        format: PySide2.QtMultimedia.QVideoFrame.PixelFormat,
    ) -> PySide2.QtGui.QImage.Format:
        """
        **[static] QImage::Format QVideoFrame::imageFormatFromPixelFormat(QVideoFrame::PixelFormat format )**

        Returns an image format equivalent to a video frame pixel **format**. If there is no equivalent format **QImage::Format_Invalid**  is returned instead.

        **Note:** In general **QImage**  does not handle YUV formats.
        """
        ...

    def isMapped(self) -> bool:
        """
        **bool QVideoFrame::isMapped() const**

        Identifies if a video frame's contents are currently mapped to system memory.

        This is a convenience function which checks that the **MapMode**  of the frame is not equal to **QAbstractVideoBuffer::NotMapped** .

        Returns true if the contents of the video frame are mapped to system memory, and false otherwise.

        **See also** **mapMode** () and **QAbstractVideoBuffer::MapMode** .
        """
        ...

    def isReadable(self) -> bool:
        """
        **bool QVideoFrame::isReadable() const**

        Identifies if the mapped contents of a video frame were read from the frame when it was mapped.

        This is a convenience function which checks if the **MapMode**  contains the **QAbstractVideoBuffer::WriteOnly**  flag.

        Returns true if the contents of the mapped memory were read from the video frame, and false otherwise.

        **See also** **mapMode** () and **QAbstractVideoBuffer::MapMode** .
        """
        ...

    def isValid(self) -> bool:
        """
        **bool QVideoFrame::isValid() const**

        Identifies whether a video frame is valid.

        An invalid frame has no video buffer associated with it.

        Returns true if the frame is valid, and false if it is not.
        """
        ...

    def isWritable(self) -> bool:
        """
        **bool QVideoFrame::isWritable() const**

        Identifies if the mapped contents of a video frame will be persisted when the frame is unmapped.

        This is a convenience function which checks if the **MapMode**  contains the **QAbstractVideoBuffer::WriteOnly**  flag.

        Returns true if the video frame will be updated when unmapped, and false otherwise.

        **Note:** The result of altering the data of a frame that is mapped in read-only mode is undefined. Depending on the buffer implementation the changes may be persisted, or worse alter a shared buffer.

        **See also** **mapMode** () and **QAbstractVideoBuffer::MapMode** .
        """
        ...

    def map(self, mode: PySide2.QtMultimedia.QAbstractVideoBuffer.MapMode) -> bool:
        """
        **bool QVideoFrame::map(QAbstractVideoBuffer::MapMode mode )**

        Maps the contents of a video frame to system (CPU addressable) memory.

        In some cases the video frame data might be stored in video memory or otherwise inaccessible memory, so it is necessary to map a frame before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.

        The map **mode** indicates whether the contents of the mapped memory should be read from and/or written to the frame. If the map mode includes the `QAbstractVideoBuffer::ReadOnly` flag the mapped memory will be populated with the content of the video frame when initially mapped. If the map mode includes the `QAbstractVideoBuffer::WriteOnly` flag the content of the possibly modified mapped memory will be written back to the frame when unmapped.

        While mapped the contents of a video frame can be accessed directly through the pointer returned by the **bits** () function.

        When access to the data is no longer needed, be sure to call the **unmap** () function to release the mapped memory and possibly update the video frame contents.

        If the video frame has been mapped in read only mode, it is permissible to map it multiple times in read only mode (and unmap it a corresponding number of times). In all other cases it is necessary to unmap the frame first before mapping a second time.

        **Note:** Writing to memory that is mapped as read-only is undefined, and may result in changes to shared data or crashes.

        Returns true if the frame was mapped to memory in the given **mode** and false otherwise.

        **See also** **unmap** (), **mapMode** (), and **bits** ().
        """
        ...

    def mapMode(self) -> PySide2.QtMultimedia.QAbstractVideoBuffer.MapMode:
        """
        **QAbstractVideoBuffer::MapMode QVideoFrame::mapMode() const**

        Returns the mode a video frame was mapped to system memory in.

        **See also** **map** () and **QAbstractVideoBuffer::MapMode** .
        """
        ...

    def mappedBytes(self) -> int:
        """
        **int QVideoFrame::mappedBytes() const**

        Returns the number of bytes occupied by the mapped frame data.

        This value is only valid while the frame data is **mapped** .

        **See also** **map** ().
        """
        ...

    def metaData(self, key: str) -> typing.Any:
        """
        **QVariant QVideoFrame::metaData(const QString & key ) const**

        Returns any metadata for this frame for the given **key**.

        This might include frame specific information from a camera, or subtitles from a decoded video stream.

        See the documentation for the relevant video frame producer for further information about available metadata.

        **See also** **setMetaData** ().
        """
        ...

    def pixelFormat(self) -> PySide2.QtMultimedia.QVideoFrame.PixelFormat:
        """
        **QVideoFrame::PixelFormat QVideoFrame::pixelFormat() const**

        Returns the color format of a video frame.
        """
        ...

    @staticmethod
    def pixelFormatFromImageFormat(
        format: PySide2.QtGui.QImage.Format,
    ) -> PySide2.QtMultimedia.QVideoFrame.PixelFormat:
        """
        **[static] QVideoFrame::PixelFormat QVideoFrame::pixelFormatFromImageFormat(QImage::Format format )**

        Returns a video pixel format equivalent to an image **format**. If there is no equivalent format QVideoFrame::InvalidType is returned instead.

        **Note:** In general **QImage**  does not handle YUV formats.
        """
        ...

    def planeCount(self) -> int:
        """
        **int QVideoFrame::planeCount() const**

        Returns the number of planes in the video frame.

        This value is only valid while the frame data is **mapped** .

        This function was introduced in Qt 5.4.

        **See also** **map** ().
        """
        ...

    def setEndTime(self, time: int) -> None:
        """
        **void QVideoFrame::setEndTime(qint64 time )**

        Sets the presentation **time** (in microseconds) when a frame should stop being displayed.

        An invalid time is represented as -1.

        **See also** **endTime** ().
        """
        ...

    def setFieldType(self, arg__1: PySide2.QtMultimedia.QVideoFrame.FieldType) -> None:
        """
        **void QVideoFrame::setFieldType(QVideoFrame::FieldType field )**

        Sets the **field** an interlaced video frame belongs to.

        **See also** **fieldType** ().
        """
        ...

    def setMetaData(self, key: str, value: typing.Any) -> None:
        """
        **void QVideoFrame::setMetaData(const QString & key , const QVariant & value )**

        Sets the metadata for the given **key** to **value**.

        If **value** is a null variant, any metadata for this key will be removed.

        The producer of the video frame might use this to associate certain data with this frame, or for an intermediate processor to add information for a consumer of this frame.

        **See also** **metaData** ().
        """
        ...

    def setStartTime(self, time: int) -> None:
        """
        **void QVideoFrame::setStartTime(qint64 time )**

        Sets the presentation **time** (in microseconds) when the frame should initially be displayed.

        An invalid time is represented as -1.

        **See also** **startTime** ().
        """
        ...

    def size(self) -> PySide2.QtCore.QSize:
        """
        **QSize QVideoFrame::size() const**

        Returns the dimensions of a video frame.
        """
        ...

    def startTime(self) -> int:
        """
        **qint64 QVideoFrame::startTime() const**

        Returns the presentation time (in microseconds) when the frame should be displayed.

        An invalid time is represented as -1.

        **See also** **setStartTime** ().
        """
        ...

    def unmap(self) -> None:
        """
        **void QVideoFrame::unmap()**

        Releases the memory mapped by the **map** () function.

        If the **MapMode**  included the **QAbstractVideoBuffer::WriteOnly**  flag this will persist the current content of the mapped memory to the video frame.

        unmap() should not be called if **map** () function failed.

        **See also** **map** ().
        """
        ...

    def width(self) -> int:
        """
        **int QVideoFrame::width() const**

        Returns the width of a video frame.
        """
        ...
