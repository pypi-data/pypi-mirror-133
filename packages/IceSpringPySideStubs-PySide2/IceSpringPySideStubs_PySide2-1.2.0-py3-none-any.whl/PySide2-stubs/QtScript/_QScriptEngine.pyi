"""
PySide stub files generated by **IceSpringPySideStubs**

Home: https://baijifeilong.github.io/2022/01/06/ice-spring-pyside-stubs/index.html

Github: https://github.com/baijifeilong/IceSpringPySideStubs

PyPI(PySide2): https://pypi.org/project/IceSpringPySideStubs-PySide2

PyPI(PySide6): https://pypi.org/project/IceSpringPySideStubs-PySide6

PyPI(PyQt5): https://pypi.org/project/IceSpringPySideStubs-PyQt5

Generated by BaiJiFeiLong@gmail.com

Licence: GPLv3
"""
"""
This file contains the exact signatures for all functions in module
PySide2.QtScript, except for defaults which are replaced by "...".
"""
import PySide2
import typing
import PySide2.QtCore
import PySide2.QtScript

bytes = str


class QScriptEngine(PySide2.QtCore.QObject):
    """
    https://doc.qt.io/qt-5/qscriptengine.html

    **Detailed Description**

    See the **Qt Script**  documentation for information about the Qt Script
    language, and how to get started with scripting your C++ application.

    **Evaluating Scripts**

    Use **evaluate** () to evaluate script code; this is the C++ equivalent of
    the built-in script function `eval()`.

    **QScriptEngine**  myEngine;
        **QScriptValue**  three =
    myEngine.evaluate("1 + 2");

    **evaluate** () returns a **QScriptValue**  that holds the result of the
    evaluation. The **QScriptValue**  class provides functions for converting
    the result to various C++ types (e.g. **QScriptValue::toString** () and
    **QScriptValue::toNumber** ()).

    The following code snippet shows how a script function can be defined and
    then invoked from C++ using **QScriptValue::call** ():

    **QScriptValue**  fun = myEngine.evaluate("(function(a, b) { return a + b;
    })");
        QScriptValueList args;
        args << 1 << 2;
        **QScriptValue**
    threeAgain = fun.call(**QScriptValue** (), args);

    As can be seen from the above snippets, a script is provided to the engine
    in the form of a string. One common way of loading scripts is by reading the
    contents of a file and passing it to **evaluate** ():

    **QString**  fileName = "helloworld.qs";
        **QFile**
    scriptFile(fileName);
        if (!scriptFile.open(**QIODevice** ::ReadOnly))
    // handle error
        **QTextStream**  stream(&scriptFile);
        **QString**
    contents = stream.readAll();
        scriptFile.close();
    myEngine.evaluate(contents, fileName);

    Here we pass the name of the file as the second argument to **evaluate** ().
    This does not affect evaluation in any way; the second argument is a
    general-purpose string that is used to identify the script for debugging
    purposes (for example, our filename will now show up in any
    **uncaughtExceptionBacktrace** () involving the script).

    **Engine Configuration**

    The **globalObject** () function returns the **Global Object** associated
    with the script engine. Properties of the Global Object are accessible from
    any script code (i.e. they are global variables). Typically, before
    evaluating "user" scripts, you will want to configure a script engine by
    adding one or more properties to the Global Object:

    myEngine.globalObject().setProperty("myNumber", 123);
        ...
    **QScriptValue**  myNumberPlusOne = myEngine.evaluate("myNumber + 1");

    Adding custom properties to the scripting environment is one of the standard
    means of providing a scripting API that is specific to your application.
    Usually these custom properties are objects created by the **newQObject** ()
    or **newObject** () functions, or constructor functions created by
    **newFunction** ().

    **Script Exceptions**

    **evaluate** () can throw a script exception (e.g. due to a syntax error);
    in that case, the return value is the value that was thrown (typically an
    `Error` object). You can check whether the evaluation caused an exception by
    calling **hasUncaughtException** (). In that case, you can call toString()
    on the error object to obtain an error message. The current uncaught
    exception is also available through **uncaughtException** (). Calling
    **clearExceptions** () will cause any uncaught exceptions to be cleared.

    **QScriptValue**  result = myEngine.evaluate(...);
        if
    (myEngine.hasUncaughtException()) {
            int line =
    myEngine.uncaughtExceptionLineNumber();
            **qDebug** () << "uncaught
    exception at line" << line << ":" << result.toString();
        }

    The **checkSyntax** () function can be used to determine whether code can be
    usefully passed to **evaluate** ().

    **Script Object Creation**

    Use **newObject** () to create a standard Qt Script object; this is the C++
    equivalent of the script statement `new Object()`. You can use the object-
    specific functionality in **QScriptValue**  to manipulate the script object
    (e.g. **QScriptValue::setProperty** ()). Similarly, use **newArray** () to
    create a Qt Script array object. Use **newDate** () to create a `Date`
    object, and **newRegExp** () to create a `RegExp` object.

    **QObject Integration**

    Use **newQObject** () to wrap a **QObject**  (or subclass) pointer.
    **newQObject** () returns a proxy script object; properties, children, and
    signals and slots of the **QObject**  are available as properties of the
    proxy object. No binding code is needed because it is done dynamically using
    the Qt meta object system.

    **QPushButton**  button;
        **QScriptValue**  scriptButton =
    myEngine.newQObject(&button);
    myEngine.globalObject().setProperty("button", scriptButton);
    myEngine.evaluate("button.checkable = true");

        **qDebug** () <<
    scriptButton.property("checkable").toBoolean();
    scriptButton.property("show").call(); // call the show() slot

    Use **qScriptConnect** () to connect a C++ signal to a script function; this
    is the Qt Script equivalent of **QObject::connect** (). When a script
    function is invoked in response to a C++ signal, it can cause a script
    exception; you can connect to the **signalHandlerException** () signal to
    catch such an exception.

    Use **newQMetaObject** () to wrap a **QMetaObject** ; this gives you a
    "script representation" of a **QObject** -based class. **newQMetaObject** ()
    returns a proxy script object; enum values of the class are available as
    properties of the proxy object. You can also specify a function that will be
    used to construct objects of the class (e.g. when the constructor is invoked
    from a script). For classes that have a "standard" Qt constructor, Qt Script
    can provide a default script constructor for you; see
    **scriptValueFromQMetaObject** ().

    See **Making Applications Scriptable**  for more information on the
    **QObject**  integration.

    **Support for Custom C++ Types**

    Use **newVariant** () to wrap a **QVariant** . This can be used to store
    values of custom (non-**QObject** ) C++ types that have been registered with
    the Qt meta-type system. To make such types scriptable, you typically
    associate a prototype (delegate) object with the C++ type by calling
    **setDefaultPrototype** (); the prototype object defines the scripting API
    for the C++ type. Unlike the **QObject**  integration, there is no automatic
    binding possible here; i.e. you have to create the scripting API yourself,
    for example by using the **QScriptable**  class.

    Use **fromScriptValue** () to cast from a **QScriptValue**  to another type,
    and **toScriptValue** () to create a **QScriptValue**  from another value.
    You can specify how the conversion of C++ types is to be performed with
    **qScriptRegisterMetaType** () and **qScriptRegisterSequenceMetaType** ().
    By default, Qt Script will use **QVariant**  to store values of custom
    types.

    **Importing Extensions**

    Use **importExtension** () to import plugin-based extensions into the
    engine. Call **availableExtensions** () to obtain a list naming all the
    available extensions, and **importedExtensions** () to obtain a list naming
    only those extensions that have been imported.

    Call **pushContext** () to open up a new variable scope, and **popContext**
    () to close the current scope. This is useful if you are implementing an
    extension that evaluates script code containing temporary variable
    definitions (e.g. `var foo = 123;`) that are safe to discard when evaluation
    has completed.

    **Native Functions**

    Use **newFunction** () to wrap native (C++) functions, including
    constructors for your own custom types, so that these can be invoked from
    script code. Such functions must have the signature
    **QScriptEngine::FunctionSignature** . You may then pass the function as
    argument to **newFunction** (). Here is an example of a function that
    returns the sum of its first two arguments:

    **QScriptValue**  myAdd(**QScriptContext**  *context, **QScriptEngine**
    *engine)
        {
           **QScriptValue**  a = context->argument(0);
    **QScriptValue**  b = context->argument(1);
           return a.toNumber() +
    b.toNumber();
        }

    To expose this function to script code, you can set it as a property of the
    Global Object:

    **QScriptValue**  fun = myEngine.newFunction(myAdd);
    myEngine.globalObject().setProperty("myAdd", fun);

    Once this is done, script code can call your function in the exact same
    manner as a "normal" script function:

    **QScriptValue**  result = myEngine.evaluate("myAdd(myNumber, 1)");

    **Long-running Scripts**

    If you need to evaluate possibly long-running scripts from the main (GUI)
    thread, you should first call **setProcessEventsInterval** () to make sure
    that the GUI stays responsive. You can abort a currently running script by
    calling **abortEvaluation** (). You can determine whether an engine is
    currently running a script by calling **isEvaluating** ().

    **Garbage Collection**

    Qt Script objects may be garbage collected when they are no longer
    referenced. There is no guarantee as to when automatic garbage collection
    will take place.

    The **collectGarbage** () function can be called to explicitly request
    garbage collection.

    The **reportAdditionalMemoryCost** () function can be called to indicate
    that a Qt Script object occupies memory that isn't managed by the scripting
    environment. Reporting the additional cost makes it more likely that the
    garbage collector will be triggered. This can be useful, for example, when
    many custom, native Qt Script objects are allocated.

    **Core Debugging/Tracing Facilities**

    Since Qt 4.4, you can be notified of events pertaining to script execution
    (e.g. script function calls and statement execution) through the
    **QScriptEngineAgent**  interface; see the **setAgent** () function. This
    can be used to implement debugging and profiling of a QScriptEngine.

    **See also** **QScriptValue** , **QScriptContext** , and
    **QScriptEngineAgent** .
    """

    QtOwnership: QScriptEngine = ...
    ExcludeChildObjects: QScriptEngine = ...
    ScriptOwnership: QScriptEngine = ...
    AutoOwnership: QScriptEngine = ...
    ExcludeSuperClassMethods: QScriptEngine = ...
    ExcludeSuperClassProperties: QScriptEngine = ...
    ExcludeSuperClassContents: QScriptEngine = ...
    SkipMethodsInEnumeration: QScriptEngine = ...
    ExcludeDeleteLater: QScriptEngine = ...
    ExcludeSlots: QScriptEngine = ...
    AutoCreateDynamicProperties: QScriptEngine = ...
    PreferExistingWrapperObject: QScriptEngine = ...

    class QObjectWrapOption(object):
        ExcludeChildObjects: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassMethods: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassProperties: QScriptEngine.QObjectWrapOption = ...
        ExcludeSuperClassContents: QScriptEngine.QObjectWrapOption = ...
        SkipMethodsInEnumeration: QScriptEngine.QObjectWrapOption = ...
        ExcludeDeleteLater: QScriptEngine.QObjectWrapOption = ...
        ExcludeSlots: QScriptEngine.QObjectWrapOption = ...
        AutoCreateDynamicProperties: QScriptEngine.QObjectWrapOption = ...
        PreferExistingWrapperObject: QScriptEngine.QObjectWrapOption = ...

    class QObjectWrapOptions(object):
        ...

    class ValueOwnership(object):
        QtOwnership: QScriptEngine.ValueOwnership = ...
        ScriptOwnership: QScriptEngine.ValueOwnership = ...
        AutoOwnership: QScriptEngine.ValueOwnership = ...

    @typing.overload
    def __init__(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#QScriptEngine

        **QScriptEngine::QScriptEngine()**

        Constructs a QScriptEngine object.

        The **globalObject** () is initialized to have properties as described
        in **ECMA-262** , Section 15.1.
        """
        ...

    @typing.overload
    def __init__(self, parent: PySide2.QtCore.QObject) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#QScriptEngine-1

        **QScriptEngine::QScriptEngine(QObject * parent )**

        Constructs a QScriptEngine object with the given **parent**.

        The **globalObject** () is initialized to have properties as described
        in **ECMA-262** , Section 15.1.
        """
        ...

    def abortEvaluation(self, result: PySide2.QtScript.QScriptValue = ...) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#abortEvaluation

        **void QScriptEngine::abortEvaluation(const QScriptValue & result =
        QScriptValue())**

        Aborts any script evaluation currently taking place in this engine. The
        given **result** is passed back as the result of the evaluation (i.e. it
        is returned from the call to **evaluate** () being aborted).

        If the engine isn't evaluating a script (i.e. **isEvaluating** ()
        returns false), this function does nothing.

        Call this function if you need to abort a running script for some
        reason, e.g. when you have detected that the script has been running for
        several seconds without completing.

        This function was introduced in Qt 4.4.

        **See also** **evaluate** (), **isEvaluating** (), and
        **setProcessEventsInterval** ().
        """
        ...

    def agent(self) -> PySide2.QtScript.QScriptEngineAgent:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#agent

        **QScriptEngineAgent *QScriptEngine::agent() const**

        Returns the agent currently installed on this engine, or 0 if no agent
        is installed.

        This function was introduced in Qt 4.4.

        **See also** **setAgent** ().
        """
        ...

    def availableExtensions(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#availableExtensions

        **QStringList QScriptEngine::availableExtensions() const**

        Returns a list naming the available extensions that can be imported
        using the **importExtension** () function. This list includes extensions
        that have been imported.

        This function was introduced in Qt 4.4.

        **See also** **importExtension** () and **importedExtensions** ().
        """
        ...

    def canEvaluate(self, program: str) -> bool:
        ...

    def clearExceptions(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#clearExceptions

        **void QScriptEngine::clearExceptions()**

        Clears any uncaught exceptions in this engine.

        This function was introduced in Qt 4.4.

        **See also** **hasUncaughtException** ().
        """
        ...

    def collectGarbage(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#collectGarbage

        **void QScriptEngine::collectGarbage()**

        Runs the garbage collector.

        The garbage collector will attempt to reclaim memory by locating and
        disposing of objects that are no longer reachable in the script
        environment.

        Normally you don't need to call this function; the garbage collector
        will automatically be invoked when the **QScriptEngine**  decides that
        it's wise to do so (i.e. when a certain number of new objects have been
        created). However, you can call this function to explicitly request that
        garbage collection should be performed as soon as possible.

        **See also** **reportAdditionalMemoryCost** ().
        """
        ...

    def currentContext(self) -> PySide2.QtScript.QScriptContext:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#currentContext

        **QScriptContext *QScriptEngine::currentContext() const**

        Returns the current context.

        The current context is typically accessed to retrieve the arguments and
        `this' object in native functions; for convenience, it is available as
        the first argument in **QScriptEngine::FunctionSignature** .
        """
        ...

    def defaultPrototype(self, metaTypeId: int) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#defaultPrototype

        **QScriptValue QScriptEngine::defaultPrototype(int metaTypeId ) const**

        Returns the default prototype associated with the given **metaTypeId** ,
        or an invalid **QScriptValue**  if no default prototype has been set.

        **See also** **setDefaultPrototype** ().
        """
        ...

    @typing.overload
    def evaluate(
        self, program: PySide2.QtScript.QScriptProgram
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#evaluate

        **QScriptValue QScriptEngine::evaluate(const QString & program , const
        QString & fileName = QString(), int lineNumber = 1)**

        Evaluates **program** , using **lineNumber** as the base line number,
        and returns the result of the evaluation.

        The script code will be evaluated in the current context.

        The evaluation of **program** can cause an exception in the engine; in
        this case the return value will be the exception that was thrown
        (typically an `Error` object). You can call **hasUncaughtException** ()
        to determine if an exception occurred in the last call to evaluate().

        **lineNumber** is used to specify a starting line number for **program**
        ; line number information reported by the engine that pertain to this
        evaluation (e.g. **uncaughtExceptionLineNumber** ()) will be based on
        this argument. For example, if **program** consists of two lines of
        code, and the statement on the second line causes a script exception,
        **uncaughtExceptionLineNumber** () would return the given **lineNumber**
        plus one. When no starting line number is specified, line numbers will
        be 1-based.

        **fileName** is used for error reporting. For example in error objects
        the file name is accessible through the "fileName" property if it's
        provided with this function.

        **See also** **canEvaluate** (), **hasUncaughtException** (),
        **isEvaluating** (), and **abortEvaluation** ().
        """
        ...

    @typing.overload
    def evaluate(
        self, program: str, fileName: str = ..., lineNumber: int = ...
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#evaluate-1

        **QScriptValue QScriptEngine::evaluate(const QScriptProgram & program
        )**

        Evaluates the given **program** and returns the result of the
        evaluation.

        This function was introduced in Qt 4.7.
        """
        ...

    def globalObject(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#globalObject

        **QScriptValue QScriptEngine::globalObject() const**

        Returns this engine's Global Object.

        By default, the Global Object contains the built-in objects that are
        part of **ECMA-262** , such as Math, Date and String. Additionally, you
        can set properties of the Global Object to make your own extensions
        available to all script code. Non-local variables in script code will be
        created as properties of the Global Object, as well as local variables
        in global code.

        **See also** **setGlobalObject** ().
        """
        ...

    def hasUncaughtException(self) -> bool:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#hasUncaughtException

        **bool QScriptEngine::hasUncaughtException() const**

        Returns true if the last script evaluation resulted in an uncaught
        exception; otherwise returns false.

        The exception state is cleared when **evaluate** () is called.

        **See also** **uncaughtException** () and
        **uncaughtExceptionLineNumber** ().
        """
        ...

    def importExtension(self, extension: str) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#importExtension

        **QScriptValue QScriptEngine::importExtension(const QString & extension
        )**

        Imports the given **extension** into this **QScriptEngine** . Returns
        **undefinedValue** () if the extension was successfully imported. You
        can call **hasUncaughtException** () to check if an error occurred; in
        that case, the return value is the value that was thrown by the
        exception (usually an `Error` object).

        **QScriptEngine**  ensures that a particular extension is only imported
        once; subsequent calls to importExtension() with the same extension name
        will do nothing and return **undefinedValue** ().

        **See also** **availableExtensions** (), **QScriptExtensionPlugin** ,
        and **Creating Qt Script Extensions** .
        """
        ...

    def importedExtensions(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#importedExtensions

        **QStringList QScriptEngine::importedExtensions() const**

        Returns a list naming the extensions that have been imported using the
        **importExtension** () function.

        This function was introduced in Qt 4.4.

        **See also** **availableExtensions** ().
        """
        ...

    def installTranslatorFunctions(
        self, object: PySide2.QtScript.QScriptValue = ...
    ) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#installTranslatorFunctions

        **void QScriptEngine::installTranslatorFunctions(const QScriptValue &
        object = QScriptValue())**

        Installs translator functions on the given **object** , or on the Global
        Object if no object is specified.

        The relation between Qt Script translator functions and C++ translator
        functions is described in the following table:

        Script FunctionCorresponding C++ Function
        qsTr()**QObject::tr** ()
        **QT_TR_NOOP** ()**QT_TR_NOOP** ()
        qsTranslate()**QCoreApplication::translate** ()
        **QT_TRANSLATE_NOOP**
        ()**QT_TRANSLATE_NOOP** ()
        qsTrId() (since 4.7)**qtTrId** ()
        **QT_TRID_NOOP** () (since 4.7)**QT_TRID_NOOP** ()

        This function was introduced in Qt 4.5.

        **See also** **Internationalization with Qt** .
        """
        ...

    def isEvaluating(self) -> bool:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#isEvaluating

        **bool QScriptEngine::isEvaluating() const**

        Returns true if this engine is currently evaluating a script, otherwise
        returns false.

        This function was introduced in Qt 4.4.

        **See also** **evaluate** () and **abortEvaluation** ().
        """
        ...

    def newActivationObject(self) -> PySide2.QtScript.QScriptValue:
        ...

    def newArray(self, length: int = ...) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newArray

        **QScriptValue QScriptEngine::newArray(uint length = 0)**

        Creates a Qt Script object of class Array with the given **length**.

        **See also** **newObject** ().
        """
        ...

    @typing.overload
    def newDate(self, value: PySide2.QtCore.QDateTime) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newDate

        **QScriptValue QScriptEngine::newDate(qsreal value )**

        Creates a Qt Script object of class Date with the given **value** (the
        number of milliseconds since 01 January 1970, UTC).
        """
        ...

    @typing.overload
    def newDate(self, value: float) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newDate-1

        **QScriptValue QScriptEngine::newDate(const QDateTime & value )**

        Creates a Qt Script object of class Date from the given **value**.

        **See also** **QScriptValue::toDateTime** ().
        """
        ...

    @typing.overload
    def newObject(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newObject

        **QScriptValue QScriptEngine::newObject()**

        Creates a Qt Script object of class Object.

        The prototype of the created object will be the Object prototype object.

        **See also** **newArray** () and **QScriptValue::setProperty** ().
        """
        ...

    @typing.overload
    def newObject(
        self,
        scriptClass: PySide2.QtScript.QScriptClass,
        data: PySide2.QtScript.QScriptValue = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newObject-1

        **QScriptValue QScriptEngine::newObject(QScriptClass * scriptClass ,
        const QScriptValue & data = QScriptValue())**

        This is an overloaded function.

        Creates a Qt Script Object of the given class, **scriptClass**.

        The prototype of the created object will be the Object prototype object.

        **data** , if specified, is set as the internal data of the new object
        (using **QScriptValue::setData** ()).

        This function was introduced in Qt 4.4.

        **See also** **QScriptValue::scriptClass** () and
        **reportAdditionalMemoryCost** ().
        """
        ...

    def newQMetaObject(
        self,
        metaObject: PySide2.QtCore.QMetaObject,
        ctor: PySide2.QtScript.QScriptValue = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQMetaObject

        **QScriptValue QScriptEngine::newQMetaObject(const QMetaObject *
        metaObject , const QScriptValue & ctor = QScriptValue())**

        Creates a Qt Script object that represents a **QObject**  class, using
        the the given **metaObject** and constructor **ctor**.

        Enums of **metaObject** (declared with Q_ENUMS) are available as
        properties of the created **QScriptValue** . When the class is called as
        a function, **ctor** will be called to create a new instance of the
        class.

        Example:

        **QScriptValue**  mySpecialQObjectConstructor(**QScriptContext**
        *context,
                                                     **QScriptEngine**
        *engine)
            {
                **QObject**  *parent =
        context->argument(0).toQObject();
                **QObject**  *object = new
        **QObject** (parent);
                return engine->newQObject(object,
        **QScriptEngine** ::ScriptOwnership);
            }

            ...
        **QScriptValue**  ctor =
        engine.newFunction(mySpecialQObjectConstructor);
            **QScriptValue**
        metaObject = engine.newQMetaObject(&**QObject** ::staticMetaObject,
        ctor);
            engine.globalObject().setProperty("QObject", metaObject);
        **QScriptValue**  result = engine.evaluate("new QObject()");

        **See also** **newQObject** () and **scriptValueFromQMetaObject** ().
        """
        ...

    @typing.overload
    def newQObject(
        self,
        object: PySide2.QtCore.QObject,
        ownership: PySide2.QtScript.QScriptEngine.ValueOwnership = ...,
        options: PySide2.QtScript.QScriptEngine.QObjectWrapOptions = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQObject

        **QScriptValue QScriptEngine::newQObject(QObject * object ,
        QScriptEngine::ValueOwnership ownership = QtOwnership, const
        QScriptEngine::QObjectWrapOptions & options = QObjectWrapOptions())**

        Creates a Qt Script object that wraps the given **QObject**  **object**
        , using the given **ownership**. The given **options** control various
        aspects of the interaction with the resulting script object.

        Signals and slots, properties and children of **object** are available
        as properties of the created **QScriptValue** . For more information,
        see the **Qt Script**  documentation.

        If **object** is a null pointer, this function returns **nullValue** ().

        If a default prototype has been registered for the **object** 's class
        (or its superclass, recursively), the prototype of the new script object
        will be set to be that default prototype.

        If the given **object** is deleted outside of Qt Script's control, any
        attempt to access the deleted **QObject** 's members through the Qt
        Script wrapper object (either by script code or C++) will result in a
        script exception.

        **See also** **QScriptValue::toQObject** () and
        **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newQObject(
        self,
        scriptObject: PySide2.QtScript.QScriptValue,
        qtObject: PySide2.QtCore.QObject,
        ownership: PySide2.QtScript.QScriptEngine.ValueOwnership = ...,
        options: PySide2.QtScript.QScriptEngine.QObjectWrapOptions = ...,
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newQObject-1

        **QScriptValue QScriptEngine::newQObject(const QScriptValue &
        scriptObject , QObject * qtObject , QScriptEngine::ValueOwnership
        ownership = QtOwnership, const QScriptEngine::QObjectWrapOptions &
        options = QObjectWrapOptions())**

        This is an overloaded function.

        Initializes the given **scriptObject** to hold the given **qtObject** ,
        and returns the **scriptObject**.

        This function enables you to "promote" a plain Qt Script object (created
        by the **newObject** () function) to a **QObject**  proxy, or to replace
        the **QObject**  contained inside an object previously created by the
        newQObject() function.

        The prototype() of the **scriptObject** will remain unchanged.

        If **scriptObject** is not an object, this function behaves like the
        normal newQObject(), i.e. it creates a new script object and returns it.

        This function is useful when you want to provide a script constructor
        for a **QObject** -based class. If your constructor is invoked in a
        `new` expression (**QScriptContext::isCalledAsConstructor** () returns
        true), you can pass **QScriptContext::thisObject** () (the default
        constructed script object) to this function to initialize the new
        object.

        This function was introduced in Qt 4.4.

        **See also** **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newRegExp(self, pattern: str, flags: str) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newRegExp

        **QScriptValue QScriptEngine::newRegExp(const QRegExp & regexp )**

        Creates a Qt Script object of class RegExp with the given **regexp**.

        **See also** **QScriptValue::toRegExp** ().
        """
        ...

    @typing.overload
    def newRegExp(
        self, regexp: PySide2.QtCore.QRegExp
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newRegExp-1

        **QScriptValue QScriptEngine::newRegExp(const QString & pattern , const
        QString & flags )**

        Creates a Qt Script object of class RegExp with the given **pattern**
        and **flags**.

        The legal flags are 'g' (global), 'i' (ignore case), and 'm'
        (multiline).
        """
        ...

    @typing.overload
    def newVariant(
        self, object: PySide2.QtScript.QScriptValue, value: typing.Any
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newVariant

        **QScriptValue QScriptEngine::newVariant(const QVariant & value )**

        Creates a Qt Script object holding the given variant **value**.

        If a default prototype has been registered with the meta type id of
        **value** , then the prototype of the created object will be that
        prototype; otherwise, the prototype will be the Object prototype object.

        **See also** **setDefaultPrototype** (), **QScriptValue::toVariant** (),
        and **reportAdditionalMemoryCost** ().
        """
        ...

    @typing.overload
    def newVariant(self, value: typing.Any) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#newVariant-1

        **QScriptValue QScriptEngine::newVariant(const QScriptValue & object ,
        const QVariant & value )**

        This is an overloaded function.

        Initializes the given Qt Script **object** to hold the given variant
        **value** , and returns the **object**.

        This function enables you to "promote" a plain Qt Script object (created
        by the **newObject** () function) to a variant, or to replace the
        variant contained inside an object previously created by the
        newVariant() function.

        The prototype() of the **object** will remain unchanged.

        If **object** is not an object, this function behaves like the normal
        newVariant(), i.e. it creates a new script object and returns it.

        This function is useful when you want to provide a script constructor
        for a C++ type. If your constructor is invoked in a `new` expression
        (**QScriptContext::isCalledAsConstructor** () returns true), you can
        pass **QScriptContext::thisObject** () (the default constructed script
        object) to this function to initialize the new object.

        This function was introduced in Qt 4.4.

        **See also** **reportAdditionalMemoryCost** ().
        """
        ...

    def nullValue(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#nullValue

        **QScriptValue QScriptEngine::nullValue()**

        Returns a **QScriptValue**  of the primitive type Null.

        **See also** **undefinedValue** ().
        """
        ...

    def objectById(self, id: int) -> PySide2.QtScript.QScriptValue:
        ...

    def popContext(self) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#popContext

        **void QScriptEngine::popContext()**

        Pops the current execution context and restores the previous one. This
        function must be used in conjunction with **pushContext** ().

        **See also** **pushContext** ().
        """
        ...

    def processEventsInterval(self) -> int:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#processEventsInterval

        **int QScriptEngine::processEventsInterval() const**

        Returns the interval in milliseconds between calls to
        **QCoreApplication::processEvents** () while the interpreter is running.

        **See also** **setProcessEventsInterval** ().
        """
        ...

    def pushContext(self) -> PySide2.QtScript.QScriptContext:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#pushContext

        **QScriptContext *QScriptEngine::pushContext()**

        Enters a new execution context and returns the associated
        **QScriptContext**  object.

        Once you are done with the context, you should call **popContext** () to
        restore the old context.

        By default, the `this' object of the new context is the Global Object.
        The context's **callee** () will be invalid.

        This function is useful when you want to evaluate script code as if it
        were the body of a function. You can use the context's
        **activationObject** () to initialize local variables that will be
        available to scripts. Example:

        **QScriptEngine**  engine;
            **QScriptContext**  *context =
        engine.pushContext();
        context->activationObject().setProperty("myArg", 123);
        engine.evaluate("var tmp = myArg + 42");
            ...
        engine.popContext();

        In the above example, the new variable "tmp" defined in the script will
        be local to the context; in other words, the script doesn't have any
        effect on the global environment.

        Returns 0 in case of stack overflow

        **See also** **popContext** ().
        """
        ...

    def reportAdditionalMemoryCost(self, size: int) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#reportAdditionalMemoryCost

        **void QScriptEngine::reportAdditionalMemoryCost(int size )**

        Reports an additional memory cost of the given **size** , measured in
        bytes, to the garbage collector.

        This function can be called to indicate that a Qt Script object has
        memory associated with it that isn't managed by Qt Script itself.
        Reporting the additional cost makes it more likely that the garbage
        collector will be triggered.

        Note that if the additional memory is shared with objects outside the
        scripting environment, the cost should not be reported, since collecting
        the Qt Script object would not cause the memory to be freed anyway.

        Negative **size** values are ignored, i.e. this function can't be used
        to report that the additional memory has been deallocated.

        This function was introduced in Qt 4.7.

        **See also** **collectGarbage** ().
        """
        ...

    def setAgent(self, agent: PySide2.QtScript.QScriptEngineAgent) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setAgent

        **void QScriptEngine::setAgent(QScriptEngineAgent * agent )**

        Installs the given **agent** on this engine. The agent will be notified
        of various events pertaining to script execution. This is useful when
        you want to find out exactly what the engine is doing, e.g. when
        **evaluate** () is called. The agent interface is the basis of tools
        like debuggers and profilers.

        The engine maintains ownership of the **agent**.

        Calling this function will replace the existing agent, if any.

        This function was introduced in Qt 4.4.

        **See also** **agent** ().
        """
        ...

    def setDefaultPrototype(
        self, metaTypeId: int, prototype: PySide2.QtScript.QScriptValue
    ) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setDefaultPrototype

        **void QScriptEngine::setDefaultPrototype(int metaTypeId , const
        QScriptValue & prototype )**

        Sets the default prototype of the C++ type identified by the given
        **metaTypeId** to **prototype**.

        The default prototype provides a script interface for values of type
        **metaTypeId** when a value of that type is accessed from script code.
        Whenever the script engine (implicitly or explicitly) creates a
        **QScriptValue**  from a value of type **metaTypeId** , the default
        prototype will be set as the **QScriptValue** 's prototype.

        The **prototype** object itself may be constructed using one of two
        principal techniques; the simplest is to subclass **QScriptable** ,
        which enables you to define the scripting API of the type through
        **QObject**  properties and slots. Another possibility is to create a
        script object by calling **newObject** (), and populate the object with
        the desired properties (e.g. native functions wrapped with
        **newFunction** ()).

        **See also** **defaultPrototype** (), **qScriptRegisterMetaType** (),
        **QScriptable** , and **Default Prototypes Example** .
        """
        ...

    def setGlobalObject(self, object: PySide2.QtScript.QScriptValue) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setGlobalObject

        **void QScriptEngine::setGlobalObject(const QScriptValue & object )**

        Sets this engine's Global Object to be the given **object**. If
        **object** is not a valid script object, this function does nothing.

        When setting a custom global object, you may want to use
        **QScriptValueIterator**  to copy the properties of the standard Global
        Object; alternatively, you can set the internal prototype of your custom
        object to be the original Global Object.

        This function was introduced in Qt 4.5.

        **See also** **globalObject** ().
        """
        ...

    def setProcessEventsInterval(self, interval: int) -> None:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#setProcessEventsInterval

        **void QScriptEngine::setProcessEventsInterval(int interval )**

        Sets the interval between calls to **QCoreApplication::processEvents**
        to **interval** milliseconds.

        While the interpreter is running, all event processing is by default
        blocked. This means for instance that the gui will not be updated and
        timers will not be fired. To allow event processing during interpreter
        execution one can specify the processing interval to be a positive
        value, indicating the number of milliseconds between each time
        **QCoreApplication::processEvents** () is called.

        The default value is -1, which disables event processing during
        interpreter execution.

        You can use **QCoreApplication::postEvent** () to post an event that
        performs custom processing at the next interval. For example, you could
        keep track of the total running time of the script and call
        **abortEvaluation** () when you detect that the script has been running
        for a long time without completing.

        **See also** **processEventsInterval** ().
        """
        ...

    def toObject(
        self, value: PySide2.QtScript.QScriptValue
    ) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#toObject

        **QScriptValue QScriptEngine::toObject(const QScriptValue & value )**

        Converts the given **value** to an object, if such a conversion is
        possible; otherwise returns an invalid **QScriptValue** . The conversion
        is performed according to the following table:

        Input TypeResult
        UndefinedAn invalid **QScriptValue** .
        NullAn
        invalid **QScriptValue** .
        BooleanA new Boolean object whose internal
        value is set to the value of the boolean.
        NumberA new Number object
        whose internal value is set to the value of the number.
        StringA new
        String object whose internal value is set to the value of the string.
        ObjectThe result is the object itself (no conversion).

        This function was introduced in Qt 4.5.

        **See also** **newObject** ().
        """
        ...

    def toStringHandle(self, str: str) -> PySide2.QtScript.QScriptString:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#toStringHandle

        **QScriptString QScriptEngine::toStringHandle(const QString & str )**

        Returns a handle that represents the given string, **str**.

        **QScriptString**  can be used to quickly look up properties, and
        compare property names, of script objects.

        This function was introduced in Qt 4.4.

        **See also** **QScriptValue::property** ().
        """
        ...

    def uncaughtException(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtException

        **QScriptValue QScriptEngine::uncaughtException() const**

        Returns the current uncaught exception, or an invalid **QScriptValue**
        if there is no uncaught exception.

        The exception value is typically an `Error` object; in that case, you
        can call toString() on the return value to obtain an error message.

        **See also** **hasUncaughtException** () and
        **uncaughtExceptionLineNumber** ().
        """
        ...

    def uncaughtExceptionBacktrace(self) -> typing.List:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtExceptionBacktrace

        **QStringList QScriptEngine::uncaughtExceptionBacktrace() const**

        Returns a human-readable backtrace of the last uncaught exception.

        It is in the form `<function-name>() at <file-name>:<line-number>`.

        **See also** **uncaughtException** ().
        """
        ...

    def uncaughtExceptionLineNumber(self) -> int:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#uncaughtExceptionLineNumber

        **int QScriptEngine::uncaughtExceptionLineNumber() const**

        Returns the line number where the last uncaught exception occurred.

        Line numbers are 1-based, unless a different base was specified as the
        second argument to **evaluate** ().

        **See also** **hasUncaughtException** ().
        """
        ...

    def undefinedValue(self) -> PySide2.QtScript.QScriptValue:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#undefinedValue

        **QScriptValue QScriptEngine::undefinedValue()**

        Returns a **QScriptValue**  of the primitive type Undefined.

        **See also** **nullValue** ().
        """
        ...

    @property
    def signalHandlerException(self) -> PySide2.QtCore.SignalInstance:
        """
        https://doc.qt.io/qt-5/qscriptengine.html#signalHandlerException

        **[signal] void QScriptEngine::signalHandlerException(const QScriptValue
        & exception )**

        This signal is emitted when a script function connected to a signal
        causes an **exception**.

        This function was introduced in Qt 4.4.

        **See also** **qScriptConnect** ().
        """
        ...
