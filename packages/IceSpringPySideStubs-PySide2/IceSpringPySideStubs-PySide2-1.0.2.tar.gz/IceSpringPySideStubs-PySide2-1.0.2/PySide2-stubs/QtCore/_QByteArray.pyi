"""
PySide2 stub files generated by **IceSpringPySideStubs**

Home page: https://github.com/baijifeilong/IceSpringPySideStubs

Generated by BaiJiFeiLong@gmail.com

Licence: GPL-3
"""
import typing
import PySide2
import PySide2.QtCore

bytes = str


class QByteArray(object):
    """
    https://doc.qt.io/qt-5/qbytearray.html

    **Detailed Description**

    QByteArray can be used to store both raw bytes (including \'\\0\'s) and traditional 8-bit \'\\0\'-terminated strings. Using QByteArray is much more convenient than using `const char *`. Behind the scenes, it always ensures that the data is followed by a \'\\0\' terminator, and uses **implicit sharing**  (copy-on-write) to reduce memory usage and avoid needless copying of data.

    In addition to QByteArray, Qt also provides the **QString**  class to store string data. For most purposes, **QString**  is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, **QString**  is used throughout in the Qt API. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).

    One way to initialize a QByteArray is simply to pass a `const char *` to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":

    **QByteArray**  ba("Hello");

    Although the **size** () is 5, the byte array also maintains an extra \'\\0\' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to **data** ()), the data pointed to is guaranteed to be \'\\0\'-terminated.

    QByteArray makes a deep copy of the `const char *` data, so you can modify it later without experiencing side effects. (If for performance reasons you don\'t want to take a deep copy of the character data, use **QByteArray::fromRawData** () instead.)

    Another approach is to set the size of the array using **resize** () and to initialize the data byte per byte. QByteArray uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:

    **QByteArray**  ba;
        ba.resize(5);
        ba[0] = 0x3c;
        ba[1] = 0xb8;
        ba[2] = 0x64;
        ba[3] = 0x18;
        ba[4] = 0xca;

    For read-only access, an alternative syntax is to use **at** ():

    for (int i = 0; i < ba.size(); ++i) {
            if (ba.at(i) >= \'a\' && ba.at(i) <= \'f\')
                cout << "Found character in range [a-f]" << Qt::endl;
        }

    **at** () can be faster than operator[](), because it never causes a **deep copy**  to occur.

    To extract many bytes at a time, use **left** (), **right** (), or **mid** ().

    A QByteArray can embed \'\\0\' bytes. The **size** () function always returns the size of the whole array, including embedded \'\\0\' bytes, but excluding the terminating \'\\0\' added by QByteArray. For example:

    **QByteArray**  ba1("ca\\0r\\0t");
        ba1.size();                     // Returns 2.
        ba1.constData();                // Returns "ca" with terminating \\0.

        **QByteArray**  ba2("ca\\0r\\0t", 3);
        ba2.size();                     // Returns 3.
        ba2.constData();                // Returns "ca\\0" with terminating \\0.

        **QByteArray**  ba3("ca\\0r\\0t", 4);
        ba3.size();                     // Returns 4.
        ba3.constData();                // Returns "ca\\0r" with terminating \\0.

        const char cart[] = {\'c\', \'a\', \'\\0\', \'r\', \'\\0\', \'t\'};
        **QByteArray**  ba4(**QByteArray** ::fromRawData(cart, 6));
        ba4.size();                     // Returns 6.
        ba4.constData();                // Returns "ca\\0r\\0t" without terminating \\0.

    If you want to obtain the length of the data up to and excluding the first \'\\0\' character, call **qstrlen** () on the byte array.

    After a call to **resize** (), newly allocated bytes have undefined values. To set all the bytes to a particular value, call **fill** ().

    To obtain a pointer to the actual character data, call **data** () or **constData** (). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the QByteArray. It is also guaranteed that the data ends with a \'\\0\' byte unless the QByteArray was created from a **raw data** . This \'\\0\' byte is automatically provided by QByteArray and is not counted in **size** ().

    QByteArray provides the following basic functions for modifying the byte data: **append** (), **prepend** (), **insert** (), **replace** (), and **remove** (). For example:

    **QByteArray**  x("and");
        x.prepend("rock ");         // x == "rock and"
        x.append(" roll");          // x == "rock and roll"
        x.replace(5, 3, "&");       // x == "rock & roll"

    The **replace** () and **remove** () functions\' first two arguments are the position from which to start erasing and the number of bytes that should be erased.

    When you **append** () data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling **reserve** (), which preallocates a certain amount of memory. You can also call **capacity** () to find out how much memory QByteArray actually allocated. Data appended to an empty array is not copied.

    A frequent requirement is to remove whitespace characters from a byte array (\'\\n\', \'\\t\', \' \', etc.). If you want to remove whitespace from both ends of a QByteArray, use **trimmed** (). If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use **simplified** ().

    If you want to find all occurrences of a particular character or substring in a QByteArray, use **indexOf** () or **lastIndexOf** (). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here\'s a typical loop that finds all occurrences of a particular substring:

    **QByteArray**  ba("We must be <b>bold</b>, very <b>bold</b>");
        int j = 0;
        while ((j = ba.indexOf("<b>", j)) != -1) {
            cout << "Found <b> tag at index position " << j << Qt::endl;
            ++j;
        }

    If you simply want to check whether a QByteArray contains a particular character or substring, use **contains** (). If you want to find out how many times a particular character or substring occurs in the byte array, use **count** (). If you want to replace all occurrences of a particular value with another, use one of the two-parameter **replace** () overloads.

    **QByteArray** s can be compared using overloaded operators such as operator<(), operator<=(), operator==(), operator>=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. **QString::localeAwareCompare** () is a better choice for sorting user-interface strings.

    For historical reasons, QByteArray distinguishes between a null byte array and an empty byte array. A **null** byte array is a byte array that is initialized using QByteArray\'s default constructor or by passing (const char *)0 to the constructor. An **empty** byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn\'t necessarily null:

    **QByteArray** ().isNull();          // returns true
        **QByteArray** ().isEmpty();         // returns true

        **QByteArray** ("").isNull();        // returns false
        **QByteArray** ("").isEmpty();       // returns true

        **QByteArray** ("abc").isNull();     // returns false
        **QByteArray** ("abc").isEmpty();    // returns false

    All functions except **isNull** () treat null byte arrays the same as empty byte arrays. For example, **data** () returns a valid pointer ( **not** nullptr) to a \'\\0\' character for a byte array and QByteArray() compares equal to QByteArray(""). We recommend that you always use **isEmpty** () and avoid **isNull** ().

    **Maximum size and out-of-memory conditions**

    The current version of QByteArray is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. Raw data blocks are also limited by the use of `int` type in the current version to 2 GB minus 1 byte.

    In case memory allocation fails, QByteArray will throw a `std::bad_alloc` exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.

    Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the QByteArray API.

    **Notes on Locale**

    **Number-String Conversions**

    Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user\'s locale settings. Use **QString**  to perform locale-aware conversions between numbers and strings.

    **8-bit Character Comparisons**

    In QByteArray, the notion of uppercase and lowercase and of which character is greater than or less than another character is done in the Latin-1 locale. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only Latin-1 characters. Functions that this affects include **contains** (), **indexOf** (), **lastIndexOf** (), operator<(), operator<=(), operator>(), operator>=(), **isLower** (), **isUpper** (), **toLower** () and **toUpper** ().

    This issue does not apply to **QString** s since they represent characters using Unicode.

    **See also** **QString**  and **QBitArray** .
    """

    Base64Encoding: QByteArray = ...
    IgnoreBase64DecodingErrors: QByteArray = ...
    KeepTrailingEquals: QByteArray = ...
    Base64UrlEncoding: QByteArray = ...
    OmitTrailingEquals: QByteArray = ...
    AbortOnBase64DecodingErrors: QByteArray = ...

    class Base64DecodingStatus(object):
        Ok: QByteArray.Base64DecodingStatus = ...
        IllegalInputLength: QByteArray.Base64DecodingStatus = ...
        IllegalCharacter: QByteArray.Base64DecodingStatus = ...
        IllegalPadding: QByteArray.Base64DecodingStatus = ...

    class Base64Option(object):
        Base64Encoding: QByteArray.Base64Option = ...
        IgnoreBase64DecodingErrors: QByteArray.Base64Option = ...
        KeepTrailingEquals: QByteArray.Base64Option = ...
        Base64UrlEncoding: QByteArray.Base64Option = ...
        OmitTrailingEquals: QByteArray.Base64Option = ...
        AbortOnBase64DecodingErrors: QByteArray.Base64Option = ...

    class Base64Options(object):
        ...

    class FromBase64Result(object):
        @typing.overload
        def __init__(self) -> None:
            ...

        @typing.overload
        def __init__(
            self, FromBase64Result: PySide2.QtCore.QByteArray.FromBase64Result
        ) -> None:
            ...

        @staticmethod
        def __copy__() -> None:
            ...

        def swap(self, other: PySide2.QtCore.QByteArray.FromBase64Result) -> None:
            ...

    @typing.overload
    def __init__(self) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#QByteArray

        **QByteArray::QByteArray()**

        Constructs an empty byte array.

        **See also** **isEmpty** ().
        """
        ...

    @typing.overload
    def __init__(self, arg__1: bytearray) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#QByteArray

        **QByteArray::QByteArray()**

        Constructs an empty byte array.

        **See also** **isEmpty** ().
        """
        ...

    @typing.overload
    def __init__(self, arg__1: bytes) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#QByteArray

        **QByteArray::QByteArray()**

        Constructs an empty byte array.

        **See also** **isEmpty** ().
        """
        ...

    @typing.overload
    def __init__(self, arg__1: PySide2.QtCore.QByteArray) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#QByteArray

        **QByteArray::QByteArray()**

        Constructs an empty byte array.

        **See also** **isEmpty** ().
        """
        ...

    @typing.overload
    def __init__(self, size: int, c: int) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#QByteArray

        **QByteArray::QByteArray()**

        Constructs an empty byte array.

        **See also** **isEmpty** ().
        """
        ...

    @typing.overload
    def __add__(self, a2: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        ...

    @typing.overload
    def __add__(self, a2: int) -> PySide2.QtCore.QByteArray:
        ...

    @typing.overload
    def __add__(self, arg__1: bytearray) -> PySide2.QtCore.QByteArray:
        ...

    @typing.overload
    def __add__(self, arg__1: bytes) -> None:
        ...

    @staticmethod
    def __copy__() -> None:
        ...

    @typing.overload
    def __iadd__(self, a: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        ...

    @typing.overload
    def __iadd__(self, arg__1: bytearray) -> PySide2.QtCore.QByteArray:
        ...

    @typing.overload
    def __iadd__(self, c: int) -> PySide2.QtCore.QByteArray:
        ...

    def __reduce__(self) -> object:
        ...

    def __repr__(self) -> object:
        ...

    def __str__(self) -> object:
        ...

    @typing.overload
    def append(self, a: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#append

        **QByteArray &QByteArray::append(const QByteArray & ba )**

        Appends the byte array **ba** onto the end of this byte array.

        Example:

        **QByteArray**  x("free");
            **QByteArray**  y("dom");
            x.append(y);
            // x == "freedom"

        This is the same as insert(**size** (), **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being appended to is not empty, a deep copy of the data is performed, taking **linear time** .

        This operation typically does not suffer from allocation overhead, because **QByteArray**  preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.

        **See also** **operator+=** (), **prepend** (), and **insert** ().
        """
        ...

    @typing.overload
    def append(self, c: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#append

        **QByteArray &QByteArray::append(const QByteArray & ba )**

        Appends the byte array **ba** onto the end of this byte array.

        Example:

        **QByteArray**  x("free");
            **QByteArray**  y("dom");
            x.append(y);
            // x == "freedom"

        This is the same as insert(**size** (), **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being appended to is not empty, a deep copy of the data is performed, taking **linear time** .

        This operation typically does not suffer from allocation overhead, because **QByteArray**  preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.

        **See also** **operator+=** (), **prepend** (), and **insert** ().
        """
        ...

    @typing.overload
    def append(self, count: int, c: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#append

        **QByteArray &QByteArray::append(const QByteArray & ba )**

        Appends the byte array **ba** onto the end of this byte array.

        Example:

        **QByteArray**  x("free");
            **QByteArray**  y("dom");
            x.append(y);
            // x == "freedom"

        This is the same as insert(**size** (), **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being appended to is not empty, a deep copy of the data is performed, taking **linear time** .

        This operation typically does not suffer from allocation overhead, because **QByteArray**  preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.

        **See also** **operator+=** (), **prepend** (), and **insert** ().
        """
        ...

    def at(self, i: int) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#at

        **char QByteArray::at(int i ) const**

        Returns the character at index position **i** in the byte array.

        **i** must be a valid index position in the byte array (i.e., 0 <= **i** < **size** ()).

        **See also** **operator[]** ().
        """
        ...

    def back(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#back

        **char QByteArray::back() const**

        Returns the last character in the byte array. Same as `at(size() - 1)`.

        This function is provided for STL compatibility.

        **Warning:** Calling this function on an empty byte array constitutes undefined behavior.

        This function was introduced in Qt 5.10.

        **See also** **front** (), **at** (), and **operator[]** ().
        """
        ...

    def capacity(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#capacity

        **int QByteArray::capacity() const**

        Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.

        The sole purpose of this function is to provide a means of fine tuning **QByteArray** 's memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call **size** ().

        **See also** **reserve** () and **squeeze** ().
        """
        ...

    def cbegin(self) -> bytes:
        """
        https://doc.qt.io/qt-5/qbytearray.html#cbegin

        **QByteArray::const_iterator QByteArray::cbegin() const**

        Returns a const **STL-style iterator**  pointing to the first character in the byte-array.

        This function was introduced in Qt 5.0.

        **See also** **begin** () and **cend** ().
        """
        ...

    def cend(self) -> bytes:
        """
        https://doc.qt.io/qt-5/qbytearray.html#cend

        **QByteArray::const_iterator QByteArray::cend() const**

        Returns a const **STL-style iterator**  pointing to the imaginary character after the last character in the list.

        This function was introduced in Qt 5.0.

        **See also** **cbegin** () and **end** ().
        """
        ...

    def chop(self, n: int) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#chop

        **void QByteArray::chop(int n )**

        Removes **n** bytes from the end of the byte array.

        If **n** is greater than **size** (), the result is an empty byte array.

        Example:

        **QByteArray**  ba("STARTTLS\\r\\n");
            ba.chop(2);                 // ba == "STARTTLS"

        **See also** **truncate** (), **resize** (), and **left** ().
        """
        ...

    def chopped(self, len: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#chopped

        **QByteArray QByteArray::chopped(int len ) const**

        Returns a byte array that contains the leftmost **size** () - **len** bytes of this byte array.

        **Note:** The behavior is undefined if **len** is negative or greater than **size** ().

        This function was introduced in Qt 5.10.

        **See also** **endsWith** (), **left** (), **right** (), **mid** (), **chop** (), and **truncate** ().
        """
        ...

    def clear(self) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#clear

        **void QByteArray::clear()**

        Clears the contents of the byte array and makes it null.

        **See also** **resize** () and **isNull** ().
        """
        ...

    @typing.overload
    def compare(
        self, a: PySide2.QtCore.QByteArray, cs: PySide2.QtCore.Qt.CaseSensitivity = ...
    ) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#compare

        **int QByteArray::compare(const char * c , Qt::CaseSensitivity cs = Qt::CaseSensitive) const**

        Returns an integer less than, equal to, or greater than zero depending on whether this **QByteArray**  sorts before, at the same position, or after the string pointed to by **c**. The comparison is performed according to case sensitivity **cs**.

        This function was introduced in Qt 5.12.

        **See also** **operator==** .
        """
        ...

    @typing.overload
    def compare(self, c: bytes, cs: PySide2.QtCore.Qt.CaseSensitivity = ...) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#compare

        **int QByteArray::compare(const char * c , Qt::CaseSensitivity cs = Qt::CaseSensitive) const**

        Returns an integer less than, equal to, or greater than zero depending on whether this **QByteArray**  sorts before, at the same position, or after the string pointed to by **c**. The comparison is performed according to case sensitivity **cs**.

        This function was introduced in Qt 5.12.

        **See also** **operator==** .
        """
        ...

    @typing.overload
    def contains(self, a: PySide2.QtCore.QByteArray) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#contains

        **bool QByteArray::contains(const QByteArray & ba ) const**

        Returns `true` if the byte array contains an occurrence of the byte array **ba** ; otherwise returns `false`.

        **See also** **indexOf** () and **count** ().
        """
        ...

    @typing.overload
    def contains(self, c: int) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#contains

        **bool QByteArray::contains(const QByteArray & ba ) const**

        Returns `true` if the byte array contains an occurrence of the byte array **ba** ; otherwise returns `false`.

        **See also** **indexOf** () and **count** ().
        """
        ...

    @typing.overload
    def count(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#count

        **int QByteArray::count(const QByteArray & ba ) const**

        Returns the number of (potentially overlapping) occurrences of byte array **ba** in this byte array.

        **See also** **contains** () and **indexOf** ().
        """
        ...

    @typing.overload
    def count(self, a: PySide2.QtCore.QByteArray) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#count

        **int QByteArray::count(const QByteArray & ba ) const**

        Returns the number of (potentially overlapping) occurrences of byte array **ba** in this byte array.

        **See also** **contains** () and **indexOf** ().
        """
        ...

    @typing.overload
    def count(self, c: int) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#count

        **int QByteArray::count(const QByteArray & ba ) const**

        Returns the number of (potentially overlapping) occurrences of byte array **ba** in this byte array.

        **See also** **contains** () and **indexOf** ().
        """
        ...

    def data(self) -> bytes:
        """
        https://doc.qt.io/qt-5/qbytearray.html#data

        **char *QByteArray::data()**

        Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is \'\\0\'-terminated, i.e. the number of bytes in the returned character string is **size** () + 1 for the \'\\0\' terminator.

        Example:

        **QByteArray**  ba("Hello world");
            char *data = ba.data();
            while (*data) {
                cout << "[" << *data << "]" << Qt::endl;
                ++data;
            }

        The pointer remains valid as long as the byte array isn\'t reallocated or destroyed. For read-only access, **constData** () is faster because it never causes a **deep copy**  to occur.

        This function is mostly useful to pass a byte array to a function that accepts a `const char *`.

        The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the \'\\0\' at the end:

        **QString**  tmp = "test";
            **QByteArray**  text = tmp.toLocal8Bit();
            char *data = new char[text.size()];
            strcpy(data, text.data());
            delete [] data;

        This one allocates the correct amount of space:

        **QString**  tmp = "test";
            **QByteArray**  text = tmp.toLocal8Bit();
            char *data = new char[text.size() + 1];
            strcpy(data, text.data());
            delete [] data;

        Note: A **QByteArray**  can store any byte values including \'\\0\'s, but most functions that take `char *` arguments assume that the data ends at the first \'\\0\' they encounter.

        **See also** **constData** () and **operator[]** ().
        """
        ...

    @typing.overload
    def endsWith(self, a: PySide2.QtCore.QByteArray) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#endsWith

        **bool QByteArray::endsWith(const QByteArray & ba ) const**

        Returns `true` if this byte array ends with byte array **ba** ; otherwise returns `false`.

        Example:

        **QByteArray**  url("http://qt-project.org/doc/qt-5.0/qtdoc/index.html");
            if (url.endsWith(".html"))
                ...

        **See also** **startsWith** () and **right** ().
        """
        ...

    @typing.overload
    def endsWith(self, c: int) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#endsWith

        **bool QByteArray::endsWith(const QByteArray & ba ) const**

        Returns `true` if this byte array ends with byte array **ba** ; otherwise returns `false`.

        Example:

        **QByteArray**  url("http://qt-project.org/doc/qt-5.0/qtdoc/index.html");
            if (url.endsWith(".html"))
                ...

        **See also** **startsWith** () and **right** ().
        """
        ...

    def fill(self, c: int, size: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fill

        **QByteArray &QByteArray::fill(char ch , int size = -1)**

        Sets every byte in the byte array to character **ch**. If **size** is different from -1 (the default), the byte array is resized to size **size** beforehand.

        Example:

        **QByteArray**  ba("Istambul");
            ba.fill(\'o\');
            // ba == "oooooooo"

            ba.fill(\'X\', 2);
            // ba == "XX"

        **See also** **resize** ().
        """
        ...

    @typing.overload
    @staticmethod
    def fromBase64(base64: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fromBase64

        **[static] QByteArray QByteArray::fromBase64(const QByteArray & base64 , QByteArray::Base64Options options )**

        This is an overloaded function.

        Returns a decoded copy of the Base64 array **base64** , using the options defined by **options**. If **options** contains `IgnoreBase64DecodingErrors` (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If **options** contains `AbortOnBase64DecodingErrors`, then decoding will stop at the first invalid character.

        For example:

        **QByteArray** ::fromBase64("PHA+SGVsbG8/PC9wPg==", **QByteArray** ::Base64Encoding); // returns "<p>Hello?</p>"
            **QByteArray** ::fromBase64("PHA-SGVsbG8_PC9wPg==", **QByteArray** ::Base64UrlEncoding); // returns "<p>Hello?</p>"

        The algorithm used to decode Base64-encoded data is defined in **RFC 4648** .

        Returns the decoded data, or, if the `AbortOnBase64DecodingErrors` option was passed and the input data was invalid, an empty byte array.

        **Note:** The **fromBase64Encoding** () function is recommended in new code.

        This function was introduced in Qt 5.2.

        **See also** **toBase64** () and **fromBase64Encoding** ().
        """
        ...

    @typing.overload
    @staticmethod
    def fromBase64(
        base64: PySide2.QtCore.QByteArray,
        options: PySide2.QtCore.QByteArray.Base64Options,
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fromBase64

        **[static] QByteArray QByteArray::fromBase64(const QByteArray & base64 , QByteArray::Base64Options options )**

        This is an overloaded function.

        Returns a decoded copy of the Base64 array **base64** , using the options defined by **options**. If **options** contains `IgnoreBase64DecodingErrors` (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If **options** contains `AbortOnBase64DecodingErrors`, then decoding will stop at the first invalid character.

        For example:

        **QByteArray** ::fromBase64("PHA+SGVsbG8/PC9wPg==", **QByteArray** ::Base64Encoding); // returns "<p>Hello?</p>"
            **QByteArray** ::fromBase64("PHA-SGVsbG8_PC9wPg==", **QByteArray** ::Base64UrlEncoding); // returns "<p>Hello?</p>"

        The algorithm used to decode Base64-encoded data is defined in **RFC 4648** .

        Returns the decoded data, or, if the `AbortOnBase64DecodingErrors` option was passed and the input data was invalid, an empty byte array.

        **Note:** The **fromBase64Encoding** () function is recommended in new code.

        This function was introduced in Qt 5.2.

        **See also** **toBase64** () and **fromBase64Encoding** ().
        """
        ...

    @staticmethod
    def fromBase64Encoding(
        base64: PySide2.QtCore.QByteArray,
        options: PySide2.QtCore.QByteArray.Base64Options = ...,
    ) -> PySide2.QtCore.QByteArray.FromBase64Result:
        ...

    @staticmethod
    def fromHex(hexEncoded: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fromHex

        **[static] QByteArray QByteArray::fromHex(const QByteArray & hexEncoded )**

        Returns a decoded copy of the hex encoded array **hexEncoded**. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.

        For example:

        **QByteArray**  text = **QByteArray** ::fromHex("517420697320677265617421");
            text.data();            // returns "Qt is great!"

        **See also** **toHex** ().
        """
        ...

    @staticmethod
    def fromPercentEncoding(
        pctEncoded: PySide2.QtCore.QByteArray, percent: int = ...
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fromPercentEncoding

        **[static] QByteArray QByteArray::fromPercentEncoding(const QByteArray & input , char percent = \'%\')**

        Returns a decoded copy of the URI/URL-style percent-encoded **input**. The **percent** parameter allows you to replace the \'%\' character for another (for instance, \'_\' or \'=\').

        For example:

        **QByteArray**  text = **QByteArray** ::fromPercentEncoding("Qt%20is%20great%33");
            text.data();            // returns "Qt is great!"

        **Note:** Given invalid input (such as a string containing the sequence "%G5", which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence "%G5" could be decoded to \'W\'.

        This function was introduced in Qt 4.4.

        **See also** **toPercentEncoding** () and **QUrl::fromPercentEncoding** ().
        """
        ...

    @staticmethod
    def fromRawData(arg__1: bytes, size: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#fromRawData

        **[static] QByteArray QByteArray::fromRawData(const char * data , int size )**

        Constructs a **QByteArray**  that uses the first **size** bytes of the **data** array. The bytes are **not** copied. The **QByteArray**  will contain the **data** pointer. The caller guarantees that **data** will not be deleted or modified as long as this **QByteArray**  and any copies of it exist that have not been modified. In other words, because **QByteArray**  is an **implicitly shared**  class and the instance returned by this function contains the **data** pointer, the caller must not delete **data** or modify it directly as long as the returned **QByteArray**  and any copies exist. However, **QByteArray**  does not take ownership of **data** , so the **QByteArray**  destructor will never delete the raw **data** , even when the last **QByteArray**  referring to **data** is destroyed.

        A subsequent attempt to modify the contents of the returned **QByteArray**  or any copy made from it will cause it to create a deep copy of the **data** array before doing the modification. This ensures that the raw **data** array itself will never be modified by **QByteArray** .

        Here is an example of how to read data using a **QDataStream**  on raw data in memory without copying the raw data into a **QByteArray** :

        static const char mydata[] = {
                '\\x00', '\\x00', '\\x03', '\\x84', '\\x78', '\\x9c', '\\x3b', '\\x76',
                '\\xec', '\\x18', '\\xc3', '\\x31', '\\x0a', '\\xf1', '\\xcc', '\\x99',
                ...
                '\\x6d', '\\x5b'
            };

            **QByteArray**  data = **QByteArray** ::fromRawData(mydata, sizeof(mydata));
            **QDataStream**  in(&data, **QIODevice** ::ReadOnly);
            ...

        **Warning:** A byte array created with fromRawData() is **not** '\\0'-terminated, unless the raw data contains a 0 character at position **size**. While that does not matter for **QDataStream**  or functions like **indexOf** (), passing the byte array to a function accepting a `const char *` expected to be '\\0'-terminated will fail.

        **See also** **setRawData** (), **data** (), and **constData** ().
        """
        ...

    def front(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#front

        **char QByteArray::front() const**

        Returns the first character in the byte array. Same as `at(0)`.

        This function is provided for STL compatibility.

        **Warning:** Calling this function on an empty byte array constitutes undefined behavior.

        This function was introduced in Qt 5.10.

        **See also** **back** (), **at** (), and **operator[]** ().
        """
        ...

    def indexOf(self, a: PySide2.QtCore.QByteArray, from_: int = ...) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#indexOf

        **int QByteArray::indexOf(const QByteArray & ba , int from = 0) const**

        Returns the index position of the first occurrence of the byte array **ba** in this byte array, searching forward from index position **from**. Returns -1 if **ba** could not be found.

        Example:

        **QByteArray**  x("sticky question");
            **QByteArray**  y("sti");
            x.indexOf(y);               // returns 0
            x.indexOf(y, 1);            // returns 10
            x.indexOf(y, 10);           // returns 10
            x.indexOf(y, 11);           // returns -1

        **See also** **lastIndexOf** (), **contains** (), and **count** ().
        """
        ...

    @typing.overload
    def insert(self, i: int, a: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#insert

        **QByteArray &QByteArray::insert(int i , const QByteArray & ba )**

        Inserts the byte array **ba** at index position **i** and returns a reference to this byte array.

        Example:

        **QByteArray**  ba("Meal");
            ba.insert(1, **QByteArray** ("ontr"));
            // ba == "Montreal"

        **See also** **append** (), **prepend** (), **replace** (), and **remove** ().
        """
        ...

    @typing.overload
    def insert(self, i: int, count: int, c: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#insert

        **QByteArray &QByteArray::insert(int i , const QByteArray & ba )**

        Inserts the byte array **ba** at index position **i** and returns a reference to this byte array.

        Example:

        **QByteArray**  ba("Meal");
            ba.insert(1, **QByteArray** ("ontr"));
            // ba == "Montreal"

        **See also** **append** (), **prepend** (), **replace** (), and **remove** ().
        """
        ...

    def isEmpty(self) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#isEmpty

        **bool QByteArray::isEmpty() const**

        Returns `true` if the byte array has size 0; otherwise returns `false`.

        Example:

        **QByteArray** ().isEmpty();         // returns true
            **QByteArray** ("").isEmpty();       // returns true
            **QByteArray** ("abc").isEmpty();    // returns false

        **See also** **size** ().
        """
        ...

    def isLower(self) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#isLower

        **bool QByteArray::isLower() const**

        Returns `true` if this byte array contains only lowercase letters, otherwise returns `false`. The byte array is interpreted as a Latin-1 encoded string.

        This function was introduced in Qt 5.12.

        **See also** **isUpper** () and **toLower** ().
        """
        ...

    def isNull(self) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#isNull

        **bool QByteArray::isNull() const**

        Returns `true` if this byte array is null; otherwise returns `false`.

        Example:

        **QByteArray** ().isNull();          // returns true
            **QByteArray** ("").isNull();        // returns false
            **QByteArray** ("abc").isNull();     // returns false

        Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using **isEmpty** ().

        **See also** **isEmpty** ().
        """
        ...

    def isSharedWith(self, other: PySide2.QtCore.QByteArray) -> bool:
        ...

    def isUpper(self) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#isUpper

        **bool QByteArray::isUpper() const**

        Returns `true` if this byte array contains only uppercase letters, otherwise returns `false`. The byte array is interpreted as a Latin-1 encoded string.

        This function was introduced in Qt 5.12.

        **See also** **isLower** () and **toUpper** ().
        """
        ...

    def lastIndexOf(self, a: PySide2.QtCore.QByteArray, from_: int = ...) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#lastIndexOf

        **int QByteArray::lastIndexOf(const QByteArray & ba , int from = -1) const**

        Returns the index position of the last occurrence of the byte array **ba** in this byte array, searching backward from index position **from**. If **from** is -1 (the default), the search starts at the last byte. Returns -1 if **ba** could not be found.

        Example:

        **QByteArray**  x("crazy azimuths");
            **QByteArray**  y("az");
            x.lastIndexOf(y);           // returns 6
            x.lastIndexOf(y, 6);        // returns 6
            x.lastIndexOf(y, 5);        // returns 2
            x.lastIndexOf(y, 1);        // returns -1

        **See also** **indexOf** (), **contains** (), and **count** ().
        """
        ...

    def left(self, len: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#left

        **QByteArray QByteArray::left(int len ) const**

        Returns a byte array that contains the leftmost **len** bytes of this byte array.

        The entire byte array is returned if **len** is greater than **size** ().

        Example:

        **QByteArray**  x("Pineapple");
            **QByteArray**  y = x.left(4);
            // y == "Pine"

        **See also** **startsWith** (), **right** (), **mid** (), **chopped** (), **chop** (), and **truncate** ().
        """
        ...

    def leftJustified(
        self, width: int, fill: int = ..., truncate: bool = ...
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#leftJustified

        **QByteArray QByteArray::leftJustified(int width , char fill = \' \', bool truncate = false) const**

        Returns a byte array of size **width** that contains this byte array padded by the **fill** character.

        If **truncate** is false and the **size** () of the byte array is more than **width** , then the returned byte array is a copy of this byte array.

        If **truncate** is true and the **size** () of the byte array is more than **width** , then any bytes in a copy of the byte array after position **width** are removed, and the copy is returned.

        Example:

        **QByteArray**  x("apple");
            **QByteArray**  y = x.leftJustified(8, \'.\');   // y == "apple..."

        **See also** **rightJustified** ().
        """
        ...

    def length(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#length

        **int QByteArray::length() const**

        Same as **size** ().
        """
        ...

    def mid(self, index: int, len: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#mid

        **QByteArray QByteArray::mid(int pos , int len = -1) const**

        Returns a byte array containing **len** bytes from this byte array, starting at position **pos**.

        If **len** is -1 (the default), or **pos** \\+ **len** >= **size** (), returns a byte array containing all bytes starting at position **pos** until the end of the byte array.

        Example:

        **QByteArray**  x("Five pineapples");
            **QByteArray**  y = x.mid(5, 4);     // y == "pine"
            **QByteArray**  z = x.mid(5);        // z == "pineapples"

        **See also** **left** (), **right** (), **chopped** (), **chop** (), and **truncate** ().
        """
        ...

    @typing.overload
    @staticmethod
    def number(
        arg__1: float, f: int = ..., prec: int = ...
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#number

        **[static] QByteArray QByteArray::number(int n , int base = 10)**

        Returns a byte array containing the string equivalent of the number **n** to base **base** (10 by default). The **base** can be any value between 2 and 36.

        Example:

        int n = 63;
            **QByteArray** ::number(n);              // returns "63"
            **QByteArray** ::number(n, 16);          // returns "3f"
            **QByteArray** ::number(n, 16).toUpper();  // returns "3F"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **setNum** () and **toInt** ().
        """
        ...

    @typing.overload
    @staticmethod
    def number(arg__1: int, base: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#number

        **[static] QByteArray QByteArray::number(int n , int base = 10)**

        Returns a byte array containing the string equivalent of the number **n** to base **base** (10 by default). The **base** can be any value between 2 and 36.

        Example:

        int n = 63;
            **QByteArray** ::number(n);              // returns "63"
            **QByteArray** ::number(n, 16);          // returns "3f"
            **QByteArray** ::number(n, 16).toUpper();  // returns "3F"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **setNum** () and **toInt** ().
        """
        ...

    @typing.overload
    @staticmethod
    def number(arg__1: int, base: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#number

        **[static] QByteArray QByteArray::number(int n , int base = 10)**

        Returns a byte array containing the string equivalent of the number **n** to base **base** (10 by default). The **base** can be any value between 2 and 36.

        Example:

        int n = 63;
            **QByteArray** ::number(n);              // returns "63"
            **QByteArray** ::number(n, 16);          // returns "3f"
            **QByteArray** ::number(n, 16).toUpper();  // returns "3F"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **setNum** () and **toInt** ().
        """
        ...

    @typing.overload
    def prepend(self, a: PySide2.QtCore.QByteArray) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#prepend

        **QByteArray &QByteArray::prepend(const QByteArray & ba )**

        Prepends the byte array **ba** to this byte array and returns a reference to this byte array.

        Example:

        **QByteArray**  x("ship");
            **QByteArray**  y("air");
            x.prepend(y);
            // x == "airship"

        This is the same as insert(0, **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being prepended to is not empty, a deep copy of the data is performed, taking **linear time** .

        **See also** **append** () and **insert** ().
        """
        ...

    @typing.overload
    def prepend(self, c: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#prepend

        **QByteArray &QByteArray::prepend(const QByteArray & ba )**

        Prepends the byte array **ba** to this byte array and returns a reference to this byte array.

        Example:

        **QByteArray**  x("ship");
            **QByteArray**  y("air");
            x.prepend(y);
            // x == "airship"

        This is the same as insert(0, **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being prepended to is not empty, a deep copy of the data is performed, taking **linear time** .

        **See also** **append** () and **insert** ().
        """
        ...

    @typing.overload
    def prepend(self, count: int, c: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#prepend

        **QByteArray &QByteArray::prepend(const QByteArray & ba )**

        Prepends the byte array **ba** to this byte array and returns a reference to this byte array.

        Example:

        **QByteArray**  x("ship");
            **QByteArray**  y("air");
            x.prepend(y);
            // x == "airship"

        This is the same as insert(0, **ba** ).

        Note: **QByteArray**  is an **implicitly shared**  class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in **ba**. In this case, no copying of data is done, taking **constant time** . If a shared instance is modified, it will be copied (copy-on-write), taking **linear time** .

        If the byte array being prepended to is not empty, a deep copy of the data is performed, taking **linear time** .

        **See also** **append** () and **insert** ().
        """
        ...

    def remove(self, index: int, len: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#remove

        **QByteArray &QByteArray::remove(int pos , int len )**

        Removes **len** bytes from the array, starting at index position **pos** , and returns a reference to the array.

        If **pos** is out of range, nothing happens. If **pos** is valid, but **pos** \\+ **len** is larger than the size of the array, the array is truncated at position **pos**.

        Example:

        **QByteArray**  ba("Montreal");
            ba.remove(1, 4);
            // ba == "Meal"

        **See also** **insert** () and **replace** ().
        """
        ...

    def repeated(self, times: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#repeated

        **QByteArray QByteArray::repeated(int times ) const**

        Returns a copy of this byte array repeated the specified number of **times**.

        If **times** is less than 1, an empty byte array is returned.

        Example:

        **QByteArray**  ba("ab");
            ba.repeated(4);             // returns "abababab"

        This function was introduced in Qt 4.5.
        """
        ...

    @typing.overload
    def replace(
        self, before: PySide2.QtCore.QByteArray, after: PySide2.QtCore.QByteArray
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#replace

        **QByteArray &QByteArray::replace(int pos , int len , const QByteArray & after )**

        Replaces **len** bytes from index position **pos** with the byte array **after** , and returns a reference to this byte array.

        Example:

        **QByteArray**  x("Say yes!");
            **QByteArray**  y("no");
            x.replace(4, 3, y);
            // x == "Say no!"

        **See also** **insert** () and **remove** ().
        """
        ...

    @typing.overload
    def replace(
        self, before: str, after: PySide2.QtCore.QByteArray
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#replace

        **QByteArray &QByteArray::replace(int pos , int len , const QByteArray & after )**

        Replaces **len** bytes from index position **pos** with the byte array **after** , and returns a reference to this byte array.

        Example:

        **QByteArray**  x("Say yes!");
            **QByteArray**  y("no");
            x.replace(4, 3, y);
            // x == "Say no!"

        **See also** **insert** () and **remove** ().
        """
        ...

    @typing.overload
    def replace(
        self, before: int, after: PySide2.QtCore.QByteArray
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#replace

        **QByteArray &QByteArray::replace(int pos , int len , const QByteArray & after )**

        Replaces **len** bytes from index position **pos** with the byte array **after** , and returns a reference to this byte array.

        Example:

        **QByteArray**  x("Say yes!");
            **QByteArray**  y("no");
            x.replace(4, 3, y);
            // x == "Say no!"

        **See also** **insert** () and **remove** ().
        """
        ...

    @typing.overload
    def replace(self, before: int, after: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#replace

        **QByteArray &QByteArray::replace(int pos , int len , const QByteArray & after )**

        Replaces **len** bytes from index position **pos** with the byte array **after** , and returns a reference to this byte array.

        Example:

        **QByteArray**  x("Say yes!");
            **QByteArray**  y("no");
            x.replace(4, 3, y);
            // x == "Say no!"

        **See also** **insert** () and **remove** ().
        """
        ...

    @typing.overload
    def replace(
        self, index: int, len: int, s: PySide2.QtCore.QByteArray
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#replace

        **QByteArray &QByteArray::replace(int pos , int len , const QByteArray & after )**

        Replaces **len** bytes from index position **pos** with the byte array **after** , and returns a reference to this byte array.

        Example:

        **QByteArray**  x("Say yes!");
            **QByteArray**  y("no");
            x.replace(4, 3, y);
            // x == "Say no!"

        **See also** **insert** () and **remove** ().
        """
        ...

    def reserve(self, size: int) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#reserve

        **void QByteArray::reserve(int size )**

        Attempts to allocate memory for at least **size** bytes. If you know in advance how large the byte array will be, you can call this function, and if you call **resize** () often you are likely to get better performance. If **size** is an underestimate, the worst that will happen is that the **QByteArray**  will be a bit slower.

        The sole purpose of this function is to provide a means of fine tuning **QByteArray** 's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call **resize** ().

        **See also** **squeeze** () and **capacity** ().
        """
        ...

    def resize(self, size: int) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#resize

        **void QByteArray::resize(int size )**

        Sets the size of the byte array to **size** bytes.

        If **size** is greater than the current size, the byte array is extended to make it **size** bytes with the extra bytes added to the end. The new bytes are uninitialized.

        If **size** is less than the current size, bytes are removed from the end.

        **See also** **size** () and **truncate** ().
        """
        ...

    def right(self, len: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#right

        **QByteArray QByteArray::right(int len ) const**

        Returns a byte array that contains the rightmost **len** bytes of this byte array.

        The entire byte array is returned if **len** is greater than **size** ().

        Example:

        **QByteArray**  x("Pineapple");
            **QByteArray**  y = x.right(5);
            // y == "apple"

        **See also** **endsWith** (), **left** (), **mid** (), **chopped** (), **chop** (), and **truncate** ().
        """
        ...

    def rightJustified(
        self, width: int, fill: int = ..., truncate: bool = ...
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#rightJustified

        **QByteArray QByteArray::rightJustified(int width , char fill = \' \', bool truncate = false) const**

        Returns a byte array of size **width** that contains the **fill** character followed by this byte array.

        If **truncate** is false and the size of the byte array is more than **width** , then the returned byte array is a copy of this byte array.

        If **truncate** is true and the size of the byte array is more than **width** , then the resulting byte array is truncated at position **width**.

        Example:

        **QByteArray**  x("apple");
            **QByteArray**  y = x.rightJustified(8, \'.\');    // y == "...apple"

        **See also** **leftJustified** ().
        """
        ...

    @typing.overload
    def setNum(
        self, arg__1: float, f: int = ..., prec: int = ...
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#setNum

        **QByteArray &QByteArray::setNum(int n , int base = 10)**

        Sets the byte array to the printed value of **n** in base **base** (10 by default) and returns a reference to the byte array. The **base** can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.

        Example:

        **QByteArray**  ba;
            int n = 63;
            ba.setNum(n);           // ba == "63"
            ba.setNum(n, 16);       // ba == "3f"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **number** () and **toInt** ().
        """
        ...

    @typing.overload
    def setNum(self, arg__1: int, base: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#setNum

        **QByteArray &QByteArray::setNum(int n , int base = 10)**

        Sets the byte array to the printed value of **n** in base **base** (10 by default) and returns a reference to the byte array. The **base** can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.

        Example:

        **QByteArray**  ba;
            int n = 63;
            ba.setNum(n);           // ba == "63"
            ba.setNum(n, 16);       // ba == "3f"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **number** () and **toInt** ().
        """
        ...

    @typing.overload
    def setNum(self, arg__1: int, base: int = ...) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#setNum

        **QByteArray &QByteArray::setNum(int n , int base = 10)**

        Sets the byte array to the printed value of **n** in base **base** (10 by default) and returns a reference to the byte array. The **base** can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.

        Example:

        **QByteArray**  ba;
            int n = 63;
            ba.setNum(n);           // ba == "63"
            ba.setNum(n, 16);       // ba == "3f"

        **Note:** The format of the number is not localized; the default C locale is used irrespective of the user\'s locale.

        **See also** **number** () and **toInt** ().
        """
        ...

    def setRawData(self, a: bytes, n: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#setRawData

        **QByteArray &QByteArray::setRawData(const char * data , uint size )**

        Resets the **QByteArray**  to use the first **size** bytes of the **data** array. The bytes are **not** copied. The **QByteArray**  will contain the **data** pointer. The caller guarantees that **data** will not be deleted or modified as long as this **QByteArray**  and any copies of it exist that have not been modified.

        This function can be used instead of **fromRawData** () to re-use existing **QByteArray**  objects to save memory re-allocations.

        This function was introduced in Qt 4.7.

        **See also** **fromRawData** (), **data** (), and **constData** ().
        """
        ...

    def shrink_to_fit(self) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#shrink_to_fit

        **void QByteArray::shrink_to_fit()**

        This function is provided for STL compatibility. It is equivalent to **squeeze** ().

        This function was introduced in Qt 5.10.
        """
        ...

    def simplified(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#simplified

        **QByteArray QByteArray::simplified() const**

        Returns a byte array that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.

        Whitespace means any character for which the standard C++ `isspace()` function returns `true` in the C locale. This includes the ASCII isspace() function returns `true` in the C locale. This includes the ASCII characters \'\\t\', \'\\n\', \'\\v\', \'\\f\', \'\\r\', and \' \'.

        Example:

        **QByteArray**  ba("  lots\\t of\\nwhitespace\\r\\n ");
            ba = ba.simplified();
            // ba == "lots of whitespace";

        **See also** **trimmed** ().
        """
        ...

    def size(self) -> int:
        """
        https://doc.qt.io/qt-5/qbytearray.html#size

        **int QByteArray::size() const**

        Returns the number of bytes in this byte array.

        The last byte in the byte array is at position size() - 1. In addition, **QByteArray**  ensures that the byte at position size() is always \'\\0\', so that you can use the return value of **data** () and **constData** () as arguments to functions that expect \'\\0\'-terminated strings. If the **QByteArray**  object was created from a **raw data**  that didn\'t include the trailing null-termination character then **QByteArray**  doesn\'t add it automaticall unless the **deep copy**  is created.

        Example:

        **QByteArray**  ba("Hello");
            int n = ba.size();          // n == 5
            ba.data()[0];               // returns \'H\'
            ba.data()[4];               // returns \'o\'
            ba.data()[5];               // returns \'\\0\'

        **See also** **isEmpty** () and **resize** ().
        """
        ...

    def split(self, sep: int) -> typing.List:
        """
        https://doc.qt.io/qt-5/qbytearray.html#split

        **QList<QByteArray> QByteArray::split(char sep ) const**

        Splits the byte array into subarrays wherever **sep** occurs, and returns the list of those arrays. If **sep** does not match anywhere in the byte array, split() returns a single-element list containing this byte array.
        """
        ...

    def squeeze(self) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#squeeze

        **void QByteArray::squeeze()**

        Releases any memory not required to store the array's data.

        The sole purpose of this function is to provide a means of fine tuning **QByteArray** 's memory usage. In general, you will rarely ever need to call this function.

        **See also** **reserve** () and **capacity** ().
        """
        ...

    @typing.overload
    def startsWith(self, a: PySide2.QtCore.QByteArray) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#startsWith

        **bool QByteArray::startsWith(const QByteArray & ba ) const**

        Returns `true` if this byte array starts with byte array **ba** ; otherwise returns `false`.

        Example:

        **QByteArray**  url("ftp://ftp.qt-project.org/");
            if (url.startsWith("ftp:"))
                ...

        **See also** **endsWith** () and **left** ().
        """
        ...

    @typing.overload
    def startsWith(self, c: int) -> bool:
        """
        https://doc.qt.io/qt-5/qbytearray.html#startsWith

        **bool QByteArray::startsWith(const QByteArray & ba ) const**

        Returns `true` if this byte array starts with byte array **ba** ; otherwise returns `false`.

        Example:

        **QByteArray**  url("ftp://ftp.qt-project.org/");
            if (url.startsWith("ftp:"))
                ...

        **See also** **endsWith** () and **left** ().
        """
        ...

    def swap(self, other: PySide2.QtCore.QByteArray) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#swap

        **void QByteArray::swap(QByteArray & other )**

        Swaps byte array **other** with this byte array. This operation is very fast and never fails.

        This function was introduced in Qt 4.8.
        """
        ...

    @typing.overload
    def toBase64(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toBase64

        **QByteArray QByteArray::toBase64() const**

        Returns a copy of the byte array, encoded as Base64.

        **QByteArray**  text("Qt is great!");
            text.toBase64();        // returns "UXQgaXMgZ3JlYXQh"

        The algorithm used to encode Base64-encoded data is defined in **RFC 4648** .

        **See also** **fromBase64** ().
        """
        ...

    @typing.overload
    def toBase64(
        self, options: PySide2.QtCore.QByteArray.Base64Options
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toBase64

        **QByteArray QByteArray::toBase64() const**

        Returns a copy of the byte array, encoded as Base64.

        **QByteArray**  text("Qt is great!");
            text.toBase64();        // returns "UXQgaXMgZ3JlYXQh"

        The algorithm used to encode Base64-encoded data is defined in **RFC 4648** .

        **See also** **fromBase64** ().
        """
        ...

    def toDouble(self) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toDouble

        **double QByteArray::toDouble(bool * ok = nullptr) const**

        Returns the byte array converted to a `double` value.

        Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **QByteArray**  string("1234.56");
            bool ok;
            double a = string.toDouble(&ok);   // a == 1234.56, ok == true

            string = "1234.56 Volt";
            a = str.toDouble(&ok);             // a == 0, ok == false

        **Warning:** The **QByteArray**  content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        This function ignores leading and trailing whitespace.

        **See also** **number** ().
        """
        ...

    def toFloat(self) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toFloat

        **float QByteArray::toFloat(bool * ok = nullptr) const**

        Returns the byte array converted to a `float` value.

        Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **QByteArray**  string("1234.56");
            bool ok;
            float a = string.toFloat(&ok);    // a == 1234.56, ok == true

            string = "1234.56 Volt";
            a = str.toFloat(&ok);              // a == 0, ok == false

        **Warning:** The **QByteArray**  content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        This function ignores leading and trailing whitespace.

        **See also** **number** ().
        """
        ...

    @typing.overload
    def toHex(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toHex

        **QByteArray QByteArray::toHex() const**

        Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.

        **See also** **fromHex** ().
        """
        ...

    @typing.overload
    def toHex(self, separator: int) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toHex

        **QByteArray QByteArray::toHex() const**

        Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.

        **See also** **fromHex** ().
        """
        ...

    def toInt(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toInt

        **int QByteArray::toInt(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to an `int` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **QByteArray**  str("FF");
            bool ok;
            int hex = str.toInt(&ok, 16);     // hex == 255, ok == true
            int dec = str.toInt(&ok, 10);     // dec == 0, ok == false

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toLong(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toLong

        **long QByteArray::toLong(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to a `long` int using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **QByteArray**  str("FF");
            bool ok;
            long hex = str.toLong(&ok, 16);   // hex == 255, ok == true
            long dec = str.toLong(&ok, 10);   // dec == 0, ok == false

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        This function was introduced in Qt 4.1.

        **See also** **number** ().
        """
        ...

    def toLongLong(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toLongLong

        **qlonglong QByteArray::toLongLong(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to a `long long` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toLower(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toLower

        **QByteArray QByteArray::toLower() const**

        Returns a lowercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.

        Example:

        **QByteArray**  x("Qt by THE QT COMPANY");
            **QByteArray**  y = x.toLower();
            // y == "qt by the qt company"

        **See also** **isLower** (), **toUpper** (), and **8-bit Character Comparisons** .
        """
        ...

    def toPercentEncoding(
        self,
        exclude: PySide2.QtCore.QByteArray = ...,
        include: PySide2.QtCore.QByteArray = ...,
        percent: int = ...,
    ) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toPercentEncoding

        **QByteArray QByteArray::toPercentEncoding(const QByteArray & exclude = QByteArray(), const QByteArray & include = QByteArray(), char percent = \'%\') const**

        Returns a URI/URL-style percent-encoded copy of this byte array. The **percent** parameter allows you to override the default \'%\' character for another.

        By default, this function will encode all characters that are not one of the following:

        ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." / "_" / "~"

        To prevent characters from being encoded pass them to **exclude**. To force characters to be encoded pass them to **include**. The **percent** character is always encoded.

        Example:

        **QByteArray**  text = "{a fishy string?}";
            **QByteArray**  ba = text.toPercentEncoding("{}", "s");
            **qDebug** (ba.constData());
            // prints "{a fi%73hy %73tring%3F}"

        The hex encoding uses the numbers 0-9 and the uppercase letters A-F.

        This function was introduced in Qt 4.4.

        **See also** **fromPercentEncoding** () and **QUrl::toPercentEncoding** ().
        """
        ...

    def toShort(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toShort

        **short QByteArray::toShort(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to a `short` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toUInt(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toUInt

        **uint QByteArray::toUInt(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to an `unsigned int` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toULong(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toULong

        **ulong QByteArray::toULong(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to an `unsigned long int` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        This function was introduced in Qt 4.1.

        **See also** **number** ().
        """
        ...

    def toULongLong(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toULongLong

        **qulonglong QByteArray::toULongLong(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to an `unsigned long long` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toUShort(self, base: int = ...) -> typing.Tuple:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toUShort

        **ushort QByteArray::toUShort(bool * ok = nullptr, int base = 10) const**

        Returns the byte array converted to an `unsigned short` using base **base** , which is 10 by default and must be between 2 and 36, or 0.

        If **base** is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

        Returns 0 if the conversion fails.

        If **ok** is not `nullptr`, failure is reported by setting * **ok** to `false`, and success by setting * **ok** to `true`.

        **Note:** The conversion of the number is performed in the default C locale, irrespective of the user\'s locale.

        **See also** **number** ().
        """
        ...

    def toUpper(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#toUpper

        **QByteArray QByteArray::toUpper() const**

        Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.

        Example:

        **QByteArray**  x("Qt by THE QT COMPANY");
            **QByteArray**  y = x.toUpper();
            // y == "QT BY THE QT COMPANY"

        **See also** **isUpper** (), **toLower** (), and **8-bit Character Comparisons** .
        """
        ...

    def trimmed(self) -> PySide2.QtCore.QByteArray:
        """
        https://doc.qt.io/qt-5/qbytearray.html#trimmed

        **QByteArray QByteArray::trimmed() const**

        Returns a byte array that has whitespace removed from the start and the end.

        Whitespace means any character for which the standard C++ `isspace()` function returns `true` in the C locale. This includes the ASCII characters \'\\t\', \'\\n\', \'\\v\', \'\\f\', \'\\r\', and \' \'.

        Example:

        **QByteArray**  ba("  lots\\t of\\nwhitespace\\r\\n ");
            ba = ba.trimmed();
            // ba == "lots\\t of\\nwhitespace";

        Unlike **simplified** (), trimmed() leaves internal whitespace alone.

        **See also** **simplified** ().
        """
        ...

    def truncate(self, pos: int) -> None:
        """
        https://doc.qt.io/qt-5/qbytearray.html#truncate

        **void QByteArray::truncate(int pos )**

        Truncates the byte array at index position **pos**.

        If **pos** is beyond the end of the array, nothing happens.

        Example:

        **QByteArray**  ba("Stockholm");
            ba.truncate(5);             // ba == "Stock"

        **See also** **chop** (), **resize** (), and **left** ().
        """
        ...
