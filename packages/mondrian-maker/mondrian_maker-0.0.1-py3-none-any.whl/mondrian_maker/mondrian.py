# mondrian_maker/mondrianMaker.py

import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import uuid
import argparse


class mondrian():

    def __init__(self, array_size=100):
        '''
        Class that generates Mondrian-style image.

        parameters:
            array_size : int, default 100; if passed, the "data" arrays generated by cls.make_mondrian
                            have a.size = self.array_size
        '''
        self.create_colormap()
        self.array_size = array_size

    def create_colormap(self, colors=None):
        '''
        Creates matplotlib linear segmented colormap
            https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html

        parameters:
            colors : list-like (default None); should contain list of either rgb or hexcode strings 
                        for colors to be used in a LinerSegmented colormap

        returns:
            cmap : matplotlib.LinearSegmentedColormap instance; 
                        contains mondrian primary colors if no color list is passed by user
        '''
        # Mondrian-style colors
        if colors:
            pass
        else:
            colors = ["#ffffff", "#225095", "#dd0100", "#fac901"]
        self.cmap = LinearSegmentedColormap.from_list("Mondrian", colors, N=len(colors))
        # return cmap

    def make_mondrian(self, x=None, y=None, bins=None, gridlines: bool =  True, title=False, savefig=False):
        """
        Creates Mondrian-style plot using randomly-generated numbers 
            (via numpy.random module) and matplotlib.

        parameters:
            x, y : 1-D array-like; if passed, these arrays are used for the datasets in the resulting image.
            bins : array-like; Bin arrays for the x and y data (should be shaped as [xbins, ybins] 
                                where xbinsa dn ybins are both array-like object of bin edges)
            gridlines: boolean, default True; if False, black gridlines will not be drawn into figure overtop of 2d histogram
            title : str or bool; if str, that will be passed as the fig title.
                                 If boolean, a randomly-generated hex (via uuid)
                                 is generated and used as the figure title
            savefig : bool, default False; if True, save pdf of figure
                                to plots/mondrian dir

        returns:
            f, ax : matplotlib Figure and Axes objects. Contain plot created
        """
        # Generating random bin edges for
        bin_sizes = np.random.randint(5,12)
        x_bins = sorted(np.random.rand(bin_sizes))
        y_bins = sorted(np.random.rand(bin_sizes))

        # if bins passed by user, use those
        if bins:
            x_bins = bins[0]
            y_bins = bins[1]
        
        # If x and y are None, generated random dataset for each 'direction'
        # Else, use the arrays passed 
        if x is None: # and y is None:
            x = np.random.random(self.array_size)

        if y is None:
            y = np.random.random(self.array_size)

        elif x.any() or y.any():
            x, y = x, y 

        # Plotting 2d histogram
        f, ax = plt.subplots()
        ax.hist2d(x, y, bins=[x_bins, y_bins], cmap=self.cmap)

        # Default function param plots black gridlines
        if gridlines:
            plt.hlines(y_bins, xmin=0, xmax=1, color='0', linewidths=4)
            plt.vlines(x_bins, ymin=0, ymax=1, color='0', linewidths=4)
        else:
            ax.set_axis_off()
        
        ax.set_xticks([])
        ax.set_yticks([])
        
        # Setting title if user passed str
        if title and type(title)==str:
            f.suptitle(title)

        # Setting title as random hex if desired by user
        elif title and type(title) != str:
            title_hex = uuid.uuid4().hex
            f.suptitle(title_hex)

        else:
            title = ''

        # Saving fig if desired by user
        if savefig:
            # index = np.random.randint(0,100000)
            if title:
                fig_path = os.path.join("..",
                                   "plots", "mondrian",
                                   f"mondrian_{title}.pdf")
            else:
                index = uuid.uuid4().hex
                fig_path = os.path.join("..",
                                   "plots", "mondrian",
                                   f"mondrian_{index}.pdf")
            print(f'Saving Mondrian image to path: {fig_path}')
            f.savefig(fig_path)
        
        plt.show()

        return f, ax


if __name__ == "__main__":
    # Grabbing any command line args
    parser = argparse.ArgumentParser(description='Mondrian arg parser')
    parser.add_argument('--array_size', type=int, nargs='?', const=1, default=100, help='Size of x and y arrays to be generated')
    parser.add_argument('--title', type=str, help='String to be used as figure title')
    parser.add_argument('--n_plots', type=int,
                        nargs='?', const=1,
                        default=1, help='number of plots to maker (defualt 1)')
    parser.add_argument('--savefig', type=bool, help='whether or not to save the figure as a pdf')
    args = parser.parse_args()

    # Getting command line args
    array_size = args.array_size
    title = args.title
    n_plots = args.n_plots
    savefig = args.savefig

    m = mondrian(array_size=array_size)
    # Generating random # of plots
    print(f'Generating {n_plots} mondrian plot(s)')

    # Generating some # of plots
    for _ in range(0, n_plots):
        m.make_mondrian(title=title, savefig=savefig)

