# Copyright (C) 2009-2022, Ecole Polytechnique Federale de Lausanne (EPFL) and
# Hospital Center and University of Lausanne (UNIL-CHUV), Switzerland, and CMP3 contributors
# All rights reserved.
#
#  This software is distributed under the open-source license Modified BSD.

"""The Camino module provides Nipype interfaces for Camino functions missing in nipype or modified.

.. note:

    Module not used anymore by CMP3.

"""

import os
from nipype.interfaces.base import (CommandLineInputSpec, CommandLine, traits,
                                    TraitedSpec, File, StdOutCommandLine,
                                    StdOutCommandLineInputSpec, InputMultiPath)
from nipype.utils.filemanip import split_filename


class DTLUTGenInputSpec(StdOutCommandLineInputSpec):
    lrange = traits.List(traits.Float, desc='Index to one-tensor LUTs. This is the ratio L1/L3 and L2 / L3.'
                                            'The LUT is square, with half the values calculated (because L2 / L3 cannot be less than L1 / L3 by definition).'
                                            'The minimum must be >= 1. For comparison, a ratio L1 / L3 = 10 with L2 / L3 = 1 corresponds to an FA of 0.891, '
                                            'and L1 / L3 = 15 with L2 / L3 = 1 corresponds to an FA of 0.929. The default range is 1 to 10.',
                         argstr='-lrange %s', minlen=2, maxlen=2, position=1,
                         units='NA')

    frange = traits.List(traits.Float, desc='Index to two-tensor LUTs. This is the fractional anisotropy \
        of the two tensors. The default is 0.3 to 0.94',
                         argstr='-frange %s', minlen=2, maxlen=2, position=1,
                         units='NA')

    step = traits.Float(argstr='-step %d', units='NA',
                        desc='Distance between points in the LUT.'
                             'For example, if lrange is 1 to 10 and the step is 0.1, LUT entries will be computed '
                             'at L1 / L3 = 1, 1.1, 1.2 ... 10.0 and at L2 / L3 = 1.0, 1.1 ... L1 / L3.'
                             'For single tensor LUTs, the default step is 0.2, for two-tensor LUTs it is 0.02.')

    samples = traits.Int(argstr='-samples %d', units='NA',
                         desc='The number of synthetic measurements to generate at each point in the LUT. The default is 2000.')

    snr = traits.Float(argstr='-snr %d', units='NA',
                       desc='The signal to noise ratio of the unweighted (q = 0) measurements.'
                            'This should match the SNR (in white matter) of the images that the LUTs are used with.')

    bingham = traits.Bool(
        argstr='-bingham', desc="Compute a LUT for the Bingham PDF. This is the default.")

    acg = traits.Bool(argstr='-acg', desc="Compute a LUT for the ACG PDF.")

    watson = traits.Bool(
        argstr='-watson', desc="Compute a LUT for the Watson PDF.")

    inversion = traits.Int(argstr='-inversion %d', units='NA',
                           desc='Index of the inversion to use. The default is 1 (linear single tensor inversion).')

    trace = traits.Float(argstr='-trace %f', units='NA',
                         desc='Trace of the diffusion tensor(s) used in the test function in the LUT generation. The default is 2100E-12 m^2 s^-1.')

    scheme_file = File(argstr='-schemefile %s', mandatory=True, position=2,
                       desc='The scheme file of the images to be processed using this LUT.')

    cross = traits.Float(argstr='-cross %d',
                         desc='The angle in degrees between the principal directions of the two tensors.')


class DTLUTGenOutputSpec(TraitedSpec):
    dtLUT = File(exists=True, desc='Lookup Table')


class DTLUTGen(StdOutCommandLine):
    """Calibrates the PDFs for PICo probabilistic tractography.

    This program needs to be run once for every acquisition scheme.
    It outputs a lookup table that is used by the dtpicoparams program to find PICo PDF parameters for an image.
    The default single tensor LUT contains parameters of the Bingham distribution and is generated by supplying
    a scheme file and an estimated signal to noise in white matter regions of the (q=0) image.
    The default inversion is linear (inversion index 1).

    Advanced users can control several options, including the extent and resolution of the LUT,
    the inversion index, and the type of PDF. See dtlutgen(1) for details.

    Example
    -------
    >>> import cmtklib.interfaces.camino as cmon
    >>> dtl = cmon.DTLUTGen()
    >>> dtl.inputs.snr = 16
    >>> dtl.inputs.scheme_file = 'A.scheme'
    >>> dtl.run()  # doctest: +SKIP

    """

    _cmd = 'dtlutgen'
    input_spec = DTLUTGenInputSpec
    output_spec = DTLUTGenOutputSpec

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['dtLUT'] = os.path.abspath(self._gen_outfilename())
        return outputs

    def _gen_outfilename(self):
        _, name, _ = split_filename(self.inputs.scheme_file)
        return name + '.dat'


class PicoPDFsInputSpec(StdOutCommandLineInputSpec):
    in_file = File(exists=True, argstr='< %s', mandatory=True, position=1,
                   desc='voxel-order data filename')

    inputmodel = traits.Enum('dt', 'multitensor', 'pds',
                             argstr='-inputmodel %s', position=2, desc='input model type', usedefault=True)

    luts = InputMultiPath(File(exists=True), argstr='-luts %s', position=3,
                          mandatory=False,
                          desc='Files containing the lookup tables.'
                               'For tensor data, one lut must be specified for each type of inversion used'
                               'in the image (one-tensor, two-tensor, three-tensor).'
                               'For pds, the number of LUTs must match -numpds (it is acceptable to use'
                               'the same LUT several times - see example, above).'
                               'These LUTs may be generated with dtlutgen.')

    # lut_str = traits.Str()

    pdf = traits.Enum('watson', 'bingham', 'acg',
                      argstr='-pdf %s', position=4, desc=' Specifies the PDF to use. There are three choices:'
                                                         'watson - The Watson distribution. This distribution is'
                                                         'rotationally symmetric.'
                                                         'bingham - The Bingham distributionn, which allows'
                                                         'elliptical probability density contours.'
                                                         'acg - The Angular Central Gaussian distribution, which'
                                                         'also allows elliptical probability density contours',
                      usedefault=True)

    directmap = traits.Bool(argstr='-directmap',
                            desc="""Only applicable when using pds as the inputmodel
                                    Use direct mapping between the eigenvalues and the
                                    distribution parameters instead of the log of the eigenvalues.""")

    maxcomponents = traits.Int(argstr='-maxcomponents %d', units='NA',
                               desc='The maximum number of tensor components in a voxel (default 2) for multitensor data.'
                                    'Currently, only the default is supported, but future releases may allow'
                                    'the input of three-tensor data using this option.')

    numpds = traits.Int(argstr='-numpds %d', units='NA',
                        desc='The maximum number of PDs in a voxel (default 3) for PD data.'
                             'This option determines the size of the input and output voxels.'
                             'This means that the data file may be large enough to accomodate three or more PDs,'
                             'but does not mean that any of the voxels are classified as containing three or more PDs.')


class PicoPDFsOutputSpec(TraitedSpec):
    pdfs = File(exists=True, desc='path/name of 4D volume in voxel order')


class PicoPDFs(StdOutCommandLine):
    """Constructs a spherical PDF in each voxel for probabilistic tractography.

    Example
    -------
    >>> import cmtklib.interfaces.camino as cmon
    >>> pdf = cmon.PicoPDFs()
    >>> pdf.inputs.inputmodel = 'dt'
    >>> pdf.inputs.luts = 'lut_file'
    >>> pdf.inputs.in_file = 'voxel-order_data.Bfloat'
    >>> pdf.run()  # doctest: +SKIP

    """

    _cmd = 'picopdfs'
    input_spec = PicoPDFsInputSpec
    output_spec = PicoPDFsOutputSpec

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['pdfs'] = os.path.abspath(self._gen_outfilename())
        return outputs

    def _gen_outfilename(self):
        _, name, _ = split_filename(self.inputs.in_file)
        return name + '_pdfs.Bdouble'


class Voxel2ImageInputSpec(StdOutCommandLineInputSpec):
    in_file = File(exists=True, argstr='-inputfile %s', position=1,
                   mandatory=True,
                   desc='image in camino format')
    header_file = File(exists=True, mandatory=True, argstr='-header %s',
                       position=2, desc="file with desired format")
    components = traits.Int(argstr='-components %d', mandatory=False,
                            desc="Number of components in inputfile")
    gzip = traits.Bool(argstr="-gzip", mandatory=False,
                       desc="Compress output image")
    out_type = traits.Enum("float", "char", "short", "int", "long", "double", argstr='-outputdatatype %s',
                           desc='"i.e. Bfloat". Can be "char", "short", "int", "long", "float" or "double"',
                           usedefault=True)
    output_root = traits.Str(
        argstr="-outputroot %s", position=-1, default_value='converted', usedefault=True)


class Voxel2ImageOutputSpec(TraitedSpec):
    image_file = File(exists=True, desc='path/name to converted file')


class Voxel2Image(StdOutCommandLine):
    """Converts voxel order image to NIFTI / MHA files.

    Converts voxel-order data to scanner-order data in a supported image format.

    Examples
    --------
    >>> import cmtklib.interfaces.camino as cmon
    >>> vox2img = cmon.Voxel2Image()
    >>> vox2img.inputs.in_file = 'fa.img'
    >>> vox2img.run()  # doctest: +SKIP

    """

    _cmd = 'voxel2image'
    input_spec = Voxel2ImageInputSpec
    output_spec = Voxel2ImageOutputSpec

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['image_file'] = os.path.abspath(self._gen_outfilename())
        return outputs

    def _gen_outfilename(self):
        _, _, ext = split_filename(self.inputs.header_file)
        return self.inputs.output_root + ext
